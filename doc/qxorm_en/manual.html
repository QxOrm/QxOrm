<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Home</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Download</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Quick sample</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutorial (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manual (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">QxOrm manual</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">QxEntityEditor manual</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Our customers</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Manual - QxOrm library user guide</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Current version :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.4.3 - <a href="../doxygen/index.html" target="_blank">QxOrm library online class documentation</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.1</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/manual.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/manual.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
      <script>$(function() { initQxOrmManualWebPage(); });</script>
      <table border="0" cellpadding="4">
       <col><col>
       <tbody>
         <tr>
           <td><font class="txt_with_shadow" color="#0B0B61" size="4"><i>Select a manual : </i></font></td>
           <td align="left">
             <a href="./manual.html" class="btn_tuto_selected">QxOrm user guide</a>
             <a href="./manual_qxee.html" class="btn_tuto">QxEntityEditor user guide</a>
           </td>
         </tr>
       </tbody>
      </table>
      <hr style="width: 100%" align="center" size="1" color="#100D5A">
      <br>
      <table border="0" style="width: 100%" align="center">
      <col><col>
         <tbody>
            <tr>
               <td>
                  <h3 class="txt_slogan"><b>QxOrm library manual - Table of Contents</b></h3>
                  <div id="manual_table_of_contents">
                  <ol class="manual_manual_ol_title_1" type="I">
                     <li class="manual_li_title_1">
                        <a href="#manual_10">Introduction</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_100">QxOrm library</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_110">Quick overview of QxEntityEditor application</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_120">C++ coding style of QxOrm library</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_20">Installation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_200">Qt dependency</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_210">Boost dependency (only header files *.hpp are required)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_230">Build QxOrm library (with qmake or CMake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_240">Qt SQL drivers (supported databases)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_30">Persistence - Object Relational Mapping (ORM)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_300">Register a class in QxOrm context (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3000">Primary key other than default type "long"</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3010">Composite primary key</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3020">public or protected/private data members</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3030">Namespace</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3040">Built-in C++ supported types</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3050">Register a transient data member</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_310">Connection to database</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_320">Persist a C++ instance in database (insert/update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_340">Delete an instance in database (delete)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3400">Soft delete behaviour (logical delete)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_350">Get a C++ instance from database (fetch)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_360">SQL queries</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3610">Using standard SQL or stored procedure</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_370">Transactions (commit, rollback, session)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_380">Relationships</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3800">one-to-many (1-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3810">many-to-one (n-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3820">many-to-many (n-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3830">one-to-one (1-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3840">Fetch relationships</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3850">Select columns fetching relationships</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_390">Supported containers</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3900">Qt containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3910">Boost containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3920">std containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3930">qx::QxCollection</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_400">Supported smart pointers</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4000">Qt smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4010">Boost smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4020">std smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4030">qx::dao::ptr</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_410">Triggers</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_420">Validators</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_430">Manage NULL database value</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4300">boost::optional</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4310">QVariant</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_440">Inheritance and polymorphism</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_450">qx::IxPersistable interface (abstract class)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_460">Persist custom type</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_470">Generate database DDL SQL schema</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_475">Associate a SQL type to a C++ class</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_480">Async database queries</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_490">Cache to store C++ instances (QxCache module)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_500">Working with several databases</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_510">Register an abstract class in QxOrm context</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_520">Register automatically Qt meta-properties (<i>Q_PROPERTY</i> macro)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_60">Serialization</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_605">Version number to manage ascendant compatibility</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_600">Qt QDataStream engine</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_606">Qt JSON engine</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_610">XML boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_620">Binary boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_630">Other boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_640">Clone a C++ instance</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_650">Dump a C++ instance (XML or JSON format)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_70">Introspection - Reflection</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_710">Get a data member value dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_720">Set a data member value dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_730">Call function dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_740">Create a C++ instance dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_750">Iterate over all classes/properties registered in QxOrm context</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_80">Services : transfer persistent data layer over network (QxService module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_810">Input/output service parameters (request/response)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_820">Define service functions exposed to clients</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_825">List of options available on server side</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_826">Connection settings on client side</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_830">Service authentication</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_840">Async client/server queries</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_90">Model View engine (QxModelView module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_910">Simple model (without relationship)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_920">Model with relationships (nested models)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_940">Interaction with QML views</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_950">Interaction with QtWidget views</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_960">Connect model to QxService module</a>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  </div>
               </td>
               <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                  <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
               </td>
            </tr>
         </tbody>
      </table>
      <br>
      <hr width="90%">
      <div id="manual_content">

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_10">Introduction</a></p>
      <div class="manual_div_content_1">
         The goal of this documentation is to provide a user guide to learn how to work with <b>QxOrm</b> library features.
         This manual is intended for developers and software architects who are looking for a solution to manage a persistent data layer in C++/Qt.
         Technical skills in C++ and databases are required to understand this document.
         <br><br>
         <b>Note :</b> all features described in this manual/user guide can be defined quickly and easily with <b>QxEntityEditor</b> application (the graphic editor for <b>QxOrm</b> library, data model designer and source code generator).
         <a href="./manual_qxee.html">Another documentation dedicated to <b>QxEntityEditor</b> application is available on QxOrm website.</a>
         <br><br>
         <b>Other note :</b> this manual is based on <a href="./faq.html">the old FAQ of QxOrm website, you can always access to this FAQ here</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_100">QxOrm library</a></p>
         <div class="manual_div_content">
           <b>QxOrm is a C++ library designed to provide <i>Object Relational Mapping (ORM)</i> feature to C++ users.<br>
           QxOrm is developed by Lionel Marty, a software development engineer since 2003.</b>
           <br><br>
           Based on a simple <b>C++ setting function per class</b> (like <a href="http://hibernate.org/" target="_blank"><i>Hibernate</i></a> XML mapping file in Java), <b>QxOrm</b> library provides following features :
           <ul>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_30">persistence</a></font></b> : communication with databases (support <i>1-1</i>, <i>1-n</i>, <i>n-1</i> and <i>n-n</i> relationships) ;
             </li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_60">serialization</a></font></b> : binary, XML and JSON format ;
             </li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_70">reflection</a></font></b> (or <b><font style="background-color:yellow"><a href="./manual.html#manual_70">introspection</a></font></b>) : access dynamically to classes definitions, retrieve properties and call classes methods.
             </li>
           </ul>
           QxOrm depends on <a href="http://www.qt.io/" target="_blank"><b>Qt</b></a> (from version 4.5.0) and <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (from version 1.38, and by default just header files <i>*.hpp</i> are necessary).<br>
           QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a>.
           <br><br>
           If you find a bug or if you have a question about <b>QxOrm</b> library, you can send an e-mail to : <u><i>support@qxorm.com</i></u>.<br>
           A forum dedicated to <b>QxOrm</b> library is available <a href="http://www.qxorm.com/forum/phpbb/" target="_blank">here</a>.<br>
           If you speak/understand french, you can access to <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/bases-donnees/qxorm/" target="_blank">the french community on the famous <i>developpez.com</i> forum</a>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_110">Quick overview of QxEntityEditor application</a></p>
         <div class="manual_div_content">
           <b>QxEntityEditor</b> is a graphic editor for <b>QxOrm</b> library : <b>QxEntityEditor</b> provides a graphic way to manage the data model.<br>
           <b>QxEntityEditor</b> is multi-platform (available for Windows, Linux and Mac OS X) and generates native code for all environments : desktop (Windows, Linux, Mac OS X), embedded and mobile (Android, iOS, Windows Phone, Raspberry Pi, etc.).<br>
           <a href="./tutorial_4.html">A presentation video of <b>QxEntityEditor</b> application is available on YouTube</a>.<br>
           <br>
           <b>QxEntityEditor</b> is based on plugins and provides many ways to import/export your data model :
           <ul>
             <li>generate C++ persistent classes automatically (registered in QxOrm context) ;</li>
             <li>generate DDL SQL script automatically (database schema) for SQLite, MySQL, PostgreSQL, Oracle and MS SQL Server ;</li>
             <li>manage schema evolution for each project version (<i>ALTER TABLE</i>, <i>ADD COLUMN</i>, <i>DROP INDEX</i>, etc.) ;</li>
             <li>transfer your data model over network and create quickly client/server applications, using <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module ;</li>
             <li>import existing database structure (using ODBC connection) for SQLite, MySQL, PostgreSQL, Oracle and MS SQL Server databases ;</li>
             <li>because each project is different, QxEntityEditor provides several ways to customize generated files (especially a javascript engine and an integrated debugger).</li>
           </ul>
           <a href="../qxentityeditor/resource/qxee_sample.png" target="_blank"><img alt="QxEntityEditor" src="../qxentityeditor/resource/qxee_sample_small.png" border="0" class="img_with_shadow"></a>
           <br><br>
           <b>QxEntityEditor</b> is developed by Lionel Marty, a software development engineer since 2003.<br>
           <a href="./manual_qxee.html">A manual dedicated to <b>QxEntityEditor</b> application is available on QxOrm website.</a>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_120">C++ coding style of QxOrm library</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses following syntax and naming convention for C++ source code :
           <ul><li>all classes, functions, properties, etc... are defined under <a href="./resource/qxorm.namespace.qx.jpg"><i>namespace qx</i></a> ;
           </li><li>all macros of QxOrm library are prefixed by <i>QX_...</i> ;
           </li><li>all abstracts classes (or interfaces) start with prefix <i>Ix</i> (for example <i>IxFactory</i> is an interface to create an instance of object) ;
           </li><li>other classes start with prefix <i>Qx</i> (for example <i>QxDataMember</i>) ;
           </li><li>containers of objects end with suffix <i>X</i> (for example <i>QxDataMemberX</i> is a list of <i>QxDataMember</i>) ;
           </li><li>functions to interact with databases are under <a href="./resource/qxorm.namespace.qx.dao.jpg"><i>namespace qx::dao</i></a> (for example <i>qx::dao::fetch_by_id()</i>) ;
           </li><li>functions to <i>serialize</i> are under <a href="./resource/qxorm.namespace.qx.serialization.jpg"><i>namespace qx::serialization</i></a> (for example <i>qx::serialization::xml::to_file()</i>) ;
           </li><li>the <i>reflection</i> (or <i>introspection</i>) engine can be used with <b><i>qx::QxClassX</i></b> class (for example <i>qx::QxClassX::invoke()</i> to call a class method) ;
           </li><li>all traits classes are under <a href="./resource/qxorm.namespace.qx.trait.jpg"><i>namespace qx::trait</i></a> (for example <i>qx::trait::is_smart_ptr&lt;T&gt;</i>).
           </li></ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_20">Installation</a></p>
      <div class="manual_div_content_1">
         <b>QxOrm</b> library is multi-platform and can be installed on all environments : Windows, Linux, Mac OS X, Android, iOS, Windows Phone, Raspberry Pi, etc...<br>
         <a href="./tutorial_3.html">A full tutorial (with screenshots) to install a development environment with QxOrm on Windows is available here.</a>
         <br><br>
         The goal of this chapter is to explain all steps required to install <b>QxOrm</b> library on all environments :
         <ul>
            <li><a href="#manual_200">Download and install Qt framework ;</a></li>
            <li><a href="#manual_210">Download and unzip boost library (by default just header files <i>*.hpp</i> are necessary) ;</a></li>
            <li><a href="#manual_220">Configure <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file ;</a></li>
            <li><a href="#manual_230">Build QxOrm library (with qmake or CMake) ;</a></li>
            <li><a href="#manual_240">Check SQL drivers provided by Qt.</a></li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_200">Qt dependency</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://www.qt.io/" target="_blank"><img alt="Qt" src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : cross-platform application development framework : GUI (<i>QtGui</i>), network (<i>QtNetwork</i>), XML (<i>QtXml</i>), database (<i>QtSql</i>)...<br>
                 Qt provides excellent support and documentation. Using Qt, you can write simple and powerful C++ code.<br>
                 Qt is produced by Digia's Qt Development Frameworks division and is available under LGPL license.<br>
                 QxOrm is compatible with many Qt's objects : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash, QSharedPointer, QScopedPointer...</i><br>
                 It is recommended to install the latest version of Qt available at the following address : <a href="http://www.qt.io/" target="_blank">http://www.qt.io/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Note :</b> by default, <b>QxOrm</b> library depends only on <a href="http://doc.qt.io/qt-5/qtcore-index.html" target="_blank">QtCore</a> and <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql</a> binaries.
           It is possible to enable extra features in the <a href="#manual_220"><i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file</a> : some features can add dependencies to QxOrm library.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_210">Boost dependency (only header files *.hpp are required)</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://www.boost.org/" target="_blank"><img alt="boost" src="./resource/logo_boost.jpg" width="161" height="50" border="0"></a></td>
                 <td align="justify"><b>boost</b> : many of boost's founders are on the C++ standard committee and several boost libraries have been accepted for incorporation into C++1x (new standard for the C++ programming language).
                 The boost's libraries are aimed at a wide range of C++ users and application domains.<br>
                 QxOrm uses the following boost's features (header files <i>*.hpp</i> only, boost <i>serialization</i> dependency is optional) : <i>smart_pointer, type_traits, multi_index_container, unordered_container, any, tuple, foreach, function.</i><br>
                 It is recommended to get the latest version of boost available at the following address : <a href="http://www.boost.org/" target="_blank">http://www.boost.org/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Important note :</b> by default, <b>QxOrm</b> library depends only on <i>*.hpp</i> boost header files (<i>header only</i> libraries).
           So boost installation is very easy because you just have to unzip boost package (to get <i>*.hpp</i> header files, there is nothing to build).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a></p>
         <div class="manual_div_content">
            <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file is divided into several sections (each section is commented) and provides all settings and compilation options available to customize QxOrm library features.
            So it is strongly recommended to read carefully <i>QxOrm.pri</i> configuration file before compiling and building QxOrm library.
            It is possible to keep default settings, only <b>QX_BOOST_INCLUDE_PATH</b> variable is required to build QxOrm library : this variable is used to define where <i>*.hpp</i> boost header files are located :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>isEmpty(QX_BOOST_INCLUDE_PATH) { QX_BOOST_INCLUDE_PATH = $$quote(<font style="background-color:yellow">D:/Dvlp/_Libs/Boost/1_57/include</font>) }</i>   </pre>
            </td></tr></tbody></table>
            <br>
            If you don't want to change <i>QxOrm.pri</i> configuration file, it is possible to define an environment variable named <b>BOOST_INCLUDE</b> : this environment variable will be used automatically to set <b>QX_BOOST_INCLUDE_PATH</b> value (read <i>QxOrm.pri</i> configuration file for more details).
            <br><br>
            Here is a list of compilation options available in <i>QxOrm.pri</i> configuration file, by default they are all disabled :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION :</b> enable <a href="#manual_610">boost::serialization engine</a>. This option requires to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary and adds a dependency to QxOrm library ;</li>
               <br>
               <li><b>_QX_CPP_11_SMART_PTR :</b> support C++11 smart-pointers : <i>std::unique_ptr, std::shared_ptr, std::weak_ptr</i> ;</li>
               <li><b>_QX_CPP_11_CONTAINER :</b> support C++11 containers : <i>std::unordered_map, std::unordered_set, std::unordered_multimap, std::unordered_multiset</i> ;</li>
               <li><b>_QX_CPP_11_TUPLE :</b> support C++11 <i>std::tuple</i> type ;</li>
               <br>
               <li><b>_QX_ENABLE_QT_GUI :</b> support serialization of <a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a> types : <i>QBrush, QColor, QFont, QImage, QMatrix, QPicture, QPixmap, QRegion</i>. This option adds a dependency to QxOrm library (<a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a>) ;</li>
               <li><b>_QX_ENABLE_QT_NETWORK :</b> enable <a href="#manual_80">QxService module</a> to transfer persistent data layer over network (client/server application). This option adds a dependency to QxOrm library (<a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a>) ;</li>
               <li><b>_QX_NO_PRECOMPILED_HEADER :</b> disable precompiled header (used to reduce compilation times of a project) : this option is required <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56926" target="_blank">with recent versions of MinGW (because of a known compiler bug)</a>, for all other compilers it is recommended to work with <i>precompiled header</i> ;</li>
               <li><b>_QX_NO_RTTI :</b> build QxOrm library (and all projects which depend on QxOrm) without <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">RTTI C++ type information</a> ;</li>
               <li><b>_QX_STATIC_BUILD :</b> build QxOrm library in <i>static</i> mode (but build QxOrm as a <i>shared library</i> is recommended).</li>
               <li><b>_QX_UNITY_BUILD :</b> reduce QxOrm library compilation times using <i>unity build</i> concept : only one <i>all.cpp</i> source file to compile. It is recommended to enable this option with <a href="https://cmake.org/" target="_blank">CMake</a> (because doesn't support natively precompiled headers).</li>
            </ul>
            <br>
            <b>Note :</b> <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file must be included in all projects which depend on QxOrm library, just adding following line in <i>*.pro</i> project file :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   include(<i>my_path_to_QxOrm_library</i>/QxOrm.pri)   </pre>
            </td></tr></tbody></table>
            <br>
            <b>Other note :</b> instead of <i>qmake</i>, it is possible to use <a href="https://cmake.org/" target="_blank">CMake compilation tools</a> to configure and build QxOrm library.
            CMake provides a GUI tool to display and configure all available parameters :
            <br><br>
            <img alt="QxOrm and CMake" src="./resource/qxorm_cmake.png" />
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_230">Build QxOrm library (with qmake or CMake)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses <b>qmake</b> process from <b>Qt</b> framework to create <i>makefile</i> and build the project (it is also possible to use <a href="https://cmake.org/" target="_blank">CMake compilation tools</a>, a <b>CMakeLists.txt</b> file is provided with QxOrm library).<br>
           <b>qmake</b> is portable and multi-platform, so it works perfectly on Windows, Linux (Unix) and Mac OS X.<br>
           To build <b>QxOrm</b> library, just execute following commands :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>qmake</i>
   <i>make debug</i>
   <i>make release</i>   </pre>
           </td></tr></tbody></table>
           <br>
           On <b>Windows</b>, <i>*.vcproj</i> and <i>*.sln</i> files are available for <b>Visual C++ 2008</b>, <b>Visual C++ 2010</b> and <b>Visual C++ 2012</b>.<br>
           <i>*.pro</i> files are readable by <b>Qt Creator</b>, and some plugins are available to interface to other C++ source code editors.<br>
           <i>mingw_build_all_debug.bat</i> and <i>mingw_build_all_release.bat</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests with <b>MinGW</b> compiler on Windows.<br>
           <i>gcc_build_all_debug.sh</i> and <i>gcc_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests with <b>GCC</b> compiler on <b>Linux</b>.<br>
           <i>osx_build_all_debug.sh</i> and <i>osx_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests on <b>Mac OS X</b> (thanks very much to Dominique Billet for the scripts).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_240">Qt SQL drivers (supported databases)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank"><i>QtSql</i></a> engine of <b>Qt</b> framework based on a system of plugins.<br>
           <a href="http://doc.qt.io/qt-5/sql-driver.html" target="_blank">A list of supported databases is available on Qt website</a>.<br>
           The <i>ODBC</i> plugin (<i>QODBC</i>) ensures compatibility with many databases.<br>
           For optimal performances, it is recommended to work with a database specific plugin :
           <ul>
              <li><i>QMYSQL</i> : MySQL ;</li>
              <li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;</li>
              <li><i>QOCI</i> : Oracle Call Interface Driver ;</li>
              <li><i>QSQLITE</i> : SQLite version 3 ;</li>
              <li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;</li>
              <li><i>QIBASE</i> : Borland InterBase ;</li>
              <li><i>QTDS</i> : Sybase Adaptive Server.</li>
           </ul>
           <b>Note :</b> to connect to a <i>Microsoft SQL Server</i> database, it is necessary to use <i>ODBC</i> (<i>QODBC</i> plugin).
           <br><br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_30">Persistence - Object Relational Mapping (ORM)</a></p>
      <div class="manual_div_content_1">
         <b>QxOrm</b> library provides a data persistence engine based on <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> module of Qt framework.
         This persistence engine uses programming pattern : <b>Object Relational Mapping (ORM)</b>.
         <br><br>
         <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">From Wikipedia website :</a> Object-Relational Mapping (ORM) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language.<br>
         In object-oriented programming, data management tasks act on object-oriented (OO) objects that are almost always non-scalar values. For example, consider an address book entry that represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object-oriented implementation by a "Person object" with attributes/fields to hold each data item that the entry comprises : the person's name, a list of phone numbers, and a list of addresses. The list of phone numbers would itself contain "PhoneNumber objects" and so on. The address book entry is treated as a single object by the programming language (it can be referenced by a single variable containing a pointer to the object, for instance). Various methods can be associated with the object, such as a method to return the preferred phone number, the home address, and so on.<br>
         However, many popular database products such as SQL database management systems (DBMS) can only store and manipulate scalar values such as integers and strings organized within tables. The programmer must either convert the object values into groups of simpler values for storage in the database (and convert them back upon retrieval), or only use simple scalar values within the program. Object-relational mapping is used to implement the first approach.<br>
         The heart of the problem is translating the logical representation of the objects into an atomized form that is capable of being stored in the database, while preserving the properties of the objects and their relationships so that they can be reloaded as objects when needed. If this storage and retrieval functionality is implemented, the objects are said to be persistent.
         <br><br>
         To do this link between object world and relational world, and to provide all its features, <b>QxOrm</b> library requires that C++ classes are registered in QxOrm context.
         So we will start this chapter this way : <b>how to register a C++ class in QxOrm context ?</b>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_300">Register a class in QxOrm context (mapping)</a></p>
         <div class="manual_div_content">
            All C++ classes can be registered in QxOrm context : there is no need to inherit from a <i>super object</i>, and you can write your methods and accessors without any constraint.
            Register a C++ class in QxOrm context means :
            <ul>
               <li>in <i>*.h</i> header file (containing class definition) : use <i><b>QX_REGISTER_HPP(class_name, base_class, class_version)</b></i> macro ;</li>
               <li>in <i>*.cpp</i> source file (containing class implementation) : use <i><b>QX_REGISTER_CPP(class_name)</b></i> macro ;</li>
               <li>in <i>*.cpp</i> source file (containing class implementation) : specialize template function : <i><b>void qx::register_class&lt;T&gt;(qx::QxClass&lt;T&gt; & t)</b></i>.</li>
            </ul>
            Here is an example to show how to define a class named <i>person</i> with 4 properties registered in QxOrm context : <i>id</i>, <i>firstName</i>, <i>lastName</i>, <i>birthDate</i> :<br>
            <br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span></font><span class="comment">

/* This macro is necessary to register 'person' class in QxOrm context */
/* param 1 : the current class to register =&gt; 'person' */
/* param 2 : the base class, if no base class, use the qx trait =&gt; 'qx::trait::no_base_class_defined' */
/* param 3 : the class version used by serialization engine to provide 'ascendant compatibility' */</span><span class="pre">

#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="pre">#include <span class="string">"precompiled.h"</span>   <span class="comment">// Precompiled-header with '#include &lt;QxOrm.h&gt;' and '#include "export.h"'</span>
#include <span class="string">"person.h"</span>          <span class="comment">// Class definition 'person'</span>
#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>     <span class="comment">// Automatic memory leak detection and boost serialization export macro</span>
</span>
<font style="background-color:yellow">QX_REGISTER_CPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">)</span></font><span class="comment">   // This macro is necessary to register 'person' class in QxOrm context
</span><span class="keyword">
namespace</span> qx<span class="operator"> {</span><font style="background-color:yellow"><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
  t<span class="operator">.</span>setName<span class="operator">(</span><span class="string">"t_person"</span><span class="operator">)</span>;<span class="comment">               // 'person' C++ class is mapped to 't_person' database table</span>

  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span><span class="comment">               // Register 'person::id' &lt;=&gt; primary key in your database
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span><span class="comment">      // Register 'person::firstName' property mapped to 'first_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span><span class="comment">  // Register 'person::lastName' property mapped to 'last_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span><span class="comment">  // Register 'person::birthDate' property mapped to 'birth_date' database column name
</span><span class="operator">}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> class methods <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::id()</a> and <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> return an instance of type : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> (which is the base class to register a data member).
            With this instance, it is possible to customize default behaviour of <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class, like for example in the chapter : <a href="#manual_3050">Register a <i>transient</i> data member</a>.
            <br><br>
            <b>Other note :</b> it is also possible to register functions and class methods in QxOrm context (support <i>static</i> and <i>non static</i> methods) with <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a>, <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a>, etc...
            This feature is a part of <a href="#manual_70">introspection engine</a> of QxOrm library, more details in the chapter : <a href="#manual_730">Call function dynamically</a>.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3000">Primary key other than default type "long"</a></p>
            <div class="manual_div_content">
              By default, the unique id (primary key) of a C++ class registered in QxOrm context is defined as <i>long</i> type (with auto-increment behaviour in database).<br>
              <br>
              It is possible to define a unique id (primary key) of another type (for example, <i>QString</i> type) with <b>QX_REGISTER_PRIMARY_KEY</b> macro.<br>
              This macro specializes <i>qx::trait::get_primary_key&lt;T&gt;</i> template to associate a primary key type to a C++ class.<br>
              <br>
              For example, to define a <i>QString</i> primary key for <i>myClass</i> C++ class (mapped to a database table with a column primary key of type <i>VARCHAR</i>), you have to write :
              <i><b>QX_REGISTER_PRIMARY_KEY(myClass, QString)</b></i><br>
              <br>
              <b>Warning :</b> <b><i>QX_REGISTER_PRIMARY_KEY</i></b> macro must be used before <b><i>QX_REGISTER_HPP</i></b> macro in your class definition, otherwise a compilation error occurs.<br>
              <br>
              Here is an example with <i>author</i> class of <i>qxBlog</i> tutorial and a <i>QString</i> primary key type :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword"> 
class</span> author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- properties
</span>   QString  m_id<span class="operator">;</span>
   QString  m_name<span class="operator">;</span><span class="comment">
// -- constructor, virtual destructor
</span>   author<span class="operator">() { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3010">Composite primary key</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> supports '<i>multi-columns primary key</i>'.<br>
              The class id (primary key) must be defined with following type :
              <ul>
                <li><i>QPair</i> or <i>std::pair</i> to define 2 columns ;</li>
                <li><i>boost::tuple</i> (or <i>std::tuple</i>) to define from 2 columns to 9 columns.</li>
              </ul>
              It is necessary to use <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> macro to specialize template and to map class id with multi-columns in database.<br>
              The list of multi-columns names must be defined with '<b>|</b>' character as separator : '<i>column1|column2|column3|etc...</i>'.<br>
              <br>
              Here is an example with '<i>author</i>' class from '<i>qxBlogCompositeKey</i>' sample project, this class has an id mapped to 3 columns in database :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- composite key (multi-column primary key in database)
</span>   <font style="background-color:yellow"><span class="keyword">typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="keyword">static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span></font><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- properties
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- contructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- methods "get" to composite key
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- methods "set" to composite key
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
              </td></tr></tbody></table>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span></font>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3020">public or protected/private data members</a></p>
            <div class="manual_div_content">
              To register <i>private</i> or <i>protected</i> data members in QxOrm context (<i>qx::register_class&lt;T&gt;</i> function), it's necessary to declare some <i>friend class</i>.<br>
              To do that, QxOrm library provides <b>QX_REGISTER_FRIEND_CLASS(myClass)</b> macro.<br>
              An example can be found in <i>./test/qxDllSample/dll1/</i> directory of QxOrm package with <i>CPerson</i> class :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> test<span class="operator"> {</span><span class="keyword">

class</span> QX_DLL1_EXPORT CPerson<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>qx<span class="operator">::</span>test<span class="operator">::</span>CPerson<span class="operator">)</span></font><span class="comment">

   // etc...
</span><span class="operator">
};

}</span><span class="comment"> // namespace test
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3030">Namespace</a></p>
            <div class="manual_div_content">
              If a class is defined in a namespace, a compilation error occurs with <b>QX_REGISTER_HPP</b> and <b>QX_REGISTER_CPP</b> macros.<br>
              To avoid this compilation error, it is necessary to use <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> and <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b> macros.<br>
              <br>
              You can find a sample in <i>./test/qxDllSample/dll1/</i> directory of QxOrm package with <i>CPerson</i> class defined in <i>qx::test</i> namespace :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)   </pre>
              </td></tr></tbody></table>
              <br>
              <b>QX_REGISTER_COMPLEX_CLASS_NAME...</b> macros require an extra parameter (in above sample : <i>qx_test_CPerson</i>) to be able to create a global variable.
              This global variable is created before your application is started.
              This global variable instance registers the class in <a href="#manual_740"><i>QxFactory</i> module (design pattern factory)</a>.
              A C++ class name cannot contain "<i>::</i>" character, so this is why extra parameter replaces all "<i>::</i>" characters by "<i>_</i>".
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3040">Built-in C++ supported types</a></p>
            <div class="manual_div_content">
               QxOrm library supports all primitive types of C++ standard and Qt framework (numeric, boolean, string, date/time, container, pointer and smart-pointer, etc...).
               Here is an example with a list (non exhaustive) of supported C++ types mapped to database types (here as <i>SQLite</i> format) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Note :</b> it is possible to persist a type not managed by default by QxOrm library. Go to the chapter <a href="#manual_460"><b><i>Persist custom type</i></b></a> for more details about this feature.
               <br><br>
               <b>Other note :</b> to map a C++ type to a database type, please go to the chapter <a href="#manual_475"><b><i>Associate a SQL type to a C++ class</i></b></a> for more details.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3050">Register a transient data member</a></p>
            <div class="manual_div_content">
               A <i>transient</i> data member is not associated to a column in a database table.
               <a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao module</a> doesn't use a <i>transient</i> property for all requests to database.
               <br><br>
               Why to register a <i>transient</i> property in QxOrm context ?<br>
               Register a <i>transient</i> data member in QxOrm context enables other features provided by QxOrm library on this property : <a href="./manual.html#manual_60">serialization</a>, <a href="./manual.html#manual_70">introspection</a>, etc...
               <br><br>
               <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> class method has an optional parameter named : <i>bool bDao</i> (default value is <i>true</i>).
               For example, we add a <i>transient</i> property named <i>age</i> to <i>person</i> class (this property doesn't have to be stored in database because we already have a <i>birthDate</i> property) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> <font style="background-color:yellow">false</font></span><span class="operator">);
}}</span></pre>
               </td></tr></tbody></table>
               <br>
               Here is another way to define a <i>transient</i> property with <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> instance :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setDao<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_310">Connection to database</a></p>
         <div class="manual_div_content">
            To configure a connection to database, you can use the singleton class : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>.<br>
            Here is an example to connect to a SQLite database named <i>test_qxorm.db</i> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlDatabase">
<pre>   <span class="comment">// Init parameters to connect to database</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDriverName<span class="operator">(</span><span class="string">"QSQLITE"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDatabaseName<span class="operator">(</span><span class="string">"./test_qxorm.db"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setHostName<span class="operator">(</span><span class="string">"localhost"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setUserName<span class="operator">(</span><span class="string">"root"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setPassword<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
</pre>
            </td></tr></tbody></table>
            <br>
            By default, all requests sent from QxOrm library to database are executed using <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> singleton class settings.
            For more details about available settings, it is recommended to read <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase Qt class documentation</a>.
            <br><br>
            <b>Note :</b> <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> singleton class can manage automatically requests to database in several threads (support <i>multi-threading</i>).
            <br><br>
            <b>Other note :</b> it is possible to manage your own connection pool to database, and also to work with several databases : for more details about this feature, please go to the chapter <a href="#manual_500"><b><i>Working with several databases</i></b></a>.
            <br><br>
            <b>Other note :</b> depending on Qt SQL plugin (<a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><i>setDriverName()</i></a> method), QxOrm library associates automatically a SQL generator.
            This SQL generator is used to manage specific features provided by databases.
            All SQL generators inherit from <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a> base class :
            <ul>
               <li><i>QMYSQL</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_MySQL</a> ;</li>
               <li><i>QPSQL</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_PostgreSQL</a> ;</li>
               <li><i>QSQLITE</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html" target="_blank">qx::dao::detail::QxSqlGenerator_SQLite</a> ;</li>
               <li><i>QOCI</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html" target="_blank">qx::dao::detail::QxSqlGenerator_Oracle</a> ;</li>
               <li>for all other plugins : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html" target="_blank">qx::dao::detail::QxSqlGenerator_Standard</a> (it is possible to create your own SQL generator writing a class based on <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a>) ;</li>
               <li>to connect to a <i>Microsoft SQL Server</i> database, you have to work with <i>QODBC</i> plugin : then you have to define yourself the SQL generator like this : </li>
            </ul>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="SQL generator">
<pre>   qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxSqlGenerator_ptr pSqlGenerator<span class="operator">;</span>
   pSqlGenerator<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxSqlGenerator_MSSQLServer<span class="operator">());</span>   
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setSqlGenerator<span class="operator">(</span>pSqlGenerator<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_320">Persist a C++ instance in database (insert/update)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To save a C++ instance (or a list of C++ instances) to database, QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert</i></a> : insert an instance (or a list of instances) to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_relation</i></a> : insert an instance (or a list of instances) + its relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_all_relation</i></a> : insert an instance (or a list of instances) + all relationships to database ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update</i></a> : update an instance (or a list of instances) to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_relation</i></a> : update an instance (or a list of instances) + its relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_all_relation</i></a> : update an instance (or a list of instances) + all relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query</i></a> : update an instance (or a list of instances) to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_relation</i></a> : update an instance (or a list of instances) + its relationships to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_all_relation</i></a> : update an instance (or a list of instances) + all relationships to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized</i></a> : update only modified fields of an instance (or a list of instances) to database using <i>is dirty</i> pattern and <a href="#manual_4030">qx::dao::ptr</a> class features ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized_by_query</i></a> : update only modified fields of an instance (or a list of instances) to database using <i>is dirty</i> pattern and <a href="#manual_4030">qx::dao::ptr</a> class features with a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + its relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_all_relation</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + all relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation_recursive</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + all relationships on all levels (recursively) : useful to store quickly a complex tree structure for example ;</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="insert/update">
<pre>   <span class="comment">// Create 3 drugs instances
   // It is possible to use 'boost' and 'Qt' smart pointer : 'boost::shared_ptr', 'QSharedPointer', etc...
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span>
   drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
   drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
   drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span>

   <span class="comment">// Insert some drugs into a container
   // It is possible to use many containers from 'std', 'boost', 'Qt' and 'qx::QxCollection&lt;Key, Value&gt;'
</span><span class="keyword">   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>drug_ptr<span class="operator">&gt;</span> type_lst_drug<span class="operator">;</span>
   type_lst_drug lst_drug<span class="operator">;</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d1<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d2<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d3<span class="operator">);</span><span class="comment">

   // Insert drugs from container to database
   // 'id' property of 'd1', 'd2' and 'd3' are auto-updated
</span>   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>lst_drug<span class="operator">);</span></font><span class="comment">

   // Modify and update the second drug into database
</span>   d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2 modified"</span><span class="operator">;</span>
   d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2 modified"</span><span class="operator">;</span>
   daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>d2<span class="operator">);</span></font>
</pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> all functions located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace are flexible because they accept several types of parameters : a simple instance, a list of instances, a pointer, a smart-pointer, a list of pointers, a list of smart-pointers, etc... For example :
            <ul>
               <li><i>my_entity t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>my_entity * t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>std::shared_ptr&lt;my_entity&gt; t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>QList&lt;my_entity&gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
               <li><i>QList&lt;std::shared_ptr&lt;my_entity&gt; &gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
            </ul>
            About supported collection types by QxOrm library, please go to the chapter : <a href="#manual_390">Supported containers</a>.<br>
            About supported smart-pointer types by QxOrm library, please go to the chapter : <a href="#manual_400">Supported smart pointers</a>.<br>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_340">Delete an instance in database (delete)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To delete a C++ instance (or a list of C++ instances) from database, QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_id</i></a> : delete entity (or a list of entities) from database associated to the id parameter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_all</i></a> : delete all entities from a database table ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_query</i></a> : delete entities from a database table using a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_id</i></a> : delete entity (or a list of entities) from database associated to the id parameter (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_all</i></a> : delete all entities from a database table (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_query</i></a> : delete entities from a database table using a SQL query filter (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="delete">
<pre>   <span class="comment">// Create a drug instance with id '18'
   </span>drug d<span class="operator">;</span> d<span class="operator">.</span>setId<span class="operator">(</span><span class="int">18</span><span class="operator">);</span><span class="comment">

   // Delete the drug with id '18' from database
   </span>QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>d<span class="operator">);</span></font><span class="comment">

   // Delete all drugs from database
   </span>daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>drug<span class="operator">&gt;();</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3400">Soft delete behaviour (logical delete)</a></p>
            <div class="manual_div_content">
              A soft delete doesn't remove rows from a database table (this is not a physical delete) : a new column is added to table definition to flag a row as deleted or not.
              This extra column can contain a boolean (1 means row deleted, 0 or NULL means row not deleted), or can contain deletion date-time (if empty or NULL, row is not deleted).
              So it is always possible to enable a row which has been previously deleted : you just have to put a NULL or empty value in this extra column.<br>
              <br>
              To define a soft delete behaviour with QxOrm library, you have to use <a href="../doxygen/html/classqx_1_1_qx_soft_delete.html" target="_blank"><b>qx::QxSoftDelete</b></a> class in mapping function <i>qx::register_class&lt;T&gt;</i>.<br>
              Here is an example with <i>Bar</i> class containing 2 properties <i>m_id</i> and <i>m_desc</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span></font>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
              </td></tr></tbody></table>
              <br>
              SQL queries generated by QxOrm library will take into account this soft delete parameter to add conditions (don't fetch deleted items, don't delete physically a row, etc...).<br>
              For example, if you execute this code with <i>Bar</i> class :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
              </td></tr></tbody></table>
              <br>
              Then output logs are :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id 
                                         AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
              </td></tr></tbody></table>
              <br>
              <b>Note :</b> to delete physically a row from database, you have to use these functions : <i>qx::dao::destroy_by_id()</i> and <i>qx::dao::destroy_all()</i>.<br>
              <br>
              <b>Other note :</b> it is recommended to define an index on <i>deleted_at</i> extra column to optimize SQL queries execution (better performance).
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_350">Get a C++ instance from database (fetch)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To fetch automatically all properties of a C++ instance (or a list of C++ instances) mapped to database table columns (and several tables if relationships are defined), QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id</i></a> : fetch entity properties (or list of entities properties) based on the id parameter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_relation</i></a> : fetch entity properties (or list of entities properties) + its relationships based on the id parameter  ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_all_relation</i></a> : fetch entity properties (or list of entities properties) + all relationships based on the id parameter  ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all</i></a> : fetch all entities from database table (all rows) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_relation</i></a> : fetch all entities from database table (all rows) + its relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_all_relation</i></a> : fetch all entities from database table (all rows) + all relationships ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query</i></a> : fetch entities from database table using a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_relation</i></a> : fetch entities + its relationships from database table using a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_all_relation</i></a> : fetch entities + all relationships from database table using a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::exist</i></a> : check if an entity (or a list of entities) already exists in database (based on its id).</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="fetch">
<pre><span class="comment">   // Fetch drug with id '3' into a new variable
</span>   drug_ptr d<span class="operator">;</span> d<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_360">SQL queries</a></p>
         <div class="manual_div_content">
            QxOrm library provides several tools to execute SQL queries to database :
            <ul>
               <li><a href="#manual_3600">qx::QxSqlQuery</a> class (or its <i>qx_query</i> alias) ;</li>
               <li><a href="#manual_3610">qx::dao::execute_query<T>()</a> function ;</li>
               <li><a href="#manual_3610">qx::dao::call_query()</a> function.</li>
            </ul>
            <b>Note :</b> QxOrm library is based on <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> module of Qt framework, so it is always possible to call database using <a href="http://doc.qt.io/qt-5/qsqlquery.html" target="_blank">QSqlQuery</a> Qt class if QxOrm features are not adapted to solve an issue.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a></p>
            <div class="manual_div_content">
              <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class (or its <i>qx_query</i> typedef) is used to communicate with database (to filter, to sort, etc.) in 2 different ways :
              <ul>
                <li>writing manually a SQL query ;</li>
                <li>using C++ methods with a syntax similar to SQL (same concept than the great library <a href="http://subsonicproject.com/docs/Simple_Query_Tool" target="_blank">SubSonic for .Net</a>).</li>
              </ul>
              With the first method (writing manually SQL query), you can use some optimizations specific for each database.<br>
              The second method (using C++ code to build SQL query) binds automatically SQL parameters without having to deal with <i>qx::QxSqlQuery::bind()</i> function.<br>
              <br>
              Here is an example with <i>qx::QxSqlQuery</i> class writing manually a SQL query :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Build a SQL query to fetch only 'author' of type 'female'
</span>qx<span class="operator">::</span>QxSqlQuery query<span class="operator">(</span><span class="string">"WHERE author.sex = :sex"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":sex"</span><span class="operator">,</span> author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* here we can work with the collection provided by database */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              QxOrm library provides 3 styles to write SQL parameters.<br>
              This style can be modified for a project using <i>qx::QxSqlDatabase::getSingleton()->setSqlPlaceHolderStyle()</i> method :<br>
              <ul>
                <li><i>ph_style_2_point_name</i> : "WHERE author.sex = :sex" (default style) ;</li>
                <li><i>ph_style_at_name</i> : "WHERE author.sex = @sex" ;</li>
                <li><i>ph_style_question_mark</i> : "WHERE author.sex = ?".</li>
              </ul>
              Here is the same example using <i>qx::QxSqlQuery</i> class methods to generate SQL query automatically :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Build a SQL query to fetch only 'author' of type 'female'
</span>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"author.sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* here we can work with the collection provided by database */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              With C++ methods of <i>qx::QxSqlQuery</i> class, you don't have to bind any SQL parameter, and the syntax is similar to real SQL.<br>
              All SQL parameters will be provided to database automatically with the following style : <i>qx::QxSqlDatabase::getSingleton()->getSqlPlaceHolderStyle()</i>.<br>
              <br>
              Here is another example using several <i>qx::QxSqlQuery</i> class methods :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"age"</span><span class="operator">).</span>isGreaterThan<span class="operator">(</span><span class="int">38</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">).</span>isNotEqualTo<span class="operator">(</span><span class="string">"Dupont"</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"first_name"</span><span class="operator">).</span>like<span class="operator">(</span><span class="string">"Alfred"</span><span class="operator">)
     .</span>and_OpenParenthesis<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>isLessThanOrEqualTo<span class="operator">(</span><span class="int">999</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"birth_date"</span><span class="operator">).</span>isBetween<span class="operator">(</span>date1<span class="operator">,</span> date2<span class="operator">)
     .</span>closeParenthesis<span class="operator">()
     .</span>or_<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>in<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 999</span><span class="operator">,</span><span class="int"> 11</span><span class="operator">,</span><span class="int"> 23</span><span class="operator">,</span><span class="int"> 78945</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"is_deleted"</span><span class="operator">).</span>isNotNull<span class="operator">()
     .</span>orderAsc<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="string"> "sex"</span><span class="operator">)
     .</span>limit<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 150</span><span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code will generate following SQL query for <i>MySQL</i>, <i>PostgreSQL</i> and <i>SQLite</i> databases (for <i>Oracle</i> and <i>Microsoft SQL Server</i>, there is a specific process for <i>limit()</i> method) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>WHERE sex<span class="operator"> = :</span>sex_1_0 
AND age<span class="operator"> &gt; :</span>age_3_0 
OR last_name<span class="operator"> &lt;&gt; :</span>last_name_5_0 
OR first_name LIKE<span class="operator"> :</span>first_name_7_0 
AND<span class="operator"> (</span> id<span class="operator"> &lt;= :</span>id_10_0 AND birth_date BETWEEN<span class="operator"> :</span>birth_date_12_0_1 AND<span class="operator"> :</span>birth_date_12_0_2<span class="operator"> )</span> 
OR id IN<span class="operator"> (:</span>id_15_0_0<span class="operator">, :</span>id_15_0_1<span class="operator">, :</span>id_15_0_2<span class="operator">, :</span>id_15_0_3<span class="operator">, :</span>id_15_0_4<span class="operator">)</span> 
AND is_deleted IS NOT NULL 
ORDER BY last_name ASC<span class="operator">,</span> first_name ASC<span class="operator">,</span> sex ASC 
LIMIT<span class="operator"> :</span>limit_rows_count_19_0 OFFSET<span class="operator"> :</span>offset_start_row_19_0</pre>
              </td></tr></tbody></table>
              <br>
              Here is the list of all functions available to use <i>qx::QxSqlQuery</i> class (or its <i>qx_query</i> typedef) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// with functions into namespace qx::dao
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// with qx::QxSession class
</span>qx<span class="operator">::</span>QxSession<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>fetchByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>update<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>deleteByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>destroyByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// with qx::QxRepository&lt;T&gt; class
</span>qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>count<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fetchByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>update<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>deleteByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>destroyByQuery<span class="operator">()</span></pre>
              </td></tr></tbody></table>
              <br>
              <b>Note :</b> these functions have 2 other optionals parameters :
              <ul>
                <li><i>const QStringList & columns</i> : to select columns to fetch (by default, all columns are fetched) ;</li>
                <li><i>const QStringList & relation</i> : to select relationships to fetch (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i> defined in <i>void qx::register_class&lt;T&gt;()</i> mapping function per class), by default there is no relation fetched.</li>
              </ul>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3610">Using standard SQL or stored procedure</a></p>
            <div class="manual_div_content">
              QxOrm library provides 2 functions to execute a stored procedure or a custom SQL query :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a></li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a></li>
              </ul>
              The first parameter of these functions, of <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> type (or <i>qx_query</i>), contains the stored procedure or the custom SQL query to execute.<br>
              For more information about <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class, please read this chapter : <a href="#manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a><br>
              <br>
              <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a> function is a <i>template</i> function : T type must be registered in QxOrm context (<i>qx::register_class&lt;T&gt;</i> function).<br>
              All datas returned by the stored procedure or the custom SQL query which could be associated with members of the C++ class (of T type) will be fetched automatically.<br>
              An automatic search is done on the name of each fields returned by the query.<br>
              Here is an example from qxBlog project of QxOrm package :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom SQL query or a stored procedure and fetch automatically properties (with a collection of items)
</span>qx_query testStoredProcBis<span class="operator">(</span><span class="string">"SELECT * FROM author"</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>execute_query<span class="operator">(</span>testStoredProcBis<span class="operator">,</span> authorX<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span> qAssert<span class="operator">(</span>authorX<span class="operator">.</span>count<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>authorX<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
              <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> function is not a <i>template</i> function : you have to iterate over each result using <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class (or <i>qx_query</i>).<br>
              To get an output value parameter (must be passed as <i>QSql::Out</i> or <i>QSql::InOut</i>) returned by a stored procedure, just call the following method : <i>QVariant qx::QxSqlQuery::boundValue(const QString & sKey) const;</i>.<br>
              <br>
              To iterate over all resultset, just use the following methods :
              <ul>
                <li><i>long qx::QxSqlQuery::getSqlResultRowCount() const;</i></li>
                <li><i>long qx::QxSqlQuery::getSqlResultColumnCount() const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, long column) const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, const QString & column) const;</i></li>
                <li><i>QVector qx::QxSqlQuery::getSqlResultAllColumns() const;</i></li>
                <li><i>void qx::QxSqlQuery::dumpSqlResult();</i></li>
              </ul>
              Here is an example using <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> function :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">(</span><span class="string">"CALL MyStoredProc(:param1, :param2)"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param1"</span><span class="operator">,</span><span class="string"> "myValue1"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param2"</span><span class="operator">,</span><span class="int"> 5024</span><span class="operator">,</span> QSql<span class="operator">::</span>InOut<span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>call_query<span class="operator">(</span>query<span class="operator">);</span>
QVariant vNewValue<span class="operator"> =</span> query<span class="operator">.</span>boundValue<span class="operator">(</span><span class="string">":param2"</span><span class="operator">);</span>
query<span class="operator">.</span>dumpSqlResult<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_370">Transactions (commit, rollback, session)</a></p>
         <div class="manual_div_content">
            A database <a href="http://en.wikipedia.org/wiki/Database_transaction" target="_blank"><b>transaction</b></a> is a sequence of operations performed as a single logical unit of work :<br>
            <ul>
               <li>if no error occurred during the execution of the transaction, then the system <b>commits</b> the transaction.</li>
               <li>if an error occurs during the transaction, or if the user specifies a <b>rollback</b> operation, then the data manipulations within the transaction are not persisted to the database.</li>
            </ul>
            <b><a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a></b> class of QxOrm library is designed to manage automatically database transactions (using <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank">C++ RAII</a>) :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Start a scope where a new session is instantiated

  // Create a session : a valid database connection by thread is automatically assigned to the session and a transaction is opened
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Execute some operations with database (using += operator of qx::QxSession class and session database connection)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // If the session is not valid (so an error occured) =&gt; display first error
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // End of scope : session is destroyed (transaction =&gt; automatically commit or rollback if there is an error)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Note :</b> a session can throw a <a href="../doxygen/html/classqx_1_1dao_1_1sql__error.html" target="_blank"><i>qx::dao::sql_error</i></a> exception when a SQL error occured (by default, there is no exception). You can setup this feature using :
            <ul>
               <li><i>qx::QxSession</i> constructor (for a specific session) ;</li>
               <li><i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> parameter (for all sessions).</li>
            </ul>
            <b>Other note :</b> don't forget to pass the session database connection to each <i>qx::dao::xxx</i> functions (using <i>session.database()</i> method).<br>
            Moreover, you can manage your own database connection (from a connection pool for example) using constructor of <i>qx::QxSession</i> class.<br>
            <br>
            <i>qx::QxSession</i> class provides persistent methods to perform CRUD operations.<br>
            Here is the same example using <i>qx::QxSession</i> class methods instead of <i>qx::dao</i> functions :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Start a scope where a new session is instantiated

  // Create a session : a valid database connection by thread is automatically assigned to the session and a transaction is opened
</span>  qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Execute some operations with database
</span>  session<span class="operator">.</span>insert<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>update<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>fetchById<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>deleteById<span class="operator">(</span>my_object<span class="operator">);</span><span class="comment">

  // If the session is not valid (so an error occured) =&gt; display first error
</span><span class="flow">  if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // End of scope : session is destroyed (transaction =&gt; automatically commit or rollback if there is an error)</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_380">Relationships</a></p>
         <div class="manual_div_content">
            QxOrm library provides a powerful relationship engine to define easily :
            <ul>
               <li><a href="#manual_3800">one-to-many (1-n)</a> relationship ;</li>
               <li><a href="#manual_3810">many-to-one (n-1)</a> relationship ;</li>
               <li><a href="#manual_3820">many-to-many (n-n)</a> relationship ;</li>
               <li><a href="#manual_3830">one-to-one (1-1)</a> relationship ;</li>
            </ul>
            <b>Note :</b> <a href="./tutorial.html">a full tutorial about relationships based on <i>qxBlog</i> sample project</a> (source code in QxOrm package) is available.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3800">one-to-many (1-n)</a></p>
            <div class="manual_div_content">
              A <i>one-to-many (1-n)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToMany()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 3 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
                <li><i>const QString & sForeignKey</i> : foreign key defined in the linked class/table.</li>
              </ul>
              <br>
              <b>For example : </b> imagine an <i>author</i> (a person) who can write several <i>blog</i> : we will show how to define a <b><i>one-to-many</i></b> relationship.<br>
              Here are the 2 tables in database : <br>
              <br>
              <img alt="qxBlog.table.author" src="./resource/qxBlog.table.author.jpg"
              width="318" height="118"><br>
              <br>
              <i>author.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- properties
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
               </td></tr></tbody></table>
               <br>
               <i>author.cpp</i> file :<br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span></font>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3810">many-to-one (n-1)</a></p>
            <div class="manual_div_content">
              A <i>many-to-one (n-1)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToOne()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 2 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship (mapped to a table column in database) ;</li>
              </ul>
              <br>
              <b>For example : </b> a <i>comment</i> is associated to a <i>blog</i> and a <i>blog</i> can contain several <i>comment</i> : we will show how to define a <b><i>many-to-one</i></b> relationship.<br>
              Here are the 2 tables in database : <br>
              <br>
              <img alt="qxBlog.table.comment"
              src="./resource/qxBlog.table.comment.jpg" width="335" height="116"><br>
              <br>
              <i>comment.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.h">
<pre><span class="pre">#ifndef _QX_BLOG_COMMENT_H_
#define _QX_BLOG_COMMENT_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT comment<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="comment">
// -- properties
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_text<span class="operator">;</span>
   QDateTime   m_dt_create<span class="operator">;</span>
   <font style="background-color:yellow">blog_ptr    m_blog<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   comment<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>comment<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>comment<span class="operator">&gt;</span> comment_ptr<span class="operator">;</span><span class="keyword">
typedef</span> QList<span class="operator">&lt;</span>comment_ptr<span class="operator">&gt;</span> list_comment<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_COMMENT_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              <i>comment.cpp</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>comment<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "comment_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_text<span class="operator">,</span><span class="string"> "comment_text"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_dt_create<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToOne<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_blog<span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3820">many-to-many (n-n)</a></p>
            <div class="manual_div_content">
              A <i>many-to-many (n-n)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToMany()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 5 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
                <li><i>const QString & sExtraTable</i> : extra table name to store id of each side of relationship ;</li>
                <li><i>const QString & sForeignKeyOwner</i> : foreign key in extra table linked to current class ;</li>
                <li><i>const QString & sForeignKeyDataType</i> : foreign key in extra table linked to other class.</li>
              </ul>
              <br>
              <b>For example :</b> a <i>category</i> embed several <i>blog</i> and a <i>blog</i> can belong to several <i>category</i> : we will show how to define a <b><i>many-to-many</i></b> relationship.
              A <i>n-n</i> relationship requires an extra table to store id of each side of relationship.<br>
              Here are the 3 tables in database : <br>
              <br>
              <img alt="qxBlog.table.category"
              src="./resource/qxBlog.table.category.jpg" width="464" height="115"><br>
              <br>
              <i>category.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.h">
<pre><span class="pre">#ifndef _QX_BLOG_CATEGORY_H_
#define _QX_BLOG_CATEGORY_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT category<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- properties
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   category<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>category<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>category<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> QSharedPointer<span class="operator">&lt;</span>category<span class="operator">&gt;</span> category_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> category_ptr<span class="operator">&gt;</span> list_category<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_CATEGORY_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              <i>category.cpp</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/category.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>category<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>category<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> category<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "description"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToMany<span class="operator">(&amp;</span> category<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "category_blog"</span><span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3830">one-to-one (1-1)</a></p>
            <div class="manual_div_content">
              A <i>one-to-one (1-1)</i> relationship links 2 entities which share the same database id.
              A <i>one-to-one (1-1)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToOne()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 2 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
              </ul>
              <br>
              <b>For example :</b> imagine a <i>person</i> table and an <i>author</i> table : an <i>author</i> is also a <i>person</i>, so these 2 tables could share the same id in database.
              Here are the 2 tables in database (with <i>person_id == author_id</i>) :<br>
              <br>
              <img alt="qxBlog.table.person" src="resource/qxBlog.table.person.jpg" width="279" height="118">
              <br><br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3840">Fetch relationships</a></p>
            <div class="manual_div_content">
              QxOrm library supports 4 kind of relationships to link C++ classes registered in QxOrm context : <i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i>.<br>
              For more details to define relationships, you can take a look at <a href="./tutorial.html" target="_blank">qxBlog tutorial</a>.<br>
              We will explain here how to fetch datas from many tables (<a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao</a> module, functions of <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace) :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query</a> : fetch datas from only 1 table from database (<i>lazy fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_all_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_all_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_all_relation</a> : fetch datas from 1 table + all tables linked (<i>eager fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> : same as above (<i>eager fetch</i>) with possibility to select relationships to fetch on many levels.</li>
              </ul>
              The first parameter of <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> functions is the list of relationships to fetch.<br>
              This list of relationships can contain these items :
              <ul>
              <li>relation key : each relation is associated to a key defined in <i>qx::register_class&lt;T&gt;</i> mapping function ;</li>
              <li>"<i>*</i>" keyword means "<i>fetch all relationships defined in <i>qx::register_class&lt;T&gt;</i> function (1 level of relationships)</i>" ;</li>
              <li>"<i>-></i>" keyword means "<i>LEFT OUTER JOIN</i>" join type between 2 tables ;</li>
              <li>"<i>>></i>" keyword means "<i>INNER JOIN</i>" join type between 2 tables.</li>
              </ul>
              <b>Note :</b> using "*" keyword to indicate "<i>fetch all relationships defined into <i>qx::register_class&lt;T&gt;</i> function</i>", following calls are similar :
              <ul>
              <li><i>qx::dao::fetch_by_id_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_id_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_by_query_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_query_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_all_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_all_with_all_relation(...)</i>.</li>
              </ul>
              <br>
              <b>Example :</b> from qxBlog tutorial, it's possible to fetch all these datas with only 1 query :<br>
              <br>
              <b>1-</b> fetch a <i>blog</i> and its <i>author</i> ;<br>
              <b>2-</b> for the <i>author</i> fetched, fetch all <i>blog</i> he wrote ;<br>
              <b>3-</b> for each <i>blog</i> written by <i>author</i> fetched, fetch all <i>comment</i> associated.<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:180px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Another example :</b> it's also possible to create a list of relationships to fetch, like this :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QStringList relation<span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_category"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_category"</span><span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>relation<span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:270px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, 
       category_7.category_id AS category_7_category_id_0, category_7.name AS category_7_name_0, category_7.description AS category_7_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN category_blog category_blog_7 ON blog.blog_id = category_blog_7.blog_id 
LEFT OUTER JOIN category category_7 ON category_blog_7.category_id = category_7.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Another example :</b> to fetch all relationships per level, "*" keyword must be used.<br>
              So to fetch all relationships on 3 levels, we can write :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"*-&gt;*-&gt;*"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:620px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, blog_2.author_id AS blog_2_author_id_0_2, 
       author_3.author_id AS author_3_author_id_0, author_3.name AS author_3_name_0, author_3.birthdate AS author_3_birthdate_0, author_3.sex AS author_3_sex_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, comment_6.blog_id AS comment_6_blog_id_0_6, 
       blog_7.blog_id AS blog_7_blog_id_0, blog_7.blog_text AS blog_7_blog_text_0, blog_7.date_creation AS blog_7_date_creation_0, blog_7.author_id AS blog_7_author_id_0_7, 
       author_8.author_id AS author_8_author_id_0, author_8.name AS author_8_name_0, author_8.birthdate AS author_8_birthdate_0, author_8.sex AS author_8_sex_0, 
       comment_9.comment_id AS comment_9_comment_id_0, comment_9.blog_id AS comment_9_blog_id_0, comment_9.comment_text AS comment_9_comment_text_0, comment_9.date_creation AS comment_9_date_creation_0, 
       category_10.category_id AS category_10_category_id_0, category_10.name AS category_10_name_0, category_10.description AS category_10_description_0, 
       category_11.category_id AS category_11_category_id_0, category_11.name AS category_11_name_0, category_11.description AS category_11_description_0, 
       blog_12.blog_id AS blog_12_blog_id_0, blog_12.blog_text AS blog_12_blog_text_0, blog_12.date_creation AS blog_12_date_creation_0, blog_12.author_id AS blog_12_author_id_0_12, 
       author_13.author_id AS author_13_author_id_0, author_13.name AS author_13_name_0, author_13.birthdate AS author_13_birthdate_0, author_13.sex AS author_13_sex_0, 
       comment_14.comment_id AS comment_14_comment_id_0, comment_14.blog_id AS comment_14_blog_id_0, comment_14.comment_text AS comment_14_comment_text_0, comment_14.date_creation AS comment_14_date_creation_0, 
       category_15.category_id AS category_15_category_id_0, category_15.name AS category_15_name_0, category_15.description AS category_15_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN author author_3 ON author_3.author_id = blog_2.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN blog blog_7 ON blog_7.blog_id = comment_6.blog_id 
LEFT OUTER JOIN author author_8 ON author_8.author_id = blog_7.author_id 
LEFT OUTER JOIN comment comment_9 ON comment_9.blog_id = blog_7.blog_id 
LEFT OUTER JOIN category_blog category_blog_10 ON blog_7.blog_id = category_blog_10.blog_id 
LEFT OUTER JOIN category category_10 ON category_blog_10.category_id = category_10.category_id 
LEFT OUTER JOIN category_blog category_blog_11 ON blog.blog_id = category_blog_11.blog_id 
LEFT OUTER JOIN category category_11 ON category_blog_11.category_id = category_11.category_id 
LEFT OUTER JOIN category_blog category_blog_12 ON category_11.category_id = category_blog_12.category_id 
LEFT OUTER JOIN blog blog_12 ON category_blog_12.blog_id = blog_12.blog_id 
LEFT OUTER JOIN author author_13 ON author_13.author_id = blog_12.author_id 
LEFT OUTER JOIN comment comment_14 ON comment_14.blog_id = blog_12.blog_id 
LEFT OUTER JOIN category_blog category_blog_15 ON blog_12.blog_id = category_blog_15.blog_id 
LEFT OUTER JOIN category category_15 ON category_blog_15.category_id = category_15.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3850">Select columns fetching relationships</a></p>
            <div class="manual_div_content">
               It is sometimes necessary to not request all table columns to optimize : indeed, selecting columns really used by a process limits network traffic between database and C++ application, so performance are improved.<br>
               <br>
               About relationships, QxOrm library provides a syntax to select columns to fetch, using format : <b>my_relation { col_1, col_2, etc... }</b>.
               By default, if this syntax is not used, then QxOrm library fetches all columns.<br>
               <br>
               <b>For example</b> : imagine a query to fetch :
               <ul>
                  <li>only <i>blog_text</i> column of <i>blog</i> table ;</li>
                  <li>only <i>name</i> and <i>birthdate</i> columns of <i>author</i> table ;</li>
                  <li>only <i>comment_text</i> column of <i>comment</i> table.</li>
               </ul>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre><span class="comment">   // Fetch relations defining columns to fetch with syntax { col_1, col_2, etc... }
</span>   list_blog lstBlogComplexRelation<span class="operator">;</span>
   <font style="background-color:yellow">QStringList relations<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "{ blog_text }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "author_id { name, birthdate }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "list_comment { comment_text }"</span><span class="operator">;</span></font>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all_with_relation<span class="operator">(</span>relations<span class="operator">,</span> lstBlogComplexRelation<span class="operator">);</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lstBlogComplexRelation<span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_creation<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_sex<span class="operator"> ==</span> author<span class="operator">::</span>unknown<span class="operator">);</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_name<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_create<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Note :</b> another syntax is available to select columns to not fetch : <b>my_relation -{ col_1, col_2, etc... }</b>.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_390">Supported containers</a></p>
         <div class="manual_div_content">
            QxOrm library supports several containers provided by <a href="#manual_3900">Qt</a>, <a href="#manual_3910">boost</a> and <a href="#manual_3920">std standard library</a>.
            QxOrm library provides also its own container, named <a href="#manual_3930">qx::QxCollection</a>, especially designed to store data fetched from database.
            So the developer is not restricted : QxOrm library offers a large choice of containers.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3900">Qt containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt collections">
<pre>
  QList&lt;T&gt;  
  QVector&lt;T&gt;  
  QSet&lt;T&gt;  
  QLinkedList&lt;T&gt;  
  QHash&lt;Key, Value&gt;  
  QMap&lt;Key, Value&gt;  
  QMultiHash&lt;Key, Value&gt;  
  QMultiMap&lt;Key, Value&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3910">Boost containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost collections">
<pre>
  boost::unordered_map&lt;Key, Value&gt;  
  boost::unordered_set&lt;T&gt;  
  boost::unordered_multimap&lt;Key, Value&gt;  
  boost::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3920">std containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std collections">
<pre>
  std::list&lt;T&gt;  
  std::vector&lt;T&gt;  
  std::set&lt;T&gt;  
  std::map&lt;Key, Value&gt;  

  <span class="comment">// With _QX_CPP_11_CONTAINER compilation option defined</span>  
  std::unordered_map&lt;Key, Value&gt;  
  std::unordered_set&lt;T&gt;  
  std::unordered_multimap&lt;Key, Value&gt;  
  std::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3930">qx::QxCollection</a></p>
            <div class="manual_div_content">
              There are several containers provided by <b>stl</b>, <b>boost</b> and <b>Qt</b> libraries.<br>
              So, it is legitimate to ask this question : what is <i>qx::QxCollection&lt;Key, Value&gt;</i> for ?<br>
              <i><a href="../doxygen/html/classqx_1_1_qx_collection.html" target="_blank">qx::QxCollection&lt;Key, Value&gt;</a></i> is a new <i>container</i> (based on the excellent <a href="http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a> library) which has following features :
              <ul><li>keeps insertion order of items in the list ;
              </li><li>quick access to an item by its index : is equivalent to <i>std::vector&lt;T&gt;</i> or <i>QList&lt;T&gt;</i> for example ;
              </li><li>quick access to an item by a key (<i>hash-map</i>) : is equivalent to <i>QHash&lt;Key, Value&gt;</i> or <i>boost::unordered_map&lt;Key, Value&gt;</i> for example ;
              </li><li>sort by <i>Key</i> type and by <i>Value</i> type.</li>
              </ul>
              <b>Note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is compatible with the <i>foreach</i> macro provided by <b>Qt</b> library and the <a href="http://www.boost.org/doc/libs/release/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> macro provided by <b>boost</b> library.<br>
              However, each element returned by these 2 macros matches to an object of <i>std::pair&lt;Key, Value&gt;</i> type.<br>
              To get a more natural and more readable result, it is advised to use the <i>_foreach</i> macro : this macro uses <i>BOOST_FOREACH</i> for all containers except for <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              In this case, the returned element matches to the <i>Value</i> type (cf. <i>sample</i>).<br>
              <i>_foreach</i> macro is compatible with all <i>containers</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>...) since it uses <i>BOOST_FOREACH</i> macro.<br><br>

              <b>Additional note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is especially designed to receive data resulting from a database.<br>
              Indeed, these data can be sorted (using <i>ORDER BY</i> in a SQL query for example), it is thus important to keep insertion order of items in the list.<br>
              Furthermore, each data resulting from a database has a unique id : it is thus important to be able to access quickly to an item based on this single identifier (<i>hash-map</i>).<br><br>

              <b>Sample :</b><br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* definition of drug class with 3 properties : code, name, description */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* smart pointer of drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection of drugs by code */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* create 3 new drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insert drugs into the collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* iterate with '_foreach' keyword */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* iterate with 'for' keyword */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* iterate with 'QxCollectionIterator' java style */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* sort ascending by key and sort descending by value */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* access drug by code */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* access drug by index */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* test if drug exists and if collection is empty */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* remove the second drug from collection */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* remove the drug with "code3" */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* clear the collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_400">Supported smart pointers</a></p>
         <div class="manual_div_content">
            QxOrm library supports several smart pointers provided by <a href="#manual_4000">Qt</a>, <a href="#manual_4010">boost</a> and <a href="#manual_4020">std standard library</a>.
            QxOrm library provides also its own smart pointer, named <a href="#manual_4030">qx::dao::ptr</a>, which provides new features when used with <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> functions.
            So the developer is not restricted : QxOrm library offers a large choice of smart pointers.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4000">Qt smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt smart pointers">
<pre>
  QSharedPointer&lt;T&gt;  
  QScopedPointer&lt;T&gt;  
  QWeakPointer&lt;T&gt;  
  QSharedDataPointer&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4010">Boost smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost smart pointers">
<pre>
  boost::shared_ptr&lt;T&gt;  
  boost::intrusive_ptr&lt;T&gt;  
  boost::scoped_ptr&lt;T&gt;  
  boost::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4020">std smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std smart pointers">
<pre>
  <span class="comment">// With _QX_CPP_11_SMART_PTR compilation option defined</span>  
  std::shared_ptr&lt;T&gt;  
  std::unique_ptr&lt;T&gt;  
  std::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4030">qx::dao::ptr</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> library can be used with smart-pointers provided by <b>std</b>, <b>boost</b> and <b>Qt</b> libraries.<br>
              <b>QxOrm</b> smart-pointer is based on <i>QSharedPointer</i> and provides new features with '<i>qx::dao::...</i>' functions.<br>
              <i><a href="../doxygen/html/classqx_1_1dao_1_1ptr.html" target="_blank">qx::dao::ptr&lt;T&gt;</a></i> keeps automatically values from database.<br>
              So it's possible to detect if an instance has been modified using the method '<i>isDirty()</i>' : this method can return list of properties changed.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> can also be used with the function '<i>qx::dao::update_optimized()</i>' to update in database only properties changed.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> can be used with a simple object and with many containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> and <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              <br>
              <b>Sample :</b><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">   // Test 'isDirty()' method
</span>   qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

   blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
   QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_text' of 'blog_isdirty'
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

   // Test 'isDirty()' method with a container
</span><span class="keyword">   typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

   type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

   author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

   author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_name' at position 1, only property 'm_birthdate' at position 2 and nothing at position 0
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

   // Fetch only property 'm_dt_creation' of blog
</span>   QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
   list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

   if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
   {</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_410">Triggers</a></p>
         <div class="manual_div_content">
           With <b>QxOrm</b> <i>Triggers</i>, it is possible to execute custom process before and/or after an insert, update or delete query in database.<br>
           You can find a sample in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.<br>
           <i>BaseClassTrigger</i> sample class contains 5 properties : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> and <i>m_userModification</i>.<br>
           In the following example, each property will be automatically auto-updated for all derived classes from <i>BaseClassTrigger</i> (see <i>Foo</i> class and <i>Bar</i> class in the same project).<br>
           It is necessary to specialize '<i>qx::dao::detail::QxDao_Trigger&lt;T&gt;</i>' template to work with this feature.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span>

   <font style="background-color:yellow"><span class="type">void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>
   <font style="background-color:yellow"><span class="type">void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span>
<font style="background-color:yellow"><span class="keyword">struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;</span></font>
<span class="operator">{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }
   static inline</span><span class="type"> void</span> onAfterFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_420">Validators</a></p>
         <div class="manual_div_content">
            <b><a href="../doxygen/html/group___qx_validator.html" target="_blank">QxValidator</a></b> module of <b>QxOrm</b> library provides a validation engine for classes registered in QxOrm context.<br>
            To use this validation engine, you have to define your constraints into the mapping function per class : <i>void qx::register_class&lt;T&gt;</i>.<br>
            If for an instance of class, at least one constraint violation is detected, then the instance is invalid : the object cannot be saved into database (<i>INSERT</i> or <i>UPDATE</i>).<br>
            <br>
            It's also possible to use <b>QxValidator</b> module to validate an instance on the presentation layer : if some datas from a user are invalids, an error message can be displayed, and it's not necessary to try to send the instance to the data access layer.<br>
            The validation process can be executed in several layers of your application without having to duplicate any of these rules (presentation layer, data access layer).<br>
            <br>
            Here is a description of some classes defined in <b>QxValidator</b> module :
            <ul>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator.html" target="_blank">qx::IxValidator</a> : each constraint defined in <i>void qx::register_class&lt;T&gt;</i> function is associated with an interface of <i>qx::IxValidator</i> type ;</li>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator_x.html" target="_blank">qx::IxValidatorX</a> : the list of constraints is associated with an interface of <i>qx::IxValidatorX</i> type. You can iterate over this collection during program execution : it could be interesting for example to generate DDL SQL schema and to take into account some validation rules into database (read the chapter : <a href="#manual_470">Generate database DDL SQL schema</a>) ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value_x.html" target="_blank">qx::QxInvalidValueX</a> : when an instance is invalid, list of constraints violation are inserted into a <i>qx::QxInvalidValueX</i> collection ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value.html" target="_blank">qx::QxInvalidValue</a> : each item into this collection is a <i>qx::QxInvalidValue</i> type and contains an error message (description to explain why the instance is not valid).</li>
            </ul>
            <b>QxValidator</b> module manages automatically class inheritance : each constraint defined into a base class is checked during validation process of a derived class.<br>
            <br>
            Here is an example using <b>QxValidator</b> module with a '<i>person</i>' class :<br>
            <br>
            * '<i>person.h</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _CLASS_PERSON_H_
#define _CLASS_PERSON_H_
</span><span class="keyword"> 
class</span> person<span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span><span class="keyword">

   enum</span> sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="type">

   long</span>        _id<span class="operator">;</span>
   QString     _firstName<span class="operator">;</span>
   QString     _lastName<span class="operator">;</span>
   QDateTime   _birthDate<span class="operator">;</span>
   sex         _sex<span class="operator">;</span>

   person<span class="operator">() :</span> _id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span>
   person<span class="operator">(</span><span class="type">long</span> id<span class="operator">) :</span> _id<span class="operator">(</span>id<span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span>

   <font style="background-color:yellow"><span class="type">void</span> isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _CLASS_PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>person.cpp</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/person.h"
#include "../include/global_validator.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_MY_EXE<span class="operator">(</span>person<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_firstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_lastName<span class="operator">,</span><span class="string"> "lastName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_birthDate<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">QxValidatorX<span class="operator">&lt;</span>person<span class="operator">&gt; *</span> pAllValidator<span class="operator"> =</span> t<span class="operator">.</span>getAllValidator<span class="operator">();</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"lastName"</span><span class="operator">,</span><span class="string"> "a person must have a lastname"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator<span class="operator">(&amp;</span> person<span class="operator">::</span>isValid<span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_QVariant<span class="operator">(&amp;</span> validateFirstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_DataType<span class="operator">&lt;</span>QDateTime<span class="operator">&gt;(&amp;</span> validateDateTime<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span></font>
<span class="operator">}}</span>

<font style="background-color:yellow"><span class="type">void</span> person<span class="operator">::</span>isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)</span></font>
<span class="operator">{</span><span class="comment">
   // This method is called automatically by 'QxValidator' module (validator engine of QxOrm library) :
   // - when you try to insert or update using 'qx::dao::xxx' functions
   // - when you call 'qx::validate()' function

   // For registration, see 'pAllValidator->add_CustomValidator(& person::isValid);' into 'qx::register_class' function

   // Here, you can verify some values of your instance
   // If a value is not valid, you must add an invalid value into the collection 'invalidValues'

   // For example, if we want to check property '_sex' of a person :
</span><span class="flow">   if</span><span class="operator"> ((</span>_sex<span class="operator"> !=</span> male<span class="operator">) &amp;&amp; (</span>_sex<span class="operator"> !=</span> female<span class="operator">))
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"person sex must be defined : male or female"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>global_validator.h</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Example of global functions 'validateFirstName' and 'validateDateTime' used by 'QxValidator' module
// Those functions will be called automatically by validator engine of QxOrm library :
// - when you try to insert or update using 'qx::dao::xxx' functions
// - when you call 'qx::validate()' function
</span><span class="type"> 
void</span> validateFirstName<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Here you can test the value (converted to QVariant type)
   // If an invalid value is detected, just add a message into 'invalidValues' collection

   // For example, if the value must be never equal to "admin" :
</span><span class="flow">   if</span><span class="operator"> (</span>value<span class="operator">.</span>toString<span class="operator">() ==</span><span class="string"> "admin"</span><span class="operator">)
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"value must not be equal to 'admin'"</span><span class="operator">); }
}</span><span class="type">

void</span> validateDateTime<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Here you can test the value (with its real type, in this example, the data-member is a 'QDateTime' type)
   // If an invalid value is detected, just add a message into 'invalidValues' collection

   // For example, if the date-time must be valid :
</span><span class="flow">   if</span><span class="operator"> (!</span> value<span class="operator">.</span>isValid<span class="operator">())
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"date-time value must not be empty and must be valid"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>main.cpp</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>person personValidate<span class="operator">;</span>
personValidate<span class="operator">.</span>_lastName<span class="operator"> =</span><span class="string"> "admin"</span><span class="operator">;</span>
qx<span class="operator">::</span>QxInvalidValueX invalidValues<span class="operator"> =</span> qx<span class="operator">::</span>validate<span class="operator">(</span>personValidate<span class="operator">);</span>
QString sInvalidValues<span class="operator"> =</span> invalidValues<span class="operator">.</span>text<span class="operator">();</span>
qDebug<span class="operator">(</span><span class="string">"[QxOrm] test 'QxValidator' module :\n%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sInvalidValues<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            During program execution of above source code, '<i>personValidate</i>' instance is not valid : '<i>invalidValues</i>' collection contains 4 items :<br>
            - "<i>property 'firstName' must not be empty</i>" ;<br>
            - "<i>person sex must be defined : male or female</i>" ;<br>
            - "<i>value must not be equal to 'admin'</i>" ;<br>
            - "<i>date-time value must not be empty and must be valid</i>".<br>
            <br>
            <b>QxValidator</b> module provides some built-in constraints, which cover most of the basic data checks.<br>
            As we'll see later, you're not limited to them, you can literally in a minute write your own constraints :
            <ul>
                <li><i>add_NotNull()</i> : checks if the value is not null ;</li>
                <li><i>add_NotEmpty()</i> : checks if the string is not empty ;</li>
                <li><i>add_MinValue()</i> : checks if the value is more than or equals to min ;</li>
                <li><i>add_MaxValue()</i> : checks if the value is less than or equals to max ;</li>
                <li><i>add_Range()</i> : checks if the value is between Min and Max (included) ;</li>
                <li><i>add_MinDecimal()</i> : checks if the decimal value is more than or equals to min ;</li>
                <li><i>add_MaxDecimal()</i> : checks if the decimal value is less than or equals to max ;</li>
                <li><i>add_RangeDecimal()</i> : checks if the decimal value is between Min and Max (included) ;</li>
                <li><i>add_MinLength()</i> : checks if the string length is more than or equals to min ;</li>
                <li><i>add_MaxLength()</i> : checks if the string length is less than or equals to max ;</li>
                <li><i>add_Size()</i> : checks if the string length is between the min-max range ;</li>
                <li><i>add_DatePast()</i> : checks if the date is in the past ;</li>
                <li><i>add_DateFuture()</i> : checks if the date is in the future ;</li>
                <li><i>add_RegExp()</i> : checks if the property matches the regular expression given a match flag ;</li>
                <li><i>add_EMail()</i> : checks whether the string conforms to the email address specification.</li>
            </ul>
            Like '<i>person</i>' class example, it's possible to define a custom validator : it's a function or a class method called automatically by <b>QxValidator</b> module to validate a property or an instance of class.<br>
            There are 3 kinds of custom validator :
            <ul>
                <li><i>add_CustomValidator()</i> : class method, method signature must be "<i>void my_class::my_method(qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_QVariant()</i> : global function with <i>QVariant</i> type (the property is converted into <i>QVariant</i> type), function signature must be "<i>void my_validator(const QVariant &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_DataType()</i> : global function with real type, function signature must be "<i>void my_validator(const T &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
            </ul>
            <b>Note :</b> each validator can be associated with a group (optional parameter for each function <i>add_XXX()</i> of <i>qx::IxValidatorX</i> class).<br>
            So it's possible to create a context validation during program execution : for example, a person from IHM A can have different validation rules than a person from IHM B.<br>
            To execute a validation process by group (for example "<i>myGroup</i>"), you have to call the following function : "<i>qx::QxInvalidValueX invalidValues = qx::validate(personValidate, "myGroup");</i>".<br>
            <br>
            <b>Other note :</b> <b>QxValidator</b> module provides default messages when a constraint violation is detected.<br>
            It's possible to modify these default messages (for example, a translation) using the following collection : "<i>QHash<QString, QString> * lstMessage = QxClassX::getAllValidatorMessage();</i>".<br>
            For example : "<i>lstMessage->insert("min_value", "la valeur '%NAME%' doit être inférieure ou égale à '%CONSTRAINT%'");</i>".<br>
            <i>%NAME%</i> and <i>%CONSTRAINT%</i> fields will be automatically replaced by the good value.<br>
            To modify a message for a specific validator (and not globally), you have to use the optional parameter provided by each function <i>add_XXX()</i> of <i>qx::IxValidatorX</i> class.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_430">Manage NULL database value</a></p>
         <div class="manual_div_content">
            All databases manages NULL value : for more details about NULL value, <a href="https://en.wikipedia.org/wiki/Null_%28SQL%29" target="_blank">please read the Wikipedia web page</a>.<br>
            QxOrm library provides several ways to manage NULL value :
            <ul>
               <li>using <a href="#manual_4300">boost::optional</a> class provided by boost library ;</li>
               <li>using <a href="#manual_4310">QVariant</a> class provided by Qt framework ;</li>
               <li>using pointers or smart-pointers : a C++ NULL pointer is associated to a NULL value in database.</li>
            </ul>
            <br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4300">boost::optional</a></p>
            <div class="manual_div_content">
               <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class provided by boost is the best solution to manage NULL value in C++.<br>
               Here is an example where all properties (except primary key) can be NULL using <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional</a> class :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QDateTime&gt; birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class is very easy to use : please read <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">documentation on boost website</a> for more details.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4310">QVariant</a></p>
            <div class="manual_div_content">
               <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> class provided by Qt is another way to manage NULL value in C++.<br>
               Here is a class example where all values (except primary key) can be NULL using <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> class :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">QVariant firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }  
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               This solution is not perfect compared to <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> because you loose the property type.<br>
               So it is recommended to work with <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class to manage NULL value with QxOrm library.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_440">Inheritance and polymorphism</a></p>
         <div class="manual_div_content">
           With <i>ORM</i> tools, there are usually 3 strategies to manage inheritance and database :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i>.
           </li></ul>
           <b>QxOrm</b> works by default with <i>Concrete Table Inheritance</i> strategy (others are not supported yet).<br>
           Many tutorials and forums are available on internet for more details about <i>ORM</i> inheritance and database.<br>
           You can find a sample in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_450">qx::IxPersistable interface (abstract class)</a></p>
         <div class="manual_div_content">
           <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface (or abstract class) provides only pure virtual methods.<br>
           Using <i>qx::IxPersistable</i>, you will have a common base class to call all persistents functions without knowing the real type of current instance (polymorphism concept).<br>
           QxOrm library doesn't force developers to work with a base class to register a persistent type in QxOrm context, however it's sometimes useful to have an interface to write some generic algorithms.<br>
           <br>
           <i>qx::IxPersistable</i> class provides following virtual methods (for more details about these methods, goto <a href="../doxygen/index.html" target="_blank">QxOrm library online class documentation</a>) :<br>
           <br>
           <div style="width:900px; height:290px; overflow:auto; background-color:white">
<pre><span class="keyword">virtual</span><span class="type"> long</span> qxCount<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchAll<span class="operator">(</span>qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxInsert<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxUpdate<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxSave<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx_bool qxExist<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>QxInvalidValueX qxValidate<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> groups<span class="operator"> =</span> QStringList<span class="operator">());</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxCollection_ptr qxNewPersistableCollection<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxClass<span class="operator"> *</span> qxClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></pre>
           </div>
           <br>
           For example, working with a list of <i>qx::IxPersistable</i> pointers, it's possible to save all items to several database tables, like this :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QList<span class="operator">&lt;</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *&gt;</span> lst<span class="operator"> = ...;</span>
foreach<span class="operator">(</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *</span> p<span class="operator">,</span> lst<span class="operator">)
{</span>
   QSqlError daoError<span class="operator"> =</span> p<span class="operator">-&gt;</span>qxSave<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>daoError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="comment"> /* an error occured */</span><span class="operator"> }</span><span class="comment">
   // etc...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           To implement <i>qx::IxPersistable</i> interface, it's necessary to :
           <ul>
           <li>inherit persistent class from <i>qx::IxPersistable</i> ;</li>
           <li>into class definition (<i>myClass.h</i> for example), add <i>QX_PERSISTABLE_HPP(myClass)</i> macro ;</li>
           <li>into class implementation (<i>myClass.cpp</i> for example), add <i>QX_PERSISTABLE_CPP(myClass)</i> macro.</li>
           </ul>
           For example, to implement <i>qx::IxPersistable</i> interface for <a href="./tutorial.html#tuto_6"><i>author</i></a> class from <i>qxBlog</i> tutorial, you have to write :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author : <font style="background-color:yellow"><b>public qx::IxPersistable</b></font><span class="operator">
{</span>
   <font style="background-color:yellow"><b>QX_PERSISTABLE_HPP(author)</b></font>
<span class="keyword">public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- properties
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   list_blog   m_blogX<span class="operator">;</span><span class="comment">
// -- contructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
        </td></tr></tbody></table>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span>
<font style="background-color:yellow"><b>QX_PERSISTABLE_CPP(author)</b></font>

<span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> project test from <i>./test/qxDllSample/dll1/</i> directory provides a kind of 'super base class' : <i>qx::QxPersistable</i> class implements <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface and inherits from <i>QObject</i>.<br>
           So <i>SIGNAL-SLOT</i> engine of Qt library can be used with this class and could be an interesting way to use QxOrm <a href="#manual_410"><i>triggers</i></a>.<br>
           <i>qx::QxPersistable</i> class provides also some virtual methods to override to manage for example data validation process from <a href="#manual_420"><i>QxValidator</i></a> module.<br>
           For information, <i>qx::QxPersistable</i> class is not a part of QxOrm library, but you can copy-past it into your own project to use all its features :
           <ul>
           <li>access to <a href="./resource/qx_persistable_hpp.html" target="_blank"><i>QxPersistable.hpp</i></a> file ;</li>
           <li>access to <a href="./resource/qx_persistable_cpp.html" target="_blank"><i>QxPersistable.cpp</i></a> file.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_460">Persist custom type</a></p>
         <div class="manual_div_content">
           QxOrm library can persist every types, not only classes registered in QxOrm context using <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           It's necessary to write serialization functions from boost framework, using the <b>non intrusive</b> method (because source code is not available or is read-only).
           For more details on boost serialization module, <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">goto official website</a>.<br>
           <br>
           For example, imagine that you have the class '<i>ExtObject3D</i>' from an external library and the source code is not available or is read-only.
           Here is the code to can persist an instance of '<i>ExtObject3D</i>' type into database :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Now you can persist an instance of '<i>ExtObject3D</i>' type into database : so you can have a '<i>ExtObject3D</i>' property in a persistent class registered in QxOrm context.
           This property can be mapped with a column of type <i>TEXT</i> or <i>VARCHAR</i> into database.<br>
           <br>
           The default behaviour of QxOrm library is : the instance is serialized to XML format before being inserted or updated into database.
           This default behaviour can be useful, for example if you want to save a collection of items without to make relation (so you don't have to manage another table into database).
           For example, with a property of type <i>std::vector&lt;mon_objet&gt;</i> in a persistent class without relation, the list of items will be saved into database under XML format.<br>
           <br>
           <b>Note :</b> the default behaviour can be easily modified for a specific type.
           <i>QtSql</i> engine uses <i>QVariant</i> type to link C++ code and database.
           <i>QVariant</i> type can contain text, numeric, binary, etc.
           So it can be interesting to specialize the default behaviour (XML serialization) if you want to save datas under binary format or to optimize your application (XML serialization is not very fast).
           You just have to write (with boost serialization functions) a conversion into/from <i>QVariant</i> type, for example with '<i>ExtObject3D</i>' class :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Here I convert from ExtObject3D to QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Here I convert from QVariant to ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_470">Generate database DDL SQL schema</a></p>
         <div class="manual_div_content">
           <a href="#manual_110"><b><font style="background-color:yellow">!!! It's strongly recommended to use <b>QxEntityEditor</b> application to manage DDL SQL schema generation !!!</font></b></a><br>
           <br>
           QxOrm library doesn't provide a generator to create and to update automatically tables into database.<br>
           Indeed, <i>qx::dao::create_table&lt;T&gt;</i> function must be used only to create prototypes or samples.<br>
           It's strongly recommended to work with a tool provided by each SGBD to design and to manage tables into database (for example <i>Navicat</i> with <i>MySql</i>, <i>pgAdmin</i> with <i>PostgreSQL</i>, <i>SQLite Manager</i> with <i>SQLite</i>, etc.).<br>
           Moreover, each tool provided by each SGBD can add some optimizations to the database (add some indexes for example).<br>
           <br>
           But sometimes, it can be useful to not have to manage manually tables into database.<br>
           In this case, it's possible to create a C++ function to iterate over all persistents classes registered in QxOrm context (using introspection engine of QxOrm library) : so you can build a SQL script to create and to update tables into database.<br>
           <br>
           QxOrm library provides an example of a C++ function : based on this function, you can create your own function to build SQL schema.<br>
           This QxOrm function is written in the file <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">./src/QxRegister/QxClassX.cpp</a></i> and is called <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">QString qx::QxClassX::dumpSqlSchema()</a></i>.<br>
           This QxOrm function builds a SQL script and returns a <i>QString</i> value : it's also possible to modify the function to generate a file with SQL script or to execute each SQL process directly to the SGBD.<br>
           <br>
           Here is a sample implementation provided by <a href="http://www.developpez.net/forums/u449556/dodobibi/" target="_blank">dodobibi</a> to manage a <i>PostgreSQL</i> database : this sample works with a version number to add columns to existing tables, to add some indexes to existing columns, etc.<br>
           When you start your application, a version number is provided and incremented when a new version of your application is released :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QApplication app<span class="operator">(</span>argc<span class="operator">,</span> argv<span class="operator">);</span>
app<span class="operator">.</span>setProperty<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span><span class="comment"></span></pre>
           </td></tr></tbody></table>
           <br>
           A table into the database must be created to store this version number.<br>
           A C++ persistent class is mapped to this table :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _DATABASE_VERSION_H_
#define _DATABASE_VERSION_H_
</span><span class="keyword"> 
class</span> MY_DLL_EXPORT DatabaseVersion<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
  QString name<span class="operator">;</span><span class="type">
  long</span> version<span class="operator">;
};</span>

QX_REGISTER_HPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _DATABASE_VERSION_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/DatabaseVersion.h"
#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>DatabaseVersion<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>version<span class="operator">,</span><span class="string"> "version"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           With <i>DatabaseVersion</i> class, it's possible to verify that the database must be updated or not.<br>
           This is the goal of <i>isDatabaseVersionOld()</i> function :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">bool</span> isDatabaseVersionOld<span class="operator">()
{</span>
  DatabaseVersion dbVersion<span class="operator">;</span>
  dbVersion<span class="operator">.</span>name<span class="operator"> =</span><span class="string"> "MyAppName"</span><span class="operator">;</span>
  QSqlError err<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="flow">
  if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="bool"> false</span><span class="operator">; }</span><span class="flow">
  return</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &lt;</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">());
}</span></pre>
           </td></tr></tbody></table>
           <br>
           If <i>isDatabaseVersionOld()</i> function returns <i>true</i> when you start your application, then you must update your SQL schema :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">void</span> updateDatabaseVersion<span class="operator">()
{</span><span class="flow">
  try</span><span class="operator">
  {</span><span class="type">
    int</span> domainVersion<span class="operator"> =</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">();</span><span class="comment">

    // Connect to the database with a user with modifications rights on SQL schema
</span>    QSqlDatabase db<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getDatabaseCloned<span class="operator">();</span>
    db<span class="operator">.</span>setUserName<span class="operator">(</span><span class="string">"MyAdminLogin"</span><span class="operator">);</span>
    db<span class="operator">.</span>setPassword<span class="operator">(</span><span class="string">"MyAdminPassword"</span><span class="operator">);</span><span class="comment">

    // Create a session, open automatically a transaction and throw an exception when an error occured
</span>    qx<span class="operator">::</span>QxSession session<span class="operator">(</span>db<span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">);</span><span class="comment">

    // Fetch the database version with a lock to protect the database
</span>    DatabaseVersion dbVersion<span class="operator">;</span>
    session<span class="operator">.</span>fetchByQuery<span class="operator">(</span>qx_query<span class="operator">(</span><span class="string">"WHERE name='MyAppName' FOR UPDATE"</span><span class="operator">),</span> dbVersion<span class="operator">);</span><span class="comment">

    // When unlocked for other users, verify that the database must be updated or not
</span><span class="flow">    if</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &gt;=</span> domainVersion<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // Execute each SQL process with "query" variable
</span>    QSqlQuery query<span class="operator">(</span>db<span class="operator">);</span><span class="comment">

    // Fetch all C++ persistents classes registered in QxOrm context
</span>    qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> qx<span class="operator">::</span>IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
    if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // Fetch all tables into database (this is a Qt function)
</span>    QStringList tables<span class="operator"> =</span> db<span class="operator">.</span>tables<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span><span class="type">long</span> k<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> k<span class="operator"> &lt;</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span> k<span class="operator">++)
    {</span>
      qx<span class="operator">::</span>IxClass<span class="operator"> *</span> pClass<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>getByIndex<span class="operator">(</span>k<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (!</span> pClass<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filter non persitents classes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxParameter"</span><span class="operator">) ||</span> pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxService"</span><span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filter already updated classes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // If table doesn't exist, create it and set the owner
</span><span class="flow">      if</span><span class="operator"> (!</span> tables<span class="operator">.</span>contains<span class="operator">(</span>pClass<span class="operator">-&gt;</span>getName<span class="operator">()))
      {</span>
        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ( ) WITH (OIDS = FALSE);"
                   "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " OWNER TO \"MyAdminLogin\";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
      }</span><span class="comment">

      // If a column doesn't exist, add it to the table
</span>      qx<span class="operator">::</span>IxDataMemberX<span class="operator"> *</span> pDataMemberX<span class="operator"> =</span> pClass<span class="operator">-&gt;</span>getDataMemberX<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">; (</span>pDataMemberX<span class="operator"> &amp;&amp; (</span>l<span class="operator"> &lt;</span> pDataMemberX<span class="operator">-&gt;</span>count_WithDaoStrategy<span class="operator">()));</span> l<span class="operator">++)
      {</span>
        qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> pDataMemberX<span class="operator">-&gt;</span>get_WithDaoStrategy<span class="operator">(</span>l<span class="operator">);</span><span class="flow">
        if</span><span class="operator"> (!</span> p<span class="operator"> || (</span>p<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span>

        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getSqlType<span class="operator">() +</span><span class="string"> ";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getIsPrimaryKey<span class="operator">())</span><span class="comment"> // PRIMARY KEY
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD PRIMARY KEY ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAllPropertyBagKeys<span class="operator">().</span>contains<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">))</span><span class="comment"> // INDEX
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE INDEX "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_idx"</span><span class="operator"> +</span><span class="string"> 
                     " ON "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " USING "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getPropertyBag<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">).</span>toString<span class="operator">() +</span><span class="string"> " ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getNotNull<span class="operator">())</span><span class="comment"> // NOT NULL
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " SET NOT NULL;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAutoIncrement<span class="operator">())</span><span class="comment"> // AUTO INCREMENT
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE SEQUENCE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> " OWNER TO \"MyAdminLogin\"; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span><span class="string">
                     "SET DEFAULT nextval('"</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "'::regclass);"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getDescription<span class="operator">() !=</span><span class="string"> ""</span><span class="operator">)</span><span class="comment"> // DESCRIPTION
</span><span class="operator">        {</span>          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"COMMENT ON COLUMN "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "."</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " IS $$"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span><span class="string"> "$$ ;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }
      }
    }</span><span class="comment">

    // Save current version of the database
</span>    dbVersion<span class="operator">.</span>version<span class="operator"> =</span> domainVersion<span class="operator">;</span>
    session<span class="operator">.</span>save<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="comment">

    // End of "try" scope : session is destroyed =&gt; commit or rollback automatically
    // Moreover, a commit or a rollback unlock the process for all users
</span><span class="operator">  }</span><span class="flow">
  catch</span><span class="operator"> (</span><span class="keyword">const</span> qx<span class="operator">::</span>dao<span class="operator">::</span>sql_error<span class="operator"> &amp;</span> err<span class="operator">)
  {</span>
    QSqlError sqlError<span class="operator"> =</span> err<span class="operator">.</span>get<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>databaseText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>driverText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>number<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>type<span class="operator">();
  }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> this code (like <a href="./resource/qxclassx_dump_sql_schema.html" target="_blank"><i>qx::QxClassX::dumpSqlSchema()</i></a> function) can be modified to provide more features.<br>
           For example, it could be interesting to create by default another table (like <i>DatabaseVersion</i> table) to store the list of all persistents classes registered in QxOrm context : instead of using "<i>db.tables()</i>" Qt function, it could be possible to fetch all tables with more information (version number for each table, columns count registered in QxOrm context, table description, etc.).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_475">Associate a SQL type to a C++ class</a></p>
         <div class="manual_div_content">
           Each database provides its own SQL types to store datas.<br>
           QxOrm library associates by default some C++ classes frequently used in a program :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
           </td></tr></tbody></table>
           <br>
           If a SQL type provided by default by QxOrm library is not supported by the database, it can be easily modified (globally for all the application) using the following collection :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QHash<span class="operator">&lt;</span>QString<span class="operator">,</span> QString<span class="operator">&gt; *</span> lstSqlType<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllSqlTypeByClassName<span class="operator">();</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"QString"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"std::string"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
// etc.</span></pre>
           </td></tr></tbody></table>
           <br>
           To modify a SQL type for a specific column of a table, you have to define the new SQL type in the mapping function of QxOrm library :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>MyClass<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span><span class="comment">
  //...
</span>  IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> MyClass<span class="operator">::</span>m_MyProperty<span class="operator">,</span><span class="string"> "my_property"</span><span class="operator">);</span>
  p<span class="operator">-&gt;</span>setSqlType<span class="operator">(</span><span class="string">"VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
  //...
</span><span class="operator">}}</span></pre>
           </td></tr></tbody></table>
           <br>
           For all classes not supported by default by QxOrm library (read chapter : <i><a href="#manual_460">Persist custom type</a></i>), it's possible to associate a default SQL type using the following macro (outside all <i>namespace</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_TRAIT_GET_SQL_TYPE<span class="operator">(</span>MyClass<span class="operator">,</span><span class="string"> "my_sql_type"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_480">Async database queries</a></p>
         <div class="manual_div_content">
           Sometimes, it's necessary to execute some queries to database in asynchronous way (multi-thread), for example to avoid to freeze a GUI if a query is too long to execute.<br>
           To make easier to work with asynchronous queries, QxOrm library provides <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i> class.<br>
           This class executes a query in another thread and returns the <i>queryFinished()</i> <i>SIGNAL</i> when query is terminated.<br>
           To use <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i> class, you just have to :
           <ul>
           <li>be careful to work only with classes implementing <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface ;</li>
           <li>create an instance of <i>qx::QxDaoAsync</i> type (for example, a property of a <i>QWidget</i> derived class) ;</li>
           <li>connect a <i>SLOT</i> to the <i>qx::QxDaoAsync::queryFinished()</i> <i>SIGNAL</i> (for example, a <i>SLOT</i> of a <i>QWidget</i> derived class) ;</li>
           <li>run a query using one of <i>qx::QxDaoAsync::asyncXXXX()</i> methods.</li>
           </ul>
           Here is an example with a class called <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MyWidget<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">
{</span> Q_OBJECT<span class="comment">

   //...
</span>   qx<span class="operator">::</span>QxDaoAsync m_daoAsync<span class="operator">;</span><span class="comment">
   //...
</span>Q_SLOTS<span class="operator">:</span><span class="type">
   void</span> onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">);</span><span class="comment">
   //...

</span><span class="operator">};</span></pre>
           </td></tr></tbody></table>
           <br>
           And here is the implementation of <i>MyWidget</i> class :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>MyWidget<span class="operator">::</span>MyWidget<span class="operator">() :</span> QObject<span class="operator">()
{</span><span class="comment">
   //...
</span>   QObject<span class="operator">::</span>connect<span class="operator">((&amp;</span> m_daoAsync<span class="operator">),</span> SIGNAL<span class="operator">(</span>queryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)),</span><span class="keyword"> 
                    this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)));</span><span class="comment">
   //...
</span><span class="operator">}</span><span class="type">

void</span> MyWidget<span class="operator">::</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> pDaoParams<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>
   qx<span class="operator">::</span>QxSqlQuery query<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>query<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (!</span> daoError<span class="operator">.</span>isValid<span class="operator">()) { ; }</span><span class="comment">
   // If the async query is associated to a simple object, just use 'pDaoParams-&gt;pInstance' method
</span>   qx<span class="operator">::</span>IxPersistable_ptr ptr<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pInstance<span class="operator">;</span><span class="comment">
   // If the async query is associated to a list of objects, just use 'pDaoParams-&gt;pListOfInstances' method
</span>   qx<span class="operator">::</span>IxCollection_ptr lst<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pListOfInstances<span class="operator">;</span><span class="comment">
   //...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_490">Cache to store C++ instances (QxCache module)</a></p>
         <div class="manual_div_content">
           Cache engine provided by QxOrm library (<a href="../doxygen/html/group___qx_cache.html" target="_blank"><i>QxCache</i> module</a>) is <i>thread-safe</i> and can store easily any kind of objects.<br>
           Functions to access to the cache engine are inside <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>.<br>
           <i>qx::cache</i> engine can provide a program optimization : you can for example store items fetched by a query to database.<br>
           <br>
           Each item into the cache is associated with a key of type <i>QString</i> : this key provides a quick access to an item stored into the cache.<br>
           If a new item is inserted with a key already in the cache, then the old item associated with this key is removed automatically from the cache.<br>
           <br>
           Cache engine of QxOrm library doesn't manage memory : there is no <i>delete</i> called by the cache engine.<br>
           This is why it's strongly recommended (but not an obligation) to store smart-pointers into the cache : for example, <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" target="_blank"><i>boost::shared_ptr&lt;T&gt;</i></a> of <i>boost</i> library or <a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer&lt;T&gt;</i></a> of <i>Qt</i> library.<br>
           <br>
           Cache engine can have a max cost to avoid too much memory usage : each item inserted to the cache can be associated with a cost (for example, element's count of a collection).<br>
           When the limit (max cost) of the cache engine is reached, first items inserted to the cache are automatically removed (insertion order) until limit of the cache is ok.<br>
           <br>
           It's also possible to associate a date-time insertion when an item is added to the cache.<br>
           If there is no date-time, then the current date-time is taken into account.<br>
           This feature provides a way to verify that an item stored into the cache must be updated or not.<br>
           <br>
           Here is an example using cache engine of QxOrm library (functions into <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Define max cost of cache engine to 500
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>max_cost<span class="operator">(</span><span class="int">500</span><span class="operator">);</span><span class="comment">

// Fetch a list of 'author' from database
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author<span class="operator">&gt; &gt;</span> list_author<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_author<span class="operator">);</span><span class="comment">

// Insert the list of 'author' to the cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">,</span> list_author<span class="operator">);</span><span class="comment">

// Fetch a list of 'blog' from database
</span>QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt;</span> list_blog<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_blog<span class="operator">);</span><span class="comment">

// Insert the list of 'blog' to the cache (cost = 'blog' count)
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">,</span> list_blog<span class="operator">.</span>count<span class="operator">());</span><span class="comment">

// Pointer to an object of type 'comment'
</span>comment_ptr my_comment<span class="operator">;</span>
my_comment<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> comment<span class="operator">(</span><span class="int">50</span><span class="operator">));</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_comment<span class="operator">);</span><span class="comment">

// Insert 'comment' to the cache with a date-time insertion
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span><span class="int"> 1</span><span class="operator">,</span> my_comment<span class="operator">-&gt;</span>dateModif<span class="operator">());</span><span class="comment">

// Get the list of 'blog' stored into the cache
</span>list_blog<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">&lt;</span> QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt; &gt;(</span><span class="string">"list_blog"</span><span class="operator">);</span><span class="comment">

// Get the list of 'blog' without providing the type
</span>qx_bool bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">);</span><span class="comment">

// Remove list of 'author' from cache
</span><span class="type">bool</span> bRemoveOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>remove<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">);</span><span class="comment">

// Get items count stored into the cache
</span><span class="type">long</span> lCount<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>count<span class="operator">();</span><span class="comment">

// Get current cost of items stored into the cache
</span><span class="type">long</span> lCurrentCost<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>current_cost<span class="operator">();</span><span class="comment">

// Verify that an element with the key "comment" exists into the cache
</span><span class="type">bool</span> bExist<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>exist<span class="operator">(</span><span class="string">"comment"</span><span class="operator">);</span><span class="comment">

// Get 'comment' stored into the cache with its date-time insertion
</span>QDateTime dt<span class="operator">;</span>
bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span> dt<span class="operator">);</span><span class="comment">

// Clear the cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_500">Working with several databases</a></p>
         <div class="manual_div_content">
            In the <a href="#manual_310">Connection to database</a> chapter, we have seen how to configure default connection to database using singleton class : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a>.
            QxOrm library is based on Qt <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> engine, so QxOrm uses internally the Qt <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase</a> class.
            All functions to communicate with databases (<a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace, <a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a> class, etc...) have an optional parameter named : <b><i>QSqlDatabase * pDatabase = NULL</i></b> :
            <ul>
               <li>if value of this parameter is NULL (which is the default value) : then QxOrm library uses <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a> settings to connect to database (support multi-threading) ;</li>
               <li>if value is not NULL : then QxOrm library uses connection provided by this <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank"><i>QSqlDatabase * pDatabase</i></a> pointer.</li>
            </ul>
            So this optional parameter can be used to manage your own connection pool and/or to connect to several databases.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_510">Register an abstract class in QxOrm context</a></p>
         <div class="manual_div_content">
           A C++ abstract class (with at least one pure virtual method) cannot be mapped to a database table (because it cannot be instantiated).<br>
           However, in some cases, it can be interesting to define properties into abstract class used by a persistent object (by inheritance).<br>
           A sample of abstract class registered in QxOrm context is available in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.<br>
           To register an abstract class in QxOrm context, you have to :
           <ul>
           <li>register the class with '<i>void register_class</i>' like any other class ;
           </li><li>use <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> macro just after the class definition.
           </li></ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_520">Register automatically Qt meta-properties (<i>Q_PROPERTY</i> macro)</a></p>
         <div class="manual_div_content">
           All classes inherited from <i>QObject</i> type can use <i><a href="http://doc-snapshots.qt.io/4.8/properties.html" target="_blank">Q_PROPERTY</a></i> macro : these properties become meta-properties.
           This is how Qt framework provides an introspection engine using the <i>moc</i> process.
           Meta-properties can be used for example by <i>QML</i> engine, <i>QtScript</i>, etc.<br>
           <br>
           <b>QxOrm</b> library requires to register all properties per class in the <i>void qx::register_class&lt;T&gt;()</i> mapping function to provide all features (persistence, XML, JSON and binary serialization, etc.).
           It's possible to register automatically all Qt meta-properties in QxOrm context without having to manage any mapping function per class <i>void qx::register_class&lt;T&gt;()</i> : <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> macro works with Qt introspection engine to iterate over all meta-properties.<br>
           <br>
           Here is an example with <i>TestQtProperty</i> class in <i>./test/qxDllSample/dll1/include/</i> directory of QxOrm package :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span></font><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
<font style="background-color:yellow">QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></font></pre>
           </td></tr></tbody></table>
           <br>
           If you don't want to use <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro, you can write 4 lines of code :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> <font style="background-color:yellow">qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span></font> <span class="operator">}
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> the second parameter of <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro is the name of the property mapped to the primary key into database.
           If this parameter is empty, then the class doesn't have any primary key or the primary key has been registered in a base class.<br>
           <br>
           All properties defined with <i>Q_PROPERTY</i> macro can be registered in QxOrm context in two different ways :<br>
           <b>1-</b> with the classic method : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> or without writing the data-member pointer : <i>t.data("my_property", 0);</i><br>
           <br>
           You can use the first or the second method to register your properties in QxOrm context and access to the same functionalities using the common interface <i><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i>.
           You can also mix Qt meta-properties and classic registration data-member into the same mapping function <i>void qx::register_class&lt;T&gt;()</i>.
           Each registration method has some advantages and disadvantages.<br>
           <br>
           Here is the list of advantages using the second registration method in QxOrm context :
           <ul>
             <li>much more faster to compile ;</li>
             <li>reduce exec size ;</li>
             <li>strong integration with Qt introspection/<i>moc</i> engine ;</li>
             <li>no need to manage any mapping function per class using <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro.</li>
           </ul>
           Here is the list of disadvantages compared to the classic registration method :
           <ul>
             <li>need to inherit from <i>QObject</i> class to use <i>Q_PROPERTY</i> macro ;</li>
             <li>program execution more slower (<i>QVariant</i> type versus C++ <i>template</i>) ;</li>
             <li>doesn't support relationship between tables into database (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i>) ;</li>
             <li>cannot access to the data-member pointer of a class (need to convert to <i>QVariant</i> type before to access or to modify a value).</li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_60">Serialization</a></p>
      <div class="manual_div_content_1">
         <a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">From Wikipedia web page :</a> <b>serialization</b> is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer, or transmitted across a network connection link) and reconstructed later in the same or another computer environment.
         When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.
         The opposite operation, extracting a data structure from a series of bytes, is named <b>deserialization</b>.
         <br><br>
         Each C++ class registered in QxOrm context can be serialized in several ways :
         <ul>
            <li><a href="#manual_600">binary format of Qt QDataStream engine</a> ;</li>
            <li><a href="#manual_606">JSON format with Qt QJson engine</a> ;</li>
            <li><a href="#manual_610">XML format with boost::serialization engine</a> ;</li>
            <li><a href="#manual_620">binary format with boost::serialization engine</a> ;</li>
            <li><a href="#manual_630">other formats provided by boost::serialization engine</a>.</li>
         </ul>
         <b>Note :</b> serialization engine of QxOrm library provides extra features like : <a href="#manual_640">clone entity</a>, <a href="#manual_650">dump entity</a> (XML or JSON format) and <a href="#manual_80">QxService module</a>.
         <br><br>
         <b>Other note :</b> by default, all properties registered in QxOrm context are serializable. To remove a property from the serialization engine, you can write :<br>
         <br>
         <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setSerialize<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
         </td></tr></tbody></table>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_605">Version number to manage ascendant compatibility</a></p>
         <div class="manual_div_content">
            Ascendant compatibility allows deserialization process (so restore a data structure) from a stream generated by a previous version of an application.
            QxOrm library requires a version number per class and a version number for each property registered in QxOrm context to provide ascendant compatibility.
            <br><br>
            For example, imagine a <i>person</i> class created in <b>a version A of your application</b> : we put in <i>QX_REGISTER_HPP</i> macro a class version equals to 0 (means first version of our <i>person</i> class), and each property class have also a version equals to 0 (0 is the default value, optional parameter).
            So our <i>person</i> class looks like :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">)</span>

<span class="pre">#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>In version B of the application</b>, we modify our <i>person</i> class and we add 2 properties : <i>sex</i> and <i>address</i>.
            Our class has changed, so we have to increment its class version number, and new properties must have a version equals to 1.
            Now, our <i>person</i> class looks like :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>
   <font style="background-color:yellow">QString sex<span class="operator">;</span></font>
   <font style="background-color:yellow">QString address<span class="operator">;</span></font>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 1</font></span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>address<span class="operator">,</span><span class="string"> "address"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> QxOrm library can serialize this <i>person</i> class from application in version A, then deserialize this version A stream to create a cloned instance of <i>person</i> class in version B of our application.
            <br><br>
            <b>Other note :</b> remove a property breaks ascendant compatibility.
            So it is recommended to never remove a property to work with QxOrm serialization engine : it is possible for example to put a <i>private</i> visibility and to delete <i>get/set</i> accessors, so property is hidden and can be considered as obsolete.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_600">Qt QDataStream engine</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be serialized using <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">Qt QDataStream engine</a>.
            Functions to use Qt QDataStream serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_byte_array()</a> : serialize a C++ instance (registered in QxOrm context) to a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_byte_array()</a> : restore a C++ instance based on a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_string()</a> : same serialization as <i>to_byte_array()</i> function + base 64 conversion to <a href="http://doc.qt.io/qt-5/qstring.html" target="_blank">QString</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_string()</a> : restore a C++ instance based on a binary stream converted to base 64 ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file()</a> : binary serialization of a C++ instance (registered in QxOrm context) to a file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file()</a> : restore a C++ instance from a file which contains serialized binary stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file_compressed()</a> : binary serialization of a C++ instance (registered in QxOrm context) to a compressed file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file_compressed()</a> : restore a C++ instance from a compressed file which contains serialized binary stream ;</li>
            </ul>
            <b>Note :</b> <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> serialization is portable (support serialization/deserialization on all environments : Windows, Linux, Mac OS X, etc...).
            The output serialized stream is in binary format : so stream size is smaller than XML or JSON for example.
            <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> serialization is based on introspection engine of QxOrm library, so it is slower than <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine (based on C++ template).
            <br><br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt QDataStream serialization">
<pre><span class="comment">   // Fetch a drug with id '3' in a new variable
   // drug is a C++ class registered in QxOrm context
</span>   drug d<span class="operator">;</span>
   d<span class="operator">.</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span><span class="comment">

   // Serialize the drug to a file
</span>   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>to_file<span class="operator">(</span>d<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Import drug from file in a new instance
</span>   drug d2<span class="operator">;</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>from_file<span class="operator">(</span>d2<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Check if d == d2
</span>   qAssert<span class="operator">(</span>d<span class="operator"> ==</span> d2<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Note :</b> in above example, we serialize a C++ instance.
            All functions in <a href="../doxygen/html/namespaceqx_1_1serialization.html" target="_blank">qx::serialization</a> namespace can serialize list of objects.
            For more details about supported containers, please read this chapter : <a href="#manual_390">Supported containers</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_606">Qt JSON engine</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be serialized to JSON using <a href="http://doc.qt.io/qt-5/json.html" target="_blank">Qt QJson engine</a> (requires Qt5).
            Functions to use Qt JSON serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_string()</a> : serialize a C++ instance (registered in QxOrm context) to JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_string()</a> : restore a C++ instance from a JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file()</a> : JSON serialization of a C++ instance (registered in QxOrm context) to a file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file()</a> : restore a C++ instance from a file which contains serialized JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file_compressed()</a> : JSON serialization of a C++ instance (registered in QxOrm context) to a compressed file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file_compressed()</a> : restore a C++ instance from a compressed file which contains serialized JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_byte_array()</a> : serialize a C++ instance (registered in QxOrm context) to a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_byte_array()</a> : restore a C++ instance based on a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type.</li>
            </ul>
            <b>Note :</b> <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> serialization engine is the most permissive (compared to <a href="#manual_610">XML engine</a> for example) : indeed, properties can be defined in any order, and properties can be removed or added.
            JSON deserialization doesn't generate errors or throw exceptions : the engine ignores invalid or removed properties (but JSON stream must be valid) : so JSON engine is much more flexible than <a href="#manual_610">XML engine</a>.
            <br><br>
            <b>Other note :</b> <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> serialization is based on introspection engine of QxOrm library, so it is slower than <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine (based on C++ template).
            <br><br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">   // Fetch a list of authors from database and serialize them to a JSON file
</span>   list_author list_of_author<span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_of_author<span class="operator">);</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>json<span class="operator">::</span>to_file<span class="operator">(</span>list_of_author<span class="operator">,</span><span class="string"> "list_of_author.json"</span><span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            Above example generates following JSON stream :<br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
{
    "author_id_2": {
        "author_id": "author_id_2",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_2",
        "sex": 1
    },
    "author_id_3": {
        "author_id": "author_id_3",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_3",
        "sex": 1
    }
}
</pre>
            </div>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_610">XML boost serialization</a></p>
         <div class="manual_div_content">
            XML <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine is disabled by default : to enable this feature, it is necessary to define <b>_QX_ENABLE_BOOST_SERIALIZATION</b> and <b>_QX_ENABLE_BOOST_SERIALIZATION_XML</b> compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            It is also required to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary (because this module is not <i>header only</i>), and to set the path to this boost serialization binary to <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> and <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> variables of <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            <br><br>
            Each C++ class registered in QxOrm context can be serialized using <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">XML boost::serialization engine</a>.
            Functions to work with XML boost serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">qx::serialization::xml</a> (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace).
            <br><br>
            XML boost serialization engine is :
            <ul>
               <li><i>portable</i> : support serialization/deserialization on all environments : Windows, Linux, Mac OS X, etc... ;</li>
               <li><i>slowest</i> : slower than <i>binary</i> and <i>text</i> serialization ;</li>
               <li><i>largest</i> : generated stream are bigger than <i>binary</i> and <i>text</i> serialization ;</li>
               <li><i>human-readable</i> : a XML stream can easily be parsed by a text editor and can be read by a human.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_620">Binary boost serialization</a></p>
         <div class="manual_div_content">
            Binary <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine is disabled by default : to enable this feature, it is necessary to define <b>_QX_ENABLE_BOOST_SERIALIZATION</b> and <b>_QX_ENABLE_BOOST_SERIALIZATION_BINARY</b> compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            It is also required to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary (because this module is not <i>header only</i>), and to set the path to this boost serialization binary to <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> and <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> variables of <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            <br><br>
            Each C++ class registered in QxOrm context can be serialized using <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">binary boost::serialization engine</a>.
            Functions to work with binary boost serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">qx::serialization::binary</a> (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace).
            <br><br>
            Binary boost serialization engine is : 
            <ul>
               <li><i>non-portable</i> : an instance serialized on Windows cannot be deserialized on Linux for example : so you have to stay on the same environment ;</li>
               <li><i>fastest</i> : faster than <i>XML</i> and <i>text</i> serialization ;</li>
               <li><i>smallest</i> : generated stream are smaller than <i>XML</i> and <i>text</i> serialization ;</li>
               <li><i>non-human-readable</i> : a binary stream cannot be read (not useful to log for example).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_630">Other boost serialization</a></p>
         <div class="manual_div_content">
            <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine provides several formats to serialize C++ classes.
            All boost serialization process are disabled by default, so to use them (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace), it is necessary to define compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a> :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_POLYMORPHIC :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__binary.html" target="_blank">qx::serialization::polymorphic_binary</a>, <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__xml.html" target="_blank">qx::serialization::polymorphic_xml</a> and <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__text.html" target="_blank">qx::serialization::polymorphic_text</a> namespaces ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_TEXT :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1text.html" target="_blank">qx::serialization::text</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_PORTABLE_BINARY :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1portable__binary.html" target="_blank">qx::serialization::portable_binary</a> namespace (not officially supported by boost library) ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_BINARY :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1binary.html" target="_blank">qx::serialization::wide::binary</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_TEXT :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1text.html" target="_blank">qx::serialization::wide::text</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_XML :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1xml.html" target="_blank">qx::serialization::wide::xml</a> namespace.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_640">Clone a C++ instance</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be cloned using :
            <ul>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>qx_shared_ptr&lt;T&gt;</i> type (by default equals to <i>boost::shared_ptr&lt;T&gt;</i> type, if C++11 enabled then equals to <i>std::shared_ptr&lt;T&gt;</i> type) ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_boost_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>boost::shared_ptr&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_qt_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>QSharedPointer&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_std_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>std::shared_ptr&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_nude_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> in a raw pointer : be careful because you have to free memory (using <i>delete</i>) once you have finished to work with this nude pointer (to avoid memory leak).</li>
            </ul>
            <b>For example :</b>
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone">
<pre>   drug_ptr d1<span class="operator">;</span>
   d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span>
   d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span><span class="comment">

   // Clone a drug
</span>   <font style="background-color:yellow">drug_ptr d_clone<span class="operator"> =</span> qx<span class="operator">::</span>clone<span class="operator">(*</span> d1<span class="operator">);</span></font><span class="comment">

   // Check if (d1 == d_clone)
</span>   qAssert<span class="operator">((*</span> d1<span class="operator">) == (*</span> d_clone<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Important note :</b> be careful when you clone a smart-pointer (<i>boost::shared_ptr</i> or <i>QSharedPointer</i> for example) where the root item can be referenced several times in its hierarchy (tree structure for example).
            In this case, to protect the root pointer of a double deletion (2 smart-pointers which take ownership of the same raw pointer), it is recommended to clone this way :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone smart-pointer">
<pre><span class="comment">// 'pOther' type is boost::shared_ptr&lt;myClass&gt; (smart-pointer)
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt; *</span> pCloneTemp<span class="operator"> =</span> qx<span class="operator">::</span>clone_to_nude_ptr<span class="operator">(</span>pOther<span class="operator">);</span>
boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;</span> pClone<span class="operator"> = (</span>pCloneTemp<span class="operator"> ? (*</span> pCloneTemp<span class="operator">) :</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;());</span><span class="flow">
if</span><span class="operator"> (</span>pCloneTemp<span class="operator">) {</span><span class="keyword"> delete</span> pCloneTemp<span class="operator">;</span> pCloneTemp<span class="operator"> =</span> NULL<span class="operator">; }</span><span class="comment">
// Now use 'pClone' ...</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_650">Dump a C++ instance (XML or JSON format)</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be displayed to <a href="#manual_606">JSON format</a>.
            If <a href="#manual_610">XML boost::serialization engine</a> is enabled, then it is also possible to display a XML dump of a C++ instance (second input parameter of <i>qx::dump</i> function).
            QxOrm dump feature can be useful to debug or to log for example.
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::dump">
<pre>   blog_ptr b<span class="operator">;</span>
   b<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   b<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_all_relation<span class="operator">(</span>b<span class="operator">);</span><span class="comment">

   // Dump 'b' instance result from database (XML or JSON serialization)
   // Second parameter is optional : 'true' = JSON format, 'false' = XML format
</span>   <font style="background-color:yellow">qx<span class="operator">::</span>dump<span class="operator">(</span>b, false<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br>
            Above source code generates output XML :
            <br><br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
[QxOrm] start dump 'boost::shared_ptr&lt;blog&gt;'
&lt;boost.shared_ptr-blog- class_id="0" tracking_level="0" version="1"&gt;
	&lt;px class_id="1" tracking_level="1" version="0" object_id="_0"&gt;
		&lt;blog_id&gt;113&lt;/blog_id&gt;
		&lt;blog_text class_id="2" tracking_level="0" version="0"&gt;update blog_text_1&lt;/blog_text&gt;
		&lt;date_creation class_id="3" tracking_level="0" version="0"&gt;20100409162612000&lt;/date_creation&gt;
		&lt;author_id class_id="4" tracking_level="0" version="1"&gt;
			&lt;px class_id="5" tracking_level="1" version="0" object_id="_1"&gt;
				&lt;author_id&gt;author_id_2&lt;/author_id&gt;
				&lt;name&gt;author_2&lt;/name&gt;
				&lt;birthdate class_id="6" tracking_level="0" version="0"&gt;20100409&lt;/birthdate&gt;
				&lt;sex&gt;1&lt;/sex&gt;
				&lt;list_blog class_id="7" tracking_level="0" version="0"&gt;
					&lt;count&gt;0&lt;/count&gt;
					&lt;item_version&gt;1&lt;/item_version&gt;
				&lt;/list_blog&gt;
			&lt;/px&gt;
		&lt;/author_id&gt;
		&lt;list_comment class_id="8" tracking_level="0" version="0"&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="9" tracking_level="0" version="1"&gt;
				&lt;px class_id="10" tracking_level="1" version="0" object_id="_2"&gt;
					&lt;comment_id&gt;209&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_1 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_3"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category class_id="11" tracking_level="0" version="0"&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;px class_id_reference="10" object_id="_4"&gt;
					&lt;comment_id&gt;210&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_2 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_5"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
		&lt;/list_comment&gt;
		&lt;list_category&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="12" tracking_level="0" version="0"&gt;
				&lt;first&gt;355&lt;/first&gt;
				&lt;second class_id="13" tracking_level="0" version="0"&gt;
					&lt;qt_shared_ptr class_id="14" tracking_level="1" version="0" object_id="_6"&gt;
						&lt;category_id&gt;355&lt;/category_id&gt;
						&lt;name&gt;category_1&lt;/name&gt;
						&lt;description&gt;desc_1&lt;/description&gt;
						&lt;list_blog class_id="15" tracking_level="0" version="0"&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;first&gt;357&lt;/first&gt;
				&lt;second&gt;
					&lt;qt_shared_ptr class_id_reference="14" object_id="_7"&gt;
						&lt;category_id&gt;357&lt;/category_id&gt;
						&lt;name&gt;category_3&lt;/name&gt;
						&lt;description&gt;desc_3&lt;/description&gt;
						&lt;list_blog&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
		&lt;/list_category&gt;
	&lt;/px&gt;
&lt;/boost.shared_ptr-blog-&gt;
[QxOrm] end dump 'boost::shared_ptr&lt;blog&gt;'
</pre>
            </div>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_70">Introspection - Reflection</a></p>
      <div class="manual_div_content_1">
           All C++ classes registered in QxOrm context (with <i>qx::register_class&lt;T&gt;()</i> function) can be used by introspection engine (or reflection engine) of QxOrm library.
           Introspection engine provides dynamically (so during program execution) some information about types.
           These information are called <i>meta-datas</i> and list some classes characteristics (properties, methods, etc.).
           Many programming languages (for example Java or C#) have natively this mechanism, but not C++, that's why QxOrm library emulates an introspection engine.
           For more details about introspection (or reflection), please <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" target="_blank">read the Wikipedia web page</a>.
           <br><br>
           Here is a list of QxOrm library classes to register/access to <i>meta-datas</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton class to iterate over all classes registered in QxOrm context (with <i>qx::register_class&lt;T&gt;()</i> function) ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface for a class registered in QxOrm context ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : list of properties associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface for a class property ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : list of methods associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface for a class method.</li>
           </ul>
           A <a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank"><i>qx::IxClass</i></a> instance contains the list of class properties (<a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank"><i>qx::IxDataMemberX</i></a>) and the list of class methods (<a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank"><i>qx::IxFunctionX</i></a>).<br>
           <br>
           Introspection engine of QxOrm library provides :
           <ul>
             <li><a href="#manual_740">create dynamically an instance of a class using class name as string format (<i>qx::create()</i>)</a> ;</li>
             <li><a href="#manual_710">access/modify dynamically the value of an object field</a> (<i>qx::IxDataMember::getValue()</i> and <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li><a href="#manual_730">invoke dynamically a class method (<i>qx::IxFunction::invoke()</i>)</a> ;</li>
             <li><a href="#manual_750">access to the class hierarchy (for example <i>qx::IxClass::getBaseClass()</i>)</a>.</li>
           </ul>
           <br>
           <b>Note :</b> <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module of QxOrm library (<a href="./tutorial_2.html" target="_blank">click here to go to the tutorial</a>) is based on introspection engine to provide an easy and powerful way to create C++ application server calling dynamically services methods (client request) on server side, and creating automatically input/ouput services parameters instances.<br>
           <br>
           <b>Other note :</b> you can add extra information to introspection engine using <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank"><i>property bag</i> pattern</a>.
           Indeed, <i>qx::IxClass</i>, <i>qx::IxDataMember</i> and <i>qx::IxFunction</i> classes contain a list of <i>QVariant</i> items associated to a <i>QString</i> key (read <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank"><i>qx::QxPropertyBag</i> class documentation</a> for more details).
           <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_710">Get a data member value dynamically</a></p>
         <div class="manual_div_content">
            To get dynamically a data member value using introspection engine of QxOrm library, you have to work with <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> base class (interface).
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class provides several methods to get a data member value (each method has a generic pointer <i>void *</i> as parameter which is the address of the current instance) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">toVariant()</a> : returns data member value converted to <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> type ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValue&lt;T&gt;()</a> : returns data member value in its real type (template T) ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValueAnyPtr()</a> : returns data member value encapsulated in <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any</a> type (possibility to cast using <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any_cast</a> function).</li>
            </ul>
            <b>For example :</b> we have a generic pointer <i>void *</i> to a <i>person</i> class.
            We can get the <i>QString</i> value of <i>firstName</i> property writing :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to get the data member value with the real type
</span>QString sFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">);</span><span class="comment">

// Second method to get the data member value converted in QVariant
</span>QVariant vFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>toVariant<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Third method to get the value encapsulated in boost::any type
</span>boost<span class="operator">::</span>any aFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValueAnyPtr<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Check if all values are equals
</span>qAssert<span class="operator">((</span>sFirstName<span class="operator"> ==</span> vFirstName<span class="operator">.</span>toString<span class="operator">()) &amp;&amp; (</span>sFirstName<span class="operator"> == (*</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span>QString<span class="operator"> *&gt;(</span>aFirstName<span class="operator">))));</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_720">Set a data member value dynamically</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> base class (interface) is able to set dynamically a new value to a property class (modify its value).
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class provides 2 methods (each method has a generic pointer <i>void *</i> as parameter which is the address of the current instance, and the new value to change) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">fromVariant()</a> : set a new data member value based on a <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">setValue&lt;T&gt;()</a> : set a new data member value based on a real type parameter (template T).</li>
            </ul>
            <b>For example :</b> we have a generic pointer <i>void *</i> to a <i>person</i> class.
            We can modify <i>firstName</i> property of <i>QString</i> type writing :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to change the data member value
</span>QVariant vFirstName<span class="operator"> =</span> QVariant<span class="operator">(</span><span class="string">"my new firstname 1"</span><span class="operator">);</span>
pDataMember<span class="operator">-&gt;</span>fromVariant<span class="operator">(</span>p<span class="operator">,</span> vFirstName<span class="operator">);</span><span class="comment">

// Other method to change the data member value (using real type)
</span>QString sFirstName<span class="operator"> =</span><span class="string"> "other firstname 2"</span><span class="operator">;</span>
pDataMember<span class="operator">-&gt;</span>setValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">,</span> sFirstName<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_730">Call function dynamically</a></p>
         <div class="manual_div_content">
            Like data members (class properties), it is possible to register class methods (functions) in QxOrm context (support <i>static</i> and <i>non static</i> methods).
            Introspection engine of QxOrm library can invoke dynamically class methods.
            All functions registered in QxOrm context are associated to a <a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> instance.
            To register a class method in QxOrm context, you have to use these functions :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a> : register a class method without parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a> : register a class method with 1 parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_2()</a> : register a class method with 2 parameters ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_X()</a> : the <i>X</i> suffix means parameters count of a class method ;</li>
               <br>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_0()</a> : register a <i>static</i> class method without parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_1()</a> : register a <i>static</i> class method with 1 parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_2()</a> : register a <i>static</i> class method with 2 parameters ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_X()</a> : the <i>X</i> suffix means parameters count of a <i>static</i> class method ;</li>
            </ul>
            <b>For example :</b> we want to register in QxOrm context several methods of a <i>person</i> class :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span>

   <font style="background-color:yellow"><span class="type">long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="type">void</span> myMethodWith2Params<span class="operator">(</span><span class="type">int</span> param1<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> param2<span class="operator">);</span></font>

   <font style="background-color:yellow"><span class="keyword">static</span><span class="type"> double</span> myStaticMethodWith1Param<span class="operator">(</span><span class="type">long</span> param1<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  <font style="background-color:yellow">t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>getId<span class="operator">,</span><span class="string"> "getId"</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>fct_2<span class="operator">&lt;</span><span class="type">void</span><span class="operator">,</span><span class="type"> int</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;&gt;(&amp;</span> person<span class="operator">::</span>myMethodWith2Params<span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">);</span></font>

  <font style="background-color:yellow">t<span class="operator">.</span>fctStatic_1<span class="operator">&lt;</span><span class="type">double</span><span class="operator">,</span><span class="type"> long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>myStaticMethodWith1Param<span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Once registered in QxOrm context, it is possible to call functions dynamically using <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invoke()</a> and <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invokeStatic()</a> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre>   <span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">   void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

   // Call method 'long getId() const' and get return value
</span>   boost<span class="operator">::</span>any returnValue<span class="operator">;</span>
   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "getId"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> ""</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   long</span> lId<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a string (default separator for parameters is character '|')
   // This way to pass parameters to the function works only if parameters are numeric or string
   // If parameters are more complex, then you have to encapsulate parameters in a list of boost::any, as shown below
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> "36|my string param 2"</span><span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a list of boost::any : std::vector&lt;boost::any&gt;
</span>   std<span class="operator">::</span>vector<span class="operator">&lt;</span>boost<span class="operator">::</span>any<span class="operator">&gt;</span> lstParams<span class="operator">;</span><span class="type">
   int</span> iParam1<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>iParam1<span class="operator">);</span><span class="comment"> // Parameter at position 1
</span>   QString sParam2<span class="operator"> =</span><span class="string"> "my string param 2"</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>sParam2<span class="operator">);</span><span class="comment"> // Parameter at position 2
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span> lstParams<span class="operator">);</span><span class="comment">

   // Call static method 'myStaticMethodWith1Param' with 1 parameter and get return value
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invokeStatic<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">,</span><span class="string"> "19"</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   double</span> dValue<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_740">Create a C++ instance dynamically</a></p>
         <div class="manual_div_content">
            Introspection engine of QxOrm library is able to create class instances dynamically based on class name (<a href="../doxygen/html/group___qx_factory.html" target="_blank">QxFactory module</a>, design pattern factory) using following functions :
            <ul>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type encapsulated in <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any</a> type (which contains a <i>qx_shared_ptr</i> smart-pointer, equals to <i>boost::shared_ptr</i> by default) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_nude_ptr&lt;T&gt;(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type in a nude pointer of <i>T *</i> type (you have to delete yourself this nude pointer to avoid memory leak) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_void_ptr(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type in a nude pointer of <i>void *</i> type (you have to delete yourself this nude pointer to avoid memory leak).</li>
            </ul>
            <b>For example :</b> <a href="#manual_80">QxService module</a> of QxOrm library creates services instances dynamically (based on service name) to execute server routines automatically :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - factory">
<pre>   qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator"> *</span> ptr<span class="operator"> =</span> qx<span class="operator">::</span>create_nude_ptr<span class="operator">&lt;</span>qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">&gt;(</span>m_sServiceName<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_750">Iterate over all classes/properties registered in QxOrm context</a></p>
         <div class="manual_div_content">
           Here is an example based on introspection engine of QxOrm library : <i>how to iterate over all classes, properties and methods registered in QxOrm context ?</i><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           If we execute the <i>qx::QxClassX::dumpAllClasses()</i> function with <a href="./tutorial.html" target="_blank">qxBlog tutorial</a>, here are output logs :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_80">Services : transfer persistent data layer over network (QxService module)</a></p>
      <div class="manual_div_content_1">
         <a href="../doxygen/html/group___qx_service.html" target="_blank"><b>QxService</b></a> module of <b>QxOrm</b> library provides an easy and powerful way to create <b>C++ application server</b> (<i>services</i> with <i>request</i> from client and <i>response</i> from server).
         <font style="background-color:yellow"><b><a href="./tutorial_2.html">A tutorial is available on QxOrm web site</a></b></font> to show how to work with <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a>.
         <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module is based on <a href="#manual_70">introspection engine</a> and <a href="#manual_60">serialization engine</a> of QxOrm library to transfer persistent data layer over network and execute automatically server routines on server side.
         <br><br>
         <b>Note :</b> to enable <b>QxService</b> module, you have to define <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> compilation option in <a href="#manual_220"><i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file</a>.
         This compilation option adds a dependency to QxOrm library : <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> provided by Qt framework.
         <br><br>
         <b>Other note :</b> <b>QxEntityEditor</b> application is deployed with <i>QxEECppServicesExport</i> plugin : this plugin generates automatically all C++ source code to transfer all project entities over network.
         A list of client/server methods are generated automatically (to manage CRUD operations) :
         <ul>
            <li><i>count() :</i> client/server query to count entities (possibility to add a SQL query filter) ;</li>
            <li><i>fetchById() :</i> client/server query to fetch entity properties based on its identifier ;</li>
            <li><i>fetchAll() :</i> client/server query to fetch properties of all entities (mapped to a database table) ;</li>
            <li><i>fetchByQuery() :</i> client/server query to fetch properties of entities filtered by a SQL query ;</li>
            <li><i>insert() :</i> client/server query to insert entity values ;</li>
            <li><i>update() :</i> client/server query to update entity values ;</li>
            <li><i>save() :</i> client/server query to save entity values (insert or update) ;</li>
            <li><i>deleteById() :</i> client/server query to delete an entity based on its identifier ;</li>
            <li><i>deleteAll() :</i> client/server query to delete all entities (mapped to a database table) ;</li>
            <li><i>deleteByQuery() :</i> client/server query to delete entities filtered by a SQL query ;</li>
            <li><i>destroyById() :</i> client/server query to delete an entity based on its identifier (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>destroyAll() :</i> client/server query to delete all entities mapped to a database table (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>destroyByQuery() :</i> client/server query to delete entities filtered by a SQL query (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>executeQuery() :</i> client/server query to execute <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
            <li><i>exist() :</i> client/server query to check if an entity already exists based on its identifier ;</li>
            <li><i>isValid() :</i> client/server query to check entity validity (<a href="#manual_420">QxValidator module</a>).</li>
         </ul>
         It is possible to add and to customize services generated by <b>QxEntityEditor</b> application.
         <br><br>
         The goal of this chapter is to show <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a> concepts :
         <ul>
            <li><a href="#manual_810">Input/output service parameters (request/response)</a> ;</li>
            <li><a href="#manual_820">Define service functions exposed to clients</a> ;</li>
            <li><a href="#manual_825">List of options available on server side</a> ;</li>
            <li><a href="#manual_826">Connection settings on client side</a> ;</li>
            <li><a href="#manual_830">Service authentication</a> ;</li>
            <li><a href="#manual_840">Async client/server queries</a>.</li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_810">Input/output service parameters (request/response)</a></p>
         <div class="manual_div_content">
            Each function exposed by a service has input parameters (request from client) and output parameters (response from server).
            These input/output parameters must inherit from <a href="../doxygen/html/classqx_1_1service_1_1_ix_parameter" target="_blank">qx::service::IxParameter</a> interface and must be registered in QxOrm context (with <i>void qx::register_class&lt;T&gt;</i> function).
            <br><br>
            <b>For example :</b> here is an example of input/output parameters generated by <b>QxEntityEditor</b> application based on <i>blog</i> class of <a href="./tutorial.html" target="_blank">qxBlog tutorial</a> :
            <br><br>
            <i>* blog.services.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_of_blog<span class="operator">;</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>list_of_blog<span class="operator">&gt;</span> list_of_blog_ptr<span class="operator">;</span><span class="comment">

/* -- Service Input Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_input<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_input<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_input<span class="operator">();</span><span class="type">

   long</span> id<span class="operator">;</span><span class="comment">                   //!&lt; Id to fetch or delete
</span>   blog_ptr instance<span class="operator">;</span><span class="comment">         //!&lt; Single instance to fetch, insert, update, delete or validate
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">     //!&lt; List of instances to fetch, insert, update, delete or validate
</span>   qx_query query<span class="operator">;</span><span class="comment">            //!&lt; Query to execute when fetching, updating or deleting
</span>   QStringList columns<span class="operator">;</span><span class="comment">       //!&lt; List of columns to fetch or update
</span>   QStringList relations<span class="operator">;</span><span class="comment">     //!&lt; List of relations to fetch
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt;</span> blog_input_ptr<span class="operator">;</span><span class="comment">

/* -- Service Output Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_output<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_output<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_output<span class="operator">();</span>

   blog_ptr instance<span class="operator">;</span><span class="comment">            //!&lt; Single instance from server
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">        //!&lt; List of instances from server
</span>   QSqlError error<span class="operator">;</span><span class="comment">              //!&lt; If a SQL error occurred, this output parameter is not empty
</span>   qx<span class="operator">::</span>QxInvalidValueX invalid<span class="operator">;</span><span class="comment">  //!&lt; Check if a single instance (or a list of instances) is valid
</span>   qx_query query<span class="operator">;</span><span class="comment">               //!&lt; Query which contains all results
</span><span class="type">   long</span> count<span class="operator">;</span><span class="comment">                   //!&lt; Count how many items in database using a query or not
</span>   qx_bool exist<span class="operator">;</span><span class="comment">                //!&lt; Check if a single instance (or a list of instances) exist in database
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt;</span> blog_output_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_output<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* blog.services.gen.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> services_blog_output<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>columns<span class="operator">,</span><span class="string"> "columns"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>relations<span class="operator">,</span><span class="string"> "relations"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>error<span class="operator">,</span><span class="string"> "error"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>invalid<span class="operator">,</span><span class="string"> "invalid"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>count<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>exist<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> input/output parameters can contain complex structures (containers, smart-pointers, etc...).
            So it is very easy to transfer complex classes (for example with relationships) with <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_820">Define service functions exposed to clients</a></p>
         <div class="manual_div_content">
            Each service registered in <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module exposes a list of functions to clients (client/server queries).
            All services must inherit from <a href="../doxygen/html/classqx_1_1service_1_1_qx_service.html" target="_blank">qx::service::QxService&lt;INPUT, OUTPUT&gt;</a> base class (<i>INPUT</i> and <i>OUTPUT</i> template parameters are explained in chapter : <a href="#manual_810">Input/output service parameters, request/response</a>) and must be registered in QxOrm context (with <i>void qx::register_class&lt;T&gt;</i> function).
            <br><br>
            <b>For example :</b> here is a service example generated by <b>QxEntityEditor</b> application based on <i>blog</i> class of <a href="./tutorial.html" target="_blank">qxBlog tutorial</a> :
            <br><br>
            <i>* blog.services.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="comment">

/* -- Service Definition -- */</span>

<font style="background-color:yellow"><span class="keyword">typedef</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span> blog_input<span class="operator">,</span> blog_output<span class="operator"> &gt;</span> blog_base_class<span class="operator">;</span><span class="keyword">
class</span> QXBLOG_SERVICES_EXPORT blog_services<span class="operator"> :</span><span class="keyword"> public</span> blog_base_class</font><span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_services<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_services<span class="operator">();</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   void</span> fetchById_<span class="operator">();</span><span class="type">
   void</span> fetchAll_<span class="operator">();</span><span class="type">
   void</span> fetchByQuery_<span class="operator">();</span><span class="type">

   void</span> insert_<span class="operator">();</span><span class="type">
   void</span> update_<span class="operator">();</span><span class="type">
   void</span> save_<span class="operator">();</span><span class="type">
   void</span> deleteById_<span class="operator">();</span><span class="type">
   void</span> deleteAll_<span class="operator">();</span><span class="type">
   void</span> deleteByQuery_<span class="operator">();</span><span class="type">
   void</span> destroyById_<span class="operator">();</span><span class="type">
   void</span> destroyAll_<span class="operator">();</span><span class="type">
   void</span> destroyByQuery_<span class="operator">();</span><span class="type">

   void</span> executeQuery_<span class="operator">();</span><span class="type">
   void</span> callQuery_<span class="operator">();</span><span class="type">
   void</span> exist_<span class="operator">();</span><span class="type">
   void</span> count_<span class="operator">();</span><span class="type">
   void</span> isValid_<span class="operator">();</span><span class="pre">

#ifdef _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="keyword">
public</span><span class="operator">:</span>

   blog_ptr fetchById<span class="operator">(</span><span class="type">long</span> id<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchAll<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span>
                                      <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError insert<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError insert<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError deleteById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError deleteAll<span class="operator">();</span>
   QSqlError deleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError destroyAll<span class="operator">();</span>
   QSqlError destroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>

   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError callQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError count<span class="operator">(</span><span class="type">long</span><span class="operator"> &amp;</span> lCount<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">());</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span><span class="pre">

#endif // _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt;</span> blog_services_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_services<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* blog.services.gen.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> services_blog_services<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span>

<font style="background-color:yellow"><span class="keyword">template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchById_<span class="operator">,</span><span class="string"> "fetchById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchAll_<span class="operator">,</span><span class="string"> "fetchAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchByQuery_<span class="operator">,</span><span class="string"> "fetchByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>insert_<span class="operator">,</span><span class="string"> "insert"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>update_<span class="operator">,</span><span class="string"> "update"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>save_<span class="operator">,</span><span class="string"> "save"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteById_<span class="operator">,</span><span class="string"> "deleteById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteAll_<span class="operator">,</span><span class="string"> "deleteAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteByQuery_<span class="operator">,</span><span class="string"> "deleteByQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyById_<span class="operator">,</span><span class="string"> "destroyById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyAll_<span class="operator">,</span><span class="string"> "destroyAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyByQuery_<span class="operator">,</span><span class="string"> "destroyByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>executeQuery_<span class="operator">,</span><span class="string"> "executeQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>callQuery_<span class="operator">,</span><span class="string"> "callQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>exist_<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>count_<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>isValid_<span class="operator">,</span><span class="string"> "isValid"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx

// Then there is the implementation of all functions provided by the service...</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> once registered in QxOrm context, all clients connected to server can call these functions exposed by the service : server routines are executed automatically.
            Data serialization and network layer to transfer persistent classes are managed automatically by <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_825">List of options available on server side</a></p>
         <div class="manual_div_content">
            C++ application server based on <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides several parameters in <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class :
            <ul>
               <li><i>setPort() :</i> listening port number to receive request from client and send response from server ;</li>
               <li><i>setThreadCount() :</i> threads count available on server side to manage several client requests at the same time ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">serialization type</a> used to send response from server to client ;</li>
               <li><i>setCompressData() :</i> define if data sent from server to client are compressed or not ;</li>
               <li><i>setEncryptData() :</i> define if data sent from server to client are encrypted or not (with possibility to configure an encryption key).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_826">Connection settings on client side</a></p>
         <div class="manual_div_content">
            Client layer based on <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides several parameters in <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class :
            <ul>
               <li><i>setIp() :</i> IP address of C++ application server ;</li>
               <li><i>setPort() :</i> port number used by C++ application server ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">serialization type</a> used by client layer to send requests from client to server ;</li>
               <li><i>setCompressData() :</i> define if data sent from client to server are compressed or not ;</li>
               <li><i>setEncryptData() :</i> define if data sent from client to server are encrypted or not (with possibility to configure an encryption key).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_830">Service authentication</a></p>
         <div class="manual_div_content">
            It is often necessary to add a control on server side to check users connected on client side.
            <a href="../doxygen/html/classqx_1_1service_1_1_ix_service.html" target="_blank">qx::service::IxService</a> interface (base class for all services registered in <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module) provides virtual methods which can be overridden to manage authentication :
            <ul>
               <li><i>onBeforeProcess() :</i> virtual method called before server routine execution ;</li>
               <li><i>onAfterProcess() :</i> virtual method called after server routine execution.</li>
            </ul>
            <br>
            <b>For example :</b> here is a class named <i>ParameterAuthentication</i> which can be used as base class for all other parameters, this class provides 3 properties <i>login</i>, <i>password</i> and <i>token</i> :
            <br><br>
            <i>* ParameterAuthentication.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MY_DLL_EXPORT ParameterAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ParameterAuthentication<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ParameterAuthentication<span class="operator">();</span>
 
   QString login<span class="operator">;</span>
   QString password<span class="operator">;</span>
   QString token<span class="operator">;</span><span class="comment">
   // etc..., put here all properties required by the authentication process
</span><span class="operator"> 
};</span><span class="keyword">
 
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt;</span> ParameterAuthentication_ptr<span class="operator">;</span>
 
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> ParameterAuthentication<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* ParameterAuthentication.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> ParameterAuthentication<span class="operator">)</span><span class="keyword">
 
namespace</span> qx<span class="operator"> {</span><span class="keyword">
 
template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>login<span class="operator">,</span><span class="string"> "login"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>password<span class="operator">,</span><span class="string"> "password"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>token<span class="operator">,</span><span class="string"> "token"</span><span class="operator">);
}
 
}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            We have a base class for all parameters (<i>ParameterAuthentication</i>), we will now create a base class for all services named <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i>.
            This service base class will override <i>onBeforeProcess()</i> virtual method to manage authentication before each service routine execution :
            <br><br>
            <i>* ServiceAuthentication.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "ParameterAuthentication.h"
</span><span class="keyword"> 
template</span><span class="operator"> &lt;</span><span class="keyword">class</span> INPUT<span class="operator">,</span><span class="keyword"> class</span> OUTPUT<span class="operator">&gt;</span><span class="keyword">
class</span> ServiceAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ServiceAuthentication<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> sServiceName<span class="operator">) :</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;(</span>sServiceName<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ServiceAuthentication<span class="operator">() { ; }</span>
 
   <font style="background-color:yellow"><span class="keyword">virtual</span><span class="type"> void</span> onBeforeProcess<span class="operator">()</span></font>
   <span class="operator">{</span><span class="comment">
      // Here you can implement your own authentication control (checking login/password for example)
      // You can get input authentication parameters like this :
</span>      ParameterAuthentication_ptr pParams<span class="operator"> =</span> getInputParameter<span class="operator">();</span>
      <i>pParams<span class="operator">-&gt;</span>login<span class="operator">,</span> pParams<span class="operator">-&gt;</span>password<span class="operator">,</span> etc<span class="operator">...</span></i><span class="comment">
 
      // If authentication is not valid, then you can throw an exception (and stop process before executing service function)
</span><span class="flow">      throw</span> qx<span class="operator">::</span>exception<span class="operator">(</span><span class="string">"Authentication error !"</span><span class="operator">);
   }
 
};</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Now we have <i>ParameterAuthentication</i> base class and <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i> base class : all parameters and services must inherit from these classes to manage automatically authentication, and return an error message to client when user settings are not valid.
            <br><br>
            <b>Note :</b> like authentication, it is possible to manage logs on server side using <i>onBeforeProcess()</i> and <i>onAfterProcess()</i> virtual methods.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_840">Async client/server queries</a></p>
         <div class="manual_div_content">
            By default, all client/server queries are synchronous operations : that means that client layer waits for server response to continue its execution.
            With a user interface (<i>GUI</i>), a client/server query locks application (<i>freeze</i>) if it is executed in the main thread : so if server response is not sent quickly, users could think that the application is crashed.
            <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides an easy way to perform asynchronous client/server queries (so without freezing GUI user interface) with <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class.
            <br><br>
            <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class is based on <a href="#manual_70">introspection engine</a> of QxOrm library and <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank">Qt <i>SIGNAL-SLOT</i> feature</a>.
            <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class requires :
            <ul>
               <li>a service instance ;</li>
               <li>input/output service parameters ;</li>
               <li>server routine name to execute (string format) ;</li>
               <li>a callback function called at the end of the transaction (connection to <i>finished()</i> <i>signal</i> event).</li>
            </ul>
            <br>
            Here is an example from <a href="./tutorial_2.html#tuto_302">qxClientServer tutorial</a> which runs a server routine asynchronously :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTimeAsync(), main_dlg::onDateTimeAsyncFinished()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTimeAsync<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDateTimeAsync<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] '%s' transaction is already running"</span><span class="operator">,</span><span class="string"> "server_infos::get_current_date_time"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur (mode asynchrone)
</span>   server_infos_ptr service<span class="operator"> =</span> server_infos_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxClientAsync<span class="operator">());</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pDateTimeAsync<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>finished<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onDateTimeAsyncFinished<span class="operator">()));</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>setService<span class="operator">(</span>service<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">);</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>start<span class="operator">();
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onDateTimeAsyncFinished<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_pDateTimeAsync<span class="operator"> || !</span> m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()) {</span><span class="flow"> return</span><span class="operator">; }</span>
   updateLastTransactionLog<span class="operator">(</span>m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()-&gt;</span>getTransaction<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">();
}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> above example shows how to perform an asynchronous client/server query with these steps :
            <ul>
               <li>create a service instance (of <i>server_infos_ptr</i> type in this example) ;</li>
               <li>create a <i>qx::service::QxClientAsync</i> instance ;</li>
               <li>connect <i>finished</i> event to a callback function (named <i>onDateTimeAsyncFinished()</i> in this example) ;</li>
               <li>pass service instance and service function name to execute to <i>qx::service::QxClientAsync</i> object ;</li>
               <li>run the transaction calling <i>start()</i> method.</li>
            </ul>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_90">Model View engine (QxModelView module)</a></p>
      <div class="manual_div_content_1">
         <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module provides an easy way to work with <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a> with all C++ classes registered in QxOrm context :
         <ul>
           <li><a href="#manual_940">QML</a> : each property defined in QxOrm context is exposed to QML engine : <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module makes easier integration between QML and databases ;</li>
           <li><a href="#manual_950">Qt widgets</a> : <i>QTableView</i> or <i>QListView</i> for example to display/modify a database table content.</li>
         </ul>
         <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides a generic way for all models linked to persistent classes registered in QxOrm context.
         All methods of this class prefixed by '<i>qx</i>' call functions from <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao namespace</a> and then communicate with database.
         <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides also <b>Q_INVOKABLE</b> methods which can be called in <a href="#manual_940">QML</a> files :
         <ul>
            <li><i>qxCount_() :</i> entities count in table mapped to model (possibility to add a SQL query filter) ;</li>
            <li><i>qxFetchById_() :</i> fetch model properties based on its identifier ;</li>
            <li><i>qxFetchAll_() :</i> fetch model with all entities in table mapped to model ;</li>
            <li><i>qxFetchByQuery_() :</i> fetch model with entities in table mapped to model filtered by a SQL query ;</li>
            <li><i>qxFetchRow_() :</i> fetch (update) a model row (each model row provides its own identifier) ;</li>
            <li><i>qxInsert_() :</i> insert all model entities (all model rows) to database ;</li>
            <li><i>qxInsertRow_() :</i> insert a model row to database ;</li>
            <li><i>qxUpdate_() :</i> update all model entities (all model rows) to database ;</li>
            <li><i>qxUpdateRow_() :</i> update a model row to database ;</li>
            <li><i>qxSave_() :</i> save all model entities (all model rows) to database (insert or update) ;</li>
            <li><i>qxSaveRow_() :</i> save a model row to database (insert or update) ;</li>
            <li><i>qxDeleteById_() :</i> delete an entity from database based on the identifier parameter ;</li>
            <li><i>qxDeleteAll_() :</i> delete all entities in table mapped to model ;</li>
            <li><i>qxDeleteByQuery_() :</i> delete entities in table mapped to model based on a SQL query ;</li>
            <li><i>qxDeleteRow_() :</i> delete a model row in database (each model row provides its own identifier) ;</li>
            <li><i>qxDestroyById_() :</i> delete an entity from database based on the identifier parameter (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyAll_() :</i> delete all entities in table mapped to model (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyByQuery_() :</i> delete entities in table mapped to model based on a SQL query (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyRow_() :</i> delete a model row in database (each model row provides its own identifier), support <a href="#manual_3400">soft delete behaviour, logical delete</a> ;</li>
            <li><i>qxExecuteQuery_() :</i> fetch model using <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
            <li><i>qxExist_() :</i> check if an entity already exists based on the identifier parameter ;</li>
            <li><i>qxValidate_() :</i> check validity of all model content (<a href="#manual_420">QxValidator module</a>) ;</li>
            <li><i>qxValidateRow_() :</i> check validity of a model row (<a href="#manual_420">QxValidator module</a>).</li>
         </ul>
         <br/>
         <b>Note :</b> <i>qxBlogModelView</i> sample project in <i>./test/</i> directory of QxOrm package shows how to create quickly a QxOrm model and associate it to the Qt <i>model/view</i> engine (first with <a href="#manual_950">a Qt widget</a>, then with a <a href="#manual_940">QML view</a>).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_910">Simple model (without relationship)</a></p>
         <div class="manual_div_content">
            All classes registered in QxOrm context can be used as a model to display/modify values in views.
            <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> QxOrm model base class inherits from Qt <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a> base class : so QxOrm models are full compatible with <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a>.
            <br/><br/>
            Only 1 line in C++ source code to instantiate a QxOrm model :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <font style="background-color:yellow">qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>MyClass<span class="operator">&gt;();</span></font>   </pre>
            </td></tr></tbody></table>
            <br/>
            <b>Note :</b> the QxOrm model created with this line of code exposes automatically all properties registered in QxOrm context to Qt <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">model/view</a> engine.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_920">Model with relationships (nested models)</a></p>
         <div class="manual_div_content">
            Associate class relationships (<i>1-n</i>, <i>n-1</i> and <i>n-n</i>) to Qt model/view engine is complex : the solution provided by QxOrm library is based on <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">nested models</a> concept.
            For more details about nested models concept, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">a french tutorial is available on famous developpez.com forum</a>.
            <br/><br/>
            To use relationships (<i>1-n</i>, <i>n-1</i> and <i>n-n</i>) with <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView module</a>, it is very important to understand that there is <b>a hierarchy between models</b> (a parent model can be associated to several child models, this is the <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">nested models</a> concept).
            <br/><br/>
            To be able to work with relationships (nested models), it is necessary to create derived classes based on <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> base class.
            This way, all simple properties (not relationship) are automatically exposed to views (thanks to the base class), the only thing to do is to write accessors to manage relationships.
            <b>QxEntityEditor</b> application is deployed with <i>QxEECppModelViewExport</i> plugin : <b>this plugin generates source code automatically to work with nested models</b>.
            <br/><br/>
            Here is a source code example generated by <b>QxEntityEditor</b> application to create a QxOrm model based on <i>blog</i> class (read <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> for more details).
            <i>blog</i> class defines 3 relationships : <i>author (n-1)</i>, <i>list_of_comment (1-n)</i> and <i>list_of_category (n-n)</i> :
            <br/><br/>
            <i>* blog.model_view.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span><span class="keyword">

typedef</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_model_base_class<span class="operator">;</span><span class="keyword">

class</span> QXBLOG_MODEL_VIEW_EXPORT blog_model<span class="operator"> :</span><span class="keyword"> public</span> blog_model_base_class<span class="operator">
{</span>

   Q_OBJECT<span class="keyword">

public</span><span class="operator">:</span>

   blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="operator"> =</span><span class="int"> 0</span><span class="operator">);</span>
   blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">);</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_model<span class="operator">();</span>

   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>

   <span class="comment">/* List of properties exposed by the model (3) :
      - blog_id
      - title
      - text
   */</span><span class="keyword">

protected</span><span class="operator">:</span><span class="keyword">

   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="keyword">
   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="operator">

};

}</span><span class="comment"> // namespace model_view</span></pre>
            </td></tr></tbody></table>
            <br/>
            <i>* blog.model_view.gen.cpp file :</i><br>
            <div style="width:1000px; height:300px; overflow:auto; background-color:white;">
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="comment"> /* = 0 */</span><span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>other<span class="operator">,</span> parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::~</span>blog_model<span class="operator">() { ; }</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "author"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_author value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getauthor<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getauthor<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>author_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_comment"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_comment value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_comment<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_comment<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>comment_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_category"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_category value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_category<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_category<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>category_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span>
   Q_UNUSED<span class="operator">(</span>relation<span class="operator">);</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pNestedModel<span class="operator"> =</span> NULL<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span><span class="flow"> return</span><span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_author value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_comment value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_category value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lstChild<span class="operator">.</span>count<span class="operator">() &lt;=</span><span class="int"> 0</span><span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="flow">
   for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
   {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>syncNestedModel<span class="operator">(</span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(</span>l<span class="operator">),</span> relation<span class="operator">); }
}

}</span><span class="comment"> // namespace model_view</span></pre>
            </div>
            <br/><br/>
            <b>Note :</b> above example shows that the source code required to work with nested models is verbose.
            <b>So to be able to work with models and relationships, it is strongly recommended to use QxEntityEditor application to generate all C++ source code automatically.</b>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_940">Interaction with QML views</a></p>
         <div class="manual_div_content">
           Here is an example in QML (with Qt5, <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module supports Qt4 too).
           This example uses '<i>author</i>' table defined in <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> (source code of this QML example is available in <i>qxBlogModelView</i> project sample of QxOrm package) :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QML view and display it
</span>QQuickView qmlView<span class="operator">;</span>
qmlView<span class="operator">.</span>rootContext<span class="operator">()-&gt;</span>setContextProperty<span class="operator">(</span><span class="string">"myModel"</span><span class="operator">,</span> pModel<span class="operator">);</span>
qmlView<span class="operator">.</span>setSource<span class="operator">(</span>QUrl<span class="operator">(</span><span class="string">"qrc:/documents/main.qml"</span><span class="operator">));</span>
qmlView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           Here is the '<i>main.qml</i>' file content :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>import QtQuick<span class="float"> 2.1</span>
import QtQuick<span class="operator">.</span>Controls<span class="float"> 1.0</span>

Item<span class="operator"> {</span>
   width<span class="operator">:</span><span class="int"> 400</span>
   height<span class="operator">:</span><span class="int"> 300</span>
   Row<span class="operator"> {</span>
      height<span class="operator">:</span><span class="int"> 20</span>
      spacing<span class="operator">:</span><span class="int"> 20</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Clear"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>clear<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Fetch All"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxFetchAll_<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Save"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxSave_<span class="operator">()
      }
   }</span>
   ListView<span class="operator"> {</span>
      y<span class="operator">:</span><span class="int"> 30</span>
      height<span class="operator">:</span><span class="int"> 270</span>
      model<span class="operator">:</span> myModel
      delegate<span class="operator">:</span> Row<span class="operator"> {</span>
         height<span class="operator">:</span><span class="int"> 20</span>
         spacing<span class="operator">:</span><span class="int"> 10</span>
         Text<span class="operator"> {</span> text<span class="operator">:</span><span class="string"> "id: "</span><span class="operator"> +</span> author_id<span class="operator"> }</span>
         TextField<span class="operator"> {</span>
            text<span class="operator">:</span> name
            onTextChanged<span class="operator">:</span> name<span class="operator"> =</span> text<span class="operator">
         }
      }
   }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           After executing this code, following window should be displayed :<br/>
           <br/>
           <img alt="qx_model_view_02" src="./resource/qx_model_view_02.png" border="0" /><br/>
           <br/>
           <b>Note :</b> as you can see in the '<i>main.qml</i>' file, '<i>author_id</i>' and '<i>name</i>' properties of '<i>author</i>' model (<i>myModel</i> variable) can be automatically read and write (because they are registered in QxOrm context).<br/>
           Moreover, <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides a list of methods for QML side (<i>Q_INVOKABLE</i>) to communicate with database : for example, the '<i>Save</i>' button will save the model in database without having to write a C++ function.<br/>
           <br/>
           <b>Other note :</b> <a href="#manual_920">a <b>QxEntityEditor</b> plugin generates automatically source code to manage relationships using nested models concept</a> (for more details about nested models concept, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">please read this french tutorial on famous developpez.com web site</a>).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_950">Interaction with QtWidget views</a></p>
         <div class="manual_div_content">
           Here is an example to display/modify data from '<i>author</i>' table (read <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> for '<i>author</i>' class definition) in a <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a> (source code of this example is available in <i>qxBlogModelView</i> project sample of QxOrm package) :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QTableView and display it
</span>QTableView tableView<span class="operator">;</span>
tableView<span class="operator">.</span>setModel<span class="operator">(</span>pModel<span class="operator">);</span>
tableView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           After executing this code, following window should be displayed :<br/>
           <br/>
           <img alt="qx_model_view_01" src="./resource/qx_model_view_01.png" border="0" /><br/>
           <br/>
           <b>Note :</b> Qt provides several <i>QtWidget</i> views which can be mapped to a model, for example : <a href="http://doc.qt.io/qt-5/qlistview.html" target="_blank">QListView</a>, <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a>, <a href="http://doc.qt.io/qt-5/qtreeview.html" target="_blank">QTreeView</a>.
           It is also possible to use <a href="http://doc.qt.io/qt-4.8/qdatawidgetmapper.html" target="_blank">QDataWidgetMapper</a> class to create your own form based on a model (<a href="http://qt-quarterly.developpez.com/qq-21/widget-correspondance-donnees/" target="_blank">a french tutorial is available on developpez.com web site</a>).
           <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_960">Connect model to QxService module</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a> module provides <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> class template (which inherits from : <a href="../doxygen/html/classqx_1_1_qx_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> &gt;&gt; <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> &gt;&gt; <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a>).
            This class has 2 template parameters :
            <ul>
               <li><i>T</i> : class registered in QxOrm context with all properties exposed to <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a> ;</li>
               <li><i>S</i> : service class of <a href="#manual_80">QxService module</a> to access/modify data from model (client/server requests).</li>
            </ul>
            Data provided by this model comes from client/server requests thanks to <a href="#manual_80">QxService module</a> (so data are not received from a database SQL query).
            The <i>S</i> service class must provide some methods :
            <ul>
               <li><i>count() :</i> client/server request to count entities in table mapped to model (with possibility to add a SQL query filter) ;</li>
               <li><i>fetchById() :</i> client/server request to fetch model properties based on identifier parameter ;</li>
               <li><i>fetchAll() :</i> client/server request to fetch model with all entities in table mapped to model ;</li>
               <li><i>fetchByQuery() :</i> client/server request to fetch model with entities in table mapped to model filtered by a SQL query ;</li>
               <li><i>insert() :</i> client/server request to insert model data to database ;</li>
               <li><i>update() :</i> client/server request to update model data to database ;</li>
               <li><i>save() :</i> client/server request to save model data to database (insert or update) ;</li>
               <li><i>deleteById() :</i> client/server request to delete an entity based on identifier parameter ;</li>
               <li><i>deleteAll() :</i> client/server request to delete all entities in table mapped to model ;</li>
               <li><i>deleteByQuery() :</i> client/server request to delete entities in table mapped to model based on a SQL query ;</li>
               <li><i>destroyById() :</i> client/server request to delete an entity based on identifier parameter (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>destroyAll() :</i> client/server request to delete all entities in table mapped to model (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>destroyByQuery() :</i> client/server request to delete entities in table mapped to model based on a SQL query (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>executeQuery() :</i> client/server request to execute <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
               <li><i>exist() :</i> client/server request to check if model exists based on its identifier ;</li>
               <li><i>isValid() :</i> client/server request to check model validity (<a href="#manual_420">QxValidator module</a>).</li>
            </ul>
            <br/>
            <b>Note :</b> <b>QxEntityEditor</b> application is deployed with <i>QxEECppServicesExport</i> and <i>QxEECppModelViewExport</i> plugins : these plugins generate automatically all C++ source code required to work with QxOrm models and the <a href="#manual_80">QxService module</a>.
            <b>So to use <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> class, it is strongly recommended to use QxEntityEditor application to generate source code automatically.</b>
            <br/><br/>
         </div>
      </div>

      </div>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2017 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
