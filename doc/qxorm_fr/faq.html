<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Accueil</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Téléchargement</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Exemple rapide</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutoriel (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manuel (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">Manuel QxOrm</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">Manuel QxEntityEditor</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Nos clients</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Faq</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Version courante :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.4.4 - <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.2</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/faq.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/faq.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
        <table border="0" style="width: 100%" align="center">
          <col><col>
          <tbody>
            <tr>
              <td><ul><li><a href="#faq_10">Qu'est-ce que QxOrm ?</a><br>
                </li><li><a href="#faq_15">Qu'est-ce que QxEntityEditor ?</a><br>
                </li><li><a href="#faq_20">Comment contacter QxOrm pour indiquer un bug ou poser une question ?</a><br>
                </li><li><a href="#faq_30">Comment installer et compiler QxOrm ?</a><br>
                </li><li><a href="#faq_40">Quelles sont les bases de données prises en compte par QxOrm ?</a><br>
                </li><li><a href="#faq_50">Pourquoi QxOrm est dépendant de deux bibliothèques : boost et Qt ?</a><br>
                </li><li><a href="#faq_60">Pourquoi QxOrm nécessite un en-tête précompilé (precompiled header) pour pouvoir être utilisé ?</a><br>
                </li><li><a href="#faq_70">Est-il possible d'accélérer les temps de compilation d'un projet ?</a><br>
                </li><li><a href="#faq_75">Quels sont les différents types de <i>serialization</i> disponibles ?</a><br>
                </li><li><a href="#faq_80">Pourquoi QxOrm fournit un nouveau type de container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</a><br>
                </li><li><a href="#faq_81">Pourquoi QxOrm fournit un nouveau type de pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> ?</a><br>
                </li><li><a href="#faq_90">Faut-il utiliser <i>QString</i> ou <i>std::string</i> ?</a><br>
                </li><li><a href="#faq_95">Faut-il utiliser les pointeurs intelligents <i>smart-pointer</i> ?</a><br>
                </li><li><a href="#faq_100">La clé primaire est de type <i>long</i> par défaut. Est-il possible d'utiliser une clé de type <i>QString</i> ou autre ?</a><br>
                </li><li><a href="#faq_101">Comment définir une clé primaire sur plusieurs colonnes (<i>composite key</i>) ?</a><br>
                </li><li><a href="#faq_105">Comment enregistrer des membres <i>private</i> ou <i>protected</i> dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_110">Comment activer/désactiver le module <i>QxMemLeak</i> pour la détection automatique des fuites mémoires ?</a><br>
                </li><li><a href="#faq_120">Comment gérer la notion d'héritage avec la base de données ?</a><br>
                </li><li><a href="#faq_130">Comment utiliser les <i>Trigger</i> ?</a><br>
                </li><li><a href="#faq_140">Comment déclarer une classe abstraite dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_150">Comment déclarer une classe définie dans un espace de nom (<i>namespace</i>) dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_160">Comment utiliser le mécanisme de suppression logique (<i>soft delete</i>) ?</a><br>
                </li><li><a href="#faq_170">Comment utiliser les sessions (classe <i>qx::QxSession</i>) pour simplifier la gestion des transactions des bases de données (C++ RAII) ?</a><br>
                </li><li><a href="#faq_180">Comment persister un type dont on ne possède pas le code source (classe provenant d'une bibliothèque tierce par exemple) ?</a><br>
                </li><li><a href="#faq_190">Comment utiliser le moteur d'introspection (ou réflexion) de la bibliothèque QxOrm ?</a><br>
                </li><li><a href="#faq_200">Comment déclarer automatiquement les méta-propriétés de Qt (définies par la macro <i>Q_PROPERTY</i>) dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_210">Comment construire une requête pour interroger la base de données sans écrire de SQL avec la classe <i>qx::QxSqlQuery</i> ?</a><br>
                </li><li><a href="#faq_220">Comment utiliser le cache (fonctions du namespace <i>qx::cache</i>) pour stocker tous types de données ?</a><br>
                </li><li><a href="#faq_230">Comment générer le schéma SQL (création et mise à jour des tables) en fonction des classes persistantes C++ définies dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_240">Comment associer un type SQL à une classe C++ ?</a><br>
                </li><li><a href="#faq_250">Comment utiliser le module <i>QxValidator</i> pour valider automatiquement les données ?</a><br>
                </li><li><a href="#faq_260">Comment utiliser l'interface <i>qx::IxPersistable</i> ?</a><br>
                </li><li><a href="#faq_270">Comment utiliser le moteur de relations pour récupérer des données associées à plusieurs tables ?</a><br>
                </li><li><a href="#faq_280">Comment appeler une procédure stockée ou une requête SQL personnalisée ?</a><br>
                </li><li><a href="#faq_290">Comment utiliser la classe <i>qx::QxDaoAsync</i> pour appeler des requêtes de manière asynchrone (multi-thread) ?</a><br>
                </li><li><a href="#faq_300">Comment utiliser le module <i>QxModelView</i> pour travailler avec le moteur <i>model/view</i> de Qt (Qt widgets et vues QML) ?</a><br>
                </li></ul>
              </td>
              <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                 <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
              </td>
            </tr>
          </tbody>
        </table>
      <br>
      <a name="faq_10"><u><b>Qu'est-ce que QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
              <b>QxOrm est une bibliothèque C++ open source de gestion de données (Object Relational Mapping, ORM).</b><br>
              <b>QxOrm</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
              <br>
              À partir d'une simple <i>fonction de paramétrage</i> (que l'on peut comparer avec un fichier de mapping XML <i>Hibernate</i>), vous aurez accès aux fonctionnalités suivantes :
              <ul>
                <li><font style="background-color:yellow"><b>persistance</b></font> : communication avec de nombreuses bases de données (avec support des relations <i>1-1</i>, <i>1-n</i>, <i>n-1</i> et <i>n-n</i>) ;
                </li><li><font style="background-color:yellow"><b>sérialisation</b></font> des données (flux binaire, XML et JSON) ;
                </li><li>moteur de <font style="background-color:yellow"><b>réflexion</b></font> (ou <font style="background-color:yellow"><b>introspection</b></font>) pour accéder aux classes, attributs et invoquer des méthodes.
                </li>
              </ul>
              <b>QxOrm</b> est dépendant des excellentes bibliothèques <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (compatible à partir de la version 1.38) et <a href="http://www.qt.io/" target="_blank"><b>Qt</b></a> (compatible à partir de la version 4.5.0).<br>
              La bibliothèque <b>QxOrm</b> a été retenue pour faire partie du programme <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank"><b>Qt Ambassador</b></a>.
              <br><br>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_15"><u><b>Qu'est-ce que QxEntityEditor ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
              <b>QxEntityEditor</b> est un éditeur graphique pour la bibliothèque <b>QxOrm</b> : <b>QxEntityEditor</b> permet de gérer graphiquement le modèle d'entités.<br>
              <b>QxEntityEditor</b> est multi-plateforme (disponible pour Windows, Linux et Mac OS X) et génère du code natif pour tous les environnements : bureau (Windows, Linux, Mac OS X), embarqué et mobile (Android, iOS, Windows Phone, Raspberry Pi, etc.).<br>
              <a href="./tutorial_4.html">Une vidéo de présentation de l'application <b>QxEntityEditor</b> est disponible</a>.<br>
              <br>
              <b>QxEntityEditor</b> est basé sur un système de plugins et propose diverses fonctionnalités pour importer/exporter le modèle de données :
              <ul>
                <li>génération automatique du code C++ (classes persistantes enregistrées dans le contexte QxOrm) ;</li>
                <li>génération automatique des scripts SQL DDL (schéma de base de données) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
                <li>supporte l'évolution du schéma de base de données pour chaque version d'un projet (<i>ALTER TABLE</i>, <i>ADD COLUMN</i>, <i>DROP INDEX</i>, etc.) ;</li>
                <li>génération automatique des classes C++ de services pour transférer le modèle de données sur le réseau, en utilisant le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>, pour créer rapidement des applications client/serveur ;</li>
                <li>importation automatique des structures de bases de données existantes (par connexion ODBC) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
                <li>parce que chaque projet est différent, QxEntityEditor propose plusieurs outils pour personnaliser les fichiers générés (notamment un moteur javascript et un débogueur intégré).</li>
              </ul>
              <a href="../qxentityeditor/resource/qxee_sample.png" target="_blank"><img alt="QxEntityEditor" src="../qxentityeditor/resource/qxee_sample_small.png" border="0" class="img_with_shadow"></a>
              <br><br>
              <b>QxEntityEditor</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
              <br><br>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_20"><u><b>Comment contacter QxOrm pour indiquer un bug ou poser une question ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Si vous trouvez un bug ou si vous avez une question concernant le fonctionnement de la bibliothèque <b>QxOrm</b>, 
           vous pouvez envoyer un mail à : <u><i>support@qxorm.com</i></u>.<br>
           Un forum (en anglais) dédié à <b>QxOrm</b> est disponible <a href="http://www.qxorm.com/forum/phpbb/" target="_blank">en cliquant ici</a>.<br>
           Vous pouvez également retrouver la communauté française de <b>QxOrm</b> sur <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/bases-donnees/qxorm/" target="_blank">le forum de Developpez.com</a>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_30"><u><b>Comment installer et compiler QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <a href="./tutorial_3.html">Un tutoriel pour installer un environnement de développement avec QxOrm sous Windows est disponible en cliquant ici.</a><br/>
           <br/>
           <b>QxOrm</b> utilise le processus <i>qmake</i> de la bibliothèque <b>Qt</b> pour générer les <i>makefile</i> et compiler le projet.<br>
           <i>qmake</i> est multiplateforme et fonctionne parfaitement sous Windows, Linux (Unix) et Mac.<br>
           Pour compiler <b>QxOrm</b>, il suffit d'exécuter les commandes suivantes :<br>
           <br>
           <i>qmake</i><br>
           <i>make debug</i><br>
           <i>make release</i><br>
           <br>
           Sous <b>Windows</b>, des fichiers <i>*.vcproj</i> et <i>*.sln</i> sont disponibles pour les éditeurs <b>Visual C++ 2008</b>, <b>Visual C++ 2010</b> et <b>Visual C++ 2012</b>.<br>
           Les fichiers <i>*.pro</i> sont lisibles par l'éditeur <b>Qt Creator</b>, et des plugins existent permettant de s'interfacer avec de nombreux éditeurs C++.<br>
           Les fichiers <i>mingw_build_all_debug.bat</i> et <i>mingw_build_all_release.bat</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec le compilateur <b>MinGW</b> sous Windows.<br>
           Les fichiers <i>gcc_build_all_debug.sh</i> et <i>gcc_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec <b>GCC</b> sous <b>Linux</b>.<br>
           Enfin, les fichiers <i>osx_build_all_debug.sh</i> et <i>osx_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests sous <b>Mac</b> (merci à Dominique Billet pour l'écriture des scripts).<br>
           <br>
           <b>Remarque :</b> suivant l'environnement de développement, il peut être nécessaire de modifier le fichier <u><b>QxOrm.pri</b></u> pour paramétrer la configuration de la bibliothèque <b>boost</b> :<br>
           <br>
           <i>QX_BOOST_INCLUDE_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/include)<br>
           QX_BOOST_LIB_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/lib_shared)<br>
           QX_BOOST_LIB_SERIALIZATION_DEBUG = "boost_serialization-vc90-mt-gd-1_42"<br>
           QX_BOOST_LIB_SERIALIZATION_RELEASE = "boost_serialization-vc90-mt-1_42"<br></i>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_40"><u><b>Quelles sont les bases de données prises en compte par QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise le moteur <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> de <b>Qt</b> basé sur un système de plugin.<br>
           Une liste détaillée des bases de données supportées est disponible sur le site de Qt <a href="http://doc.qt.io/qt-5/sql-driver.html" target="_blank">en cliquant ici</a>.<br>
           Le plugin <i>ODBC</i> (<i>QODBC</i>) assure une compatibilité avec de nombreuses bases de données.<br>
           Pour des performances optimales, il est conseillé d'utiliser un plugin spécifique à une base de données :
           <ul><li><i>QMYSQL</i> : MySQL ;
           </li><li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;
           </li><li><i>QOCI</i> : Oracle Call Interface Driver ;
           </li><li><i>QSQLITE</i> : SQLite version 3 ;
           </li><li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;
           </li><li><i>QIBASE</i> : Borland InterBase ;
           </li><li><i>QTDS</i> : Sybase Adaptive Server.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_50"><u><b>Pourquoi QxOrm est dépendant de deux bibliothèques : boost et Qt ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise de nombreuses fonctionnalités disponibles dans les excellentes bibliothèques <b>boost</b> et <b>Qt</b>.<br>
           De plus, ces deux bibliothèques sont utilisées dans de nombreux projets à la fois professionnels et open-source.<br>
           Il existe un grand nombre de forums, de tutoriaux, et toute une communauté pour répondre à toutes les problématiques que vous pourriez rencontrer.<br>
           L'objectif de <b>QxOrm</b> n'est pas de redévelopper des fonctionnalités qui existent déjà mais de fournir un outil performant d'accès aux bases de données 
           comme il en existe dans d'autres langages (<i>Java</i> avec <i>Hibernate</i>, <i>.Net</i> avec <i>NHibernate</i>, <i>Ruby</i>, <i>Python</i>, etc.).<br><br>
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.qt.io/" target="_blank"><img alt="Qt"
                   src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : bibliothèque complète : IHM
                   (<i>QtGui</i>), réseau (<i>QtNetwork</i>), XML (<i>QtXml</i>), base de données
                   (<i>QtSql</i>), etc.<br>
                   La documentation est excellente et le code C++ écrit à partir
                   de cette bibliothèque est à la fois performant et simple de
                   compréhension.<br>
                   Depuis le rachat par Nokia puis Digia et sa nouvelle licence LGPL, Qt est
                   sans contexte la bibliothèque phare du moment.<br>
                   QxOrm est compatible avec les principaux objets définis par Qt
                   : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash,
                   QSharedPointer, QScopedPointer, etc.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de Qt disponible à l'adresse suivante : <a
                   href="http://www.qt.io/"
                   target="_blank">http://www.qt.io/</a></td>
               </tr>
             </tbody>
           </table>
           <p></p>
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.boost.org/" target="_blank"><img alt="boost"
                   src="./resource/logo_boost.jpg" width="161"
                 height="50" border="0"></a></td>
                 <td align="justify"><b>boost</b> : de nombreux modules de la
                   bibliothèque boost font partie de la nouvelle norme C++.<br>
                   C'est une bibliothèque reconnue pour sa qualité, son code 'C++
                   moderne', sa documentation, sa portabilité, etc.<br>
                   QxOrm utilise les fonctionnalités suivantes de boost :
                   <i>smart_pointer, serialization, type_traits,
                   multi_index_container, unordered_container, any, tuple,
                   foreach, function.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de boost disponible à l'adresse suivante : <a
                   href="http://www.boost.org/"
                   target="_blank">http://www.boost.org/</a></td>
               </tr>
             </tbody>
           </table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_60"><u><b>Pourquoi QxOrm nécessite un en-tête précompilé (precompiled header) pour pouvoir être utilisé ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise les techniques de <b>métaprogrammation C++</b> pour fournir une grande partie de ses fonctionnalités.<br>
           Vous n'avez pas besoin de savoir utiliser la métaprogrammation pour travailler avec la bibliothèque QxOrm.<br>
           En effet, QxOrm se veut simple d'utilisation et un code C++ écrit avec Qt et QxOrm est facile à lire, donc facile à développer et à maintenir.<br><br>
           Cependant, la métaprogrammation est couteuse en temps de compilation.<br>
           En utilisant un fichier <i>precompiled.h</i>, un projet C++ se compilera beaucoup plus vite.<br>
           Un seul fichier d'en-tête est nécessaire pour disposer de l'ensemble des fonctionnalités de QxOrm : le fichier <i>QxOrm.h</i>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_70"><u><b>Est-il possible d'accélérer les temps de compilation d'un projet ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Oui, si la <i>serialization</i> des données au format XML n'est pas utilisée dans le projet, vous pouvez désactiver cette fonctionnalité.<br>
           Les temps de compilation seront alors réduits mais vous n'aurez plus accès au namespace <i>qx::serialization:xml</i>.<br>
           Pour désactiver la <i>serialization XML</i>, il faut ouvrir le fichier de configuration <i>QxOrm.pri</i> et supprimer (ou mettre en commentaire) l'option de compilation <b><i>_QX_ENABLE_BOOST_SERIALIZATION_XML</i></b>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification.<br>
           <br>
           Une autre possibilité est d'utiliser les classes <i>polymorphiques</i> de la bibliothèque <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank"><i>boost::serialization</i></a> (à la place des classes <i>template</i>).<br>
           Cette fonctionnalité réduit les temps de compilation ainsi que la taille de l'éxecutable généré.<br>
           En contre-partie, la vitesse d'exécution du programme sera réduite puisqu'une partie du travail effectué lors de la compilation devra être réalisé à l'exécution de l'application.<br>
           Pour utiliser cette fonctionnalité dans <b>QxOrm</b>, vous devez activer l'option de compilation <b><i>_QX_ENABLE_BOOST_SERIALIZATION_POLYMORPHIC</i></b> dans le fichier de configuration <i>QxOrm.pri</i>.<br>
           <b>Attention</b> : les fonctions de <i>serialization</i> seront alors accessibles depuis les <i>namespace</i> suivants : <i>qx::serialization::polymorphic_binary</i>, <i>qx::serialization::polymorphic_text</i> et <i>qx::serialization::polymorphic_xml</i>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification.<br>
           <br>
           Enfin, il est également possible d'utiliser la macro <i>Q_PROPERTY</i> pour déclarer les propriétés si la classe hérite du type <i>QObject</i>.<br>
           Dans ce cas, il existe deux manières différentes pour enregistrer les propriétés dans le contexte QxOrm, dont une qui réduit sensiblement les temps de compilation du projet.<br>
           Pour plus d'informations sur cette fonctionnalité, <a href="./faq.html#faq_200">rendez-vous sur cette Question-Réponse de la FAQ</a>.<br>
           <br>
           <b>Remarque :</b> il est également nécessaire de s'assurer que toutes les optimisations proposées par le compilateur sont activées, notamment au niveau de la compilation parallèle sur plusieurs processeurs :
           <ul>
             <li><b>MSVC++</b> : utiliser la variable d'environnement <b>SET CL=/MP</b></li>
             <li><b>GCC</b> et <b>Clang</b> : préciser le nombre de processeurs utilisés en paramètre du process <i>make</i>, par exemple pour 8 coeurs : <b>SET MAKE_COMMAND=make -j8</b></li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_75"><u><b>Quels sont les différents types de <i>serialization</i> disponibles ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise le framework de <i>serialization</i> proposé par la bibliothèque <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost</a>.<br>
           Il existe plusieurs types de serialization disponibles : <i>binaire, XML, JSON, texte, etc.</i><br>
           Le fichier de configuration <i>QxOrm.pri</i> permet d'activer et/ou désactiver les différents types de serialization.<br>
           <br>
           Chaque type de serialization possède ses propres caractéristiques :
           <ul>
             <li><b>binary</b> : <i>smallest, fastest, non-portable</i> ;
             </li><li><b>text</b> : <i>larger, slower, portable</i> ;
             </li><li><b>XML</b> : <i>largest, slowest, portable</i>.
             </li>
           </ul>
           <b>Remarque :</b> le type <b>binary</b> n'est pas portable, ce qui signifie que des données ne peuvent pas s'échanger entre un sytème Windows et un système Unix par exemple.<br>
           Si vous devez faire transiter des données sur un réseau à travers plusieurs systèmes d'exploitation, il faut utiliser le type de serialization <b>text</b> ou <b>XML</b>.<br>
           <b>QxOrm</b> propose également une autre solution : le type de serialization <b><a href="http://epa.codeplex.com/" target="_blank">portable_binary</a></b>.<br>
           Le type <b>portable_binary</b> possède les mêmes caractéristiques que le type <b>binary</b> et permet d'échanger des données de manière portable.<br>
           Cependant, ce type de serialization n'est pas proposé officiellement par la bibliothèque <b>boost</b>, il est donc nécessaire de tester avant de l'utiliser dans un logiciel en production.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_80"><u><b>Pourquoi QxOrm fournit un nouveau type de container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Il existe de nombreux <i>container</i> dans les bibliothèques <b>stl</b>, <b>boost</b> et <b>Qt</b>.<br>
           Il est donc légitime de se poser cette question : à quoi sert <i>qx::QxCollection&lt;Key, Value&gt;</i> ?<br>
           <i><a href="../doxygen/html/classqx_1_1_qx_collection.html" target="_blank">qx::QxCollection&lt;Key, Value&gt;</a></i> est un nouveau <i>container</i> (basé sur l'excellente bibliothèque <a href="http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a>) qui possède les fonctionnalités suivantes :
           <ul><li>conserve l'ordre d'insertion des éléments dans la liste ;
           </li><li>accès rapide à un élément par son index : équivaut à <i>std::vector&lt;T&gt;</i> ou <i>QList&lt;T&gt;</i> par exemple ;
           </li><li>accès rapide à un élément par une clé (<i>hash-map</i>) : équivaut à <i>QHash&lt;Key, Value&gt;</i> ou <i>boost::unordered_map&lt;Key, Value&gt;</i> par exemple ;
           </li><li>fonctions de tri sur le type <i>Key</i> et sur le type <i>Value</i>.
           </li></ul>
           <b>Remarque :</b>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> est compatible avec la macro <i>foreach</i> fournie par la bibliothèque <b>Qt</b> ainsi que par la macro <a href="http://www.boost.org/doc/libs/release/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> fournie par la bibliothèque <b>boost</b>.<br>
           Cependant, chaque élément renvoyé par ces deux macros correspond à un objet de type <i>std::pair&lt;Key, Value&gt;</i>.<br>
           Pour obtenir un résultat 'plus naturel' et plus lisible, il est conseillé d'utiliser la macro <i>_foreach</i> : cette macro utilise <i>BOOST_FOREACH</i> pour tous les <i>container</i> sauf pour <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           Dans ce cas, l'élément renvoyé correspond au type <i>Value</i> (voir par la suite l'exemple d'utilisation).<br>
           La macro <i>_foreach</i> est donc compatible avec tous les <i>container</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>, etc.) puisqu'elle utilise la macro <i>BOOST_FOREACH</i>.<br><br>
           <b>Autre Remarque :</b>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> est particulièrement adapté pour recevoir des données issues d'une base de données.<br>
           En effet, ces données peuvent être triées (en utilisant <i>ORDER BY</i> dans une requête SQL par exemple), il est donc important de conserver l'ordre d'insertion des éléments dans la liste.<br>
           De plus, chaque donnée issue d'une base de données possède un identifiant unique. Il est donc intéressant de pouvoir accéder à un élément en fonction de cet identifiant unique de manière extrèmement rapide (<i>hash-map</i>).<br><br>
           <b>Exemple d'utilisation de la collection <i>qx::QxCollection&lt;Key, Value&gt;</i> :</b><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* définition d'une classe drug avec 3 propriétés : 'code', 'name', 'description' */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* pointeur intelligent associé à la classe drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection de drugs (accès rapide à un élément de la collection par la propriété 'code') */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* création de 3 nouveaux drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insertion des 3 drugs dans la collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* parcours la collection en utilisant le mot-clé '_foreach' */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* parcours la collection en utilisant une boucle 'for' */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* parcours la collection en utilisant le style Java avec 'QxCollectionIterator' */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* effectue un tri croissant par clé (propriété 'code') et décroissant par valeur */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son 'code' */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son index (position) dans la collection */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* teste si un drug existe dans la collection et si la liste est vide */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* supprime de la collection le 2ème élément */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* supprime de la collection l'élément avec le code 'code3' */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* efface tous les éléments de la collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_81"><u><b>Pourquoi QxOrm fournit un nouveau type de pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> est compatible avec les pointeurs intelligents des bibliothèques <b>boost</b> et <b>Qt</b>.<br>
           Le pointeur intelligent développé par <b>QxOrm</b> est basé sur <i>QSharedPointer</i> et apporte de nouvelles fonctionnalités s'il est utilisé avec les fonctions '<i>qx::dao::...</i>'.<br>
           <i><a href="../doxygen/html/classqx_1_1dao_1_1ptr.html" target="_blank">qx::dao::ptr&lt;T&gt;</a></i> conserve automatiquement les valeurs issues de la base de données.<br>
           Il est ainsi possible de vérifier à tout moment si une instance d'objet a subi des modifications grâce à la méthode '<i>isDirty()</i>' : cette méthode peut renvoyer la liste de toutes les propriétés ayant été modifiées.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> peut également être utilisé par la fonction '<i>qx::dao::update_optimized()</i>' pour mettre à jour en base de données uniquement les champs modifiés.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> peut être utilisé avec un objet simple ou bien avec la plupart des containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> et <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           <br>
           <b>Exemple d'utilisation du pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> :</b><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// exemple d'utilisation de la méthode 'isDirty()'
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour uniquement la propriété 'm_text' de l'instance 'blog_isdirty'
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

// exemple d'utilisation de la méthode 'isDirty()' avec une liste d'objets
</span><span class="keyword">typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour la propriété 'm_name' en position 1, la propriété 'm_birthdate' en position 2 et ne change rien en position 0
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

// récupère uniquement la propriété 'm_dt_creation' du blog
</span>QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
{</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_90"><u><b>Faut-il utiliser <i>QString</i> ou <i>std::string</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> conseille d'utiliser la classe <a href="http://doc.qt.io/qt-5/QString.html" target="_blank"><i>QString</i></a> pour la gestion des chaînes de caractères.<br>
           Même si <b>boost</b> fournit de nombreuses fonctionnalités avec son module <a href="http://www.boost.org/doc/libs/release/doc/html/string_algo.html" target="_blank"><i>boost::string_algo</i></a>, 
           la classe <i>QString</i> est plus simple à utiliser et surtout prend en charge automatiquement les différents formats : <i>Ascii, Utf8, Utf16, etc.</i><br>
           Cependant, <b>QxOrm</b> est compatible avec <i>std::string</i> et <i>std::wstring</i> si vous préférez utiliser ce type de chaîne de caractères.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_95"><u><b>Faut-il utiliser les pointeurs intelligents <i>smart-pointer</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> conseille fortement d'utiliser les pointeurs intelligents de <b>boost</b> ou <b>Qt</b>.<br>
           Le langage C++ ne possède pas de <i>Garbage Collector</i> comme <i>Java</i> ou <i>C#</i> par exemple.<br>
           L'utilisation des <i>smart-pointer</i> simplifie énormément la gestion de la mémoire en C++.<br>
           L'idéal dans un programme C++ est de n'avoir aucun appel à <i>delete</i> ou <i>delete[]</i>.<br>
           De plus, les <i>smart-pointer</i> font partie de la nouvelle norme C++ : <b>C++1x</b>.<br>
           Il est donc essentiel aujourd'hui de connaître les classes suivantes :
           <ul><li><a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/smart_ptr.htm" target="_blank"><i>shared_ptr</i>, <i>scoped_ptr</i> et <i>weak_ptr</i></a> pour les pointeurs intelligents de la bibliothèque <b>boost</b> ;
           </li><li><a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer</i>, <i>QScopedPointer</i> et <i>QWeakPointer</i></a> pour les pointeurs intelligents de la bibliothèque <b>Qt</b>.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_100"><u><b>La clé primaire est de type <i>long</i> par défaut. Est-il possible d'utiliser une clé de type <i>QString</i> ou autre ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
            Par défaut, lorsqu'un mapping d'une classe C++ est écrit avec la méthode <i>void qx::register_class&lt;T&gt;</i>, l'identifiant associé à la classe est de type <i>long</i> (clé primaire avec auto-incrémentation dans la base de données).<br>
            <br>
            Il est possible de définir un identifiant d'un autre type en utilisant la macro <b>QX_REGISTER_PRIMARY_KEY</b>.<br>
            Cette macro spécialise le template <i>qx::trait::get_primary_key</i> pour associer un type d'identifiant à une classe C++.<br>
            <br>
            Par exemple, pour définir un identifiant unique de type <i>QString</i> pour la classe C++ <i>myClass</i> (mappée vers une table de la BDD avec une colonne de type <i>VARCHAR</i> pour clé primaire), il suffit d'écrire :<br>
            <i><b>QX_REGISTER_PRIMARY_KEY(myClass, QString)</b></i><br>
            <br>
            Voici un exemple d'utilisation de la macro <b>QX_REGISTER_PRIMARY_KEY</b> avec une classe <i>author</i> possédant un identifiant de type <i>QString</i> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword"> 
class</span> author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- propriétés
</span>   QString  m_id<span class="operator">;</span>
   QString  m_name<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_</span></pre>
            </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_101"><u><b>Comment définir une clé primaire sur plusieurs colonnes (<i>composite key</i>) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> supporte la notion de '<i>multi-columns primary key</i>'.<br>
           L'identifiant de la classe doit être du type suivant :
           <ul>
           <li><i>QPair</i> ou <i>std::pair</i> pour définir deux colonnes ;
           </li><li><i>boost::tuple</i> pour définir de deux à neuf colonnes.
           </li></ul>
           Il est nécessaire d'utiliser la macro <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> pour spécialiser le template et ainsi définir le type d'identifiant sur plusieurs colonnes.<br>
           La liste des noms des colonnes doit être de la forme suivante : '<i>column1|column2|column3|etc.</i>'.<br>
           <br>
           <b>Exemple d'utilisation</b> avec la classe '<i>author</i>' du projet '<i>qxBlogCompositeKey</i>', cette classe possède un identifiant sur trois colonnes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- clé composée (clé primaire définie sur plusieurs colonnes dans la base de données)
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span><span class="keyword">
   static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- propriétés
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- méthodes d'accès à la clé composée
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- méthodes de modification de la clé composée
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_105"><u><b>Comment enregistrer des membres <i>private</i> ou <i>protected</i> dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Pour enregistrer des membres <i>private</i> ou <i>protected</i> dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>), il faut déclarer les <i>friend class</i> nécessaires.<br>
           Pour simplifier l'écriture avec les <i>template</i> C++, la bibliothèque QxOrm fournit la macro suivante : <b>QX_REGISTER_FRIEND_CLASS(myClass)</b>.<br>
           Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll1/</i> du package QxOrm avec la classe <i>CPerson</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> test<span class="operator"> {</span><span class="keyword">

class</span> QX_DLL1_EXPORT CPerson<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>qx<span class="operator">::</span>test<span class="operator">::</span>CPerson<span class="operator">)</span></font><span class="comment">

   // etc...
</span><span class="operator">
};

}</span><span class="comment"> // namespace test
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_110"><u><b>Comment activer/désactiver le module <i>QxMemLeak</i> pour la détection automatique des fuites mémoires ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Le module <i>QxMemLeak</i> permet une détection rapide des fuites
           mémoire en mode <i>Debug</i> une fois l'exécution du programme terminée
           (avec indication du fichier et de la ligne =&gt; style MFC de
           Microsoft).<br>
           Ce module a été développé par <a href="http://wyw.dcweb.cn/leakage.htm" target="_blank">Wu Yongwei</a> et a subi
           quelques modifications pour être intégré dans <b>QxOrm</b>.<br>
           Si un autre outil est déjà utilisé (<i>Valgrind</i> par exemple),
           cette fonctionnalité ne doit pas être activée.<br>
           Pour activer/désactiver le module <i>QxMemLeak</i>, il suffit de modifier la constante 
           <b><i>_QX_USE_MEM_LEAK_DETECTION</i></b> définie dans le fichier <i>QxConfig.h</i>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification. 
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_120"><u><b>Comment gérer la notion d'héritage avec la base de données ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           On retrouve généralement dans les différents outils de type <i>ORM</i> trois différentes stratégies pour gérer la notion d'héritage avec la base de données :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> (une seule table regroupant toutes les propriétés d'une hiérarchie d'héritage de classes) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> (à chaque classe d'une hiérarchie d'héritage est associée une table dans la base de données) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i> (une table par classe concrète dans la hiérarchie d'héritage).
           </li></ul>
           <b>QxOrm</b> utilise par défaut la stratégie <i>Concrete Table Inheritance</i> (les autres stratégies ne sont pas fonctionnelles à l'heure actuelle).<br>
           De nombreux tutoriaux et forums sont disponibles sur internet pour plus de détails sur cette notion d'héritage.<br>
           Un exemple d'utilisation avec une classe de base se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_130"><u><b>Comment utiliser les <i>Trigger</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Les <i>Trigger</i> de <b>QxOrm</b> permettent d'effectuer divers traitements avant et/ou après une insertion, une mise à jour ou bien une suppression dans la base de données.<br>
           Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.<br>
           Cette classe contient cinq propriétés : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> et <i>m_userModification</i>.<br>
           Ces propriétés se mettront à jour automatiquement pour chaque classe héritant de <i>BaseClassTrigger</i> (cf. les classes <i>Foo</i> et <i>Bar</i> du même projet).<br>
           Il est nécessaire de spécialiser le template '<i>QxDao_Trigger</i>' pour profiter de cette fonctionnalité.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">

   void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span><span class="type">
   void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);

};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword">
struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;
{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }
   static inline</span><span class="type"> void</span> onAfterFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_140"><u><b>Comment déclarer une classe abstraite dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Une classe abstraite C++ (contenant au moins une méthode virtuelle pure) ne peut pas être mappée avec une table d'une base de données (puisqu'elle ne peut pas être instanciée).<br>
           Cependant, il peut être intéressant de définir une classe abstraite contenant une liste de propriétés utilisées par plusieurs objets persistants.<br>
           Un exemple de classe abstraite se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> de la distribution de QxOrm avec la classe <i>BaseClassTrigger</i>.<br>
           QxOrm propose le mécanisme suivant pour définir une classe abstraite dans le contexte QxOrm :
           <ul>
           <li>déclarer la classe avec la méthode '<i>void register_class</i>' comme n'importe qu'elle autre classe ;
           </li><li>utiliser la macro <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> juste après la définition de la classe.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_150"><u><b>Comment déclarer une classe définie dans un espace de nom (<i>namespace</i>) dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Si une classe est définie dans un espace de nom (<i>namespace</i>), alors une erreur de compilation se produit avec l'utilisation des macros : <b>QX_REGISTER_HPP</b> et <b>QX_REGISTER_CPP</b>.<br>
           Pour éviter ces erreurs de compilation, il est nécessaire d'utiliser les macros suivantes : <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> et <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b>.<br>
           <br>
           Vous trouverez un exemple d'utilisation dans le dossier <i>./test/qxDllSample/dll1/</i> de la distribution de QxOrm avec la classe <i>CPerson</i> définie dans l'espace de nom <i>qx::test</i> :<br>
           * <i><b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)</b></i><br>
           <br>
           Les macros <b>QX_REGISTER_COMPLEX_CLASS_NAME...</b> nécessitent un paramètre supplémentaire (dans l'exemple ci-dessus il s'agit du paramètre <i>qx_test_CPerson</i>) afin de créer une variable globale.<br>
           Celle-ci est appelée dès le lancement de l'application.<br>
           La construction de cette instance globale déclare la classe dans le module <i>QxFactory</i> (modèle de conception fabrique ou design pattern factory).<br>
           Un objet C++ ne pouvant pas se nommer avec des caractères "<i>::</i>", le paramètre supplémentaire de la macro permet de remplacer tous les "<i>::</i>" par des "<i>_</i>".<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_160"><u><b>Comment utiliser le mécanisme de suppression logique (<i>soft delete</i>) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Une suppression logique permet de ne pas effacer de ligne dans une table d'une base de données (contrairement à une suppression physique) : une colonne supplémentaire est ajoutée à la définition de la table pour indiquer que la ligne est supprimée ou non.<br>
           Cette colonne peut contenir soit un booléen (1 signifie ligne supprimée, 0 ou vide signifie ligne non supprimée), soit la date-heure de suppression de la ligne (si vide, la ligne est considérée comme non supprimée).<br>
           Il est donc à tout moment possible de réactiver une ligne supprimée en réinitialisant la valeur à vide dans la table de la base de données.<br>
           <br>
           Pour activer le mécanisme de suppression logique avec la bibliothèque QxOrm, il faut utiliser la classe <b>qx::QxSoftDelete</b> dans la fonction de mapping <i>qx::register_class&lt;T&gt;</i>.<br>
           Voici un exemple d'utilisation avec une classe <i>Bar</i> contenant deux propriétés <i>m_id</i> et <i>m_desc</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Les requêtes SQL générées automatiquement par la bibliothèque QxOrm vont prendre en compte ce paramètre de suppression logique pour ajouter les conditions nécessaires (ne pas récupérer les éléments supprimés, ne pas supprimer physiquement une ligne, etc.).<br>
           Par exemple, si vous exécutez les lignes suivantes avec la classe <i>Bar</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
           </td></tr></tbody></table>
           <br>
           Vous obtiendrez les traces suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> pour supprimer physiquement une ligne de la base de données, il faut utiliser les fonctions : <i>qx::dao::destroy_by_id()</i> et <i>qx::dao::destroy_all()</i>.<br>
           <br>
           <b>Autre remarque :</b> il peut être intéressant de définir au niveau du SGBD un index sur la colonne <i>deleted_at</i> (ou peu importe le nom que vous donnez) afin d'accélérer l'exécution des requêtes SQL.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_170"><u><b>Comment utiliser les sessions (classe <i>qx::QxSession</i>) pour simplifier la gestion des transactions des bases de données (C++ RAII) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
            Une <a href="http://knol.google.com/k/les-transactions-base-de-données" target="_blank"><b>transaction</b></a> est une suite d'opérations effectuées comme une seule unité logique de travail.<br>
            Une fois terminée, la transaction est :<br>
            * soit validée (<b>commit</b>), alors toutes les modifications sont faites dans la base de données ;<br>
            * soit annulée (<b>rollback</b>), alors toutes les modifications ne sont pas enregistrée.<br>
            <br>
            La classe <b><a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a></b> de la bibliothèque QxOrm permet de gérer automatiquement les transactions (validation, annulation) en utilisant le mécanisme <a href="http://fr.wikipedia.org/wiki/RAII" target="_blank">C++ RAII</a> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connection valide à la BDD est assignée à la session et une transaction est démarrée
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD (en utilisant l'opérateur += de la classe qx::QxSession et la connection de la session)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> une session peut déclencher une exception de type <i>qx::dao::sql_error</i> lorsqu'une erreur se produit (par défaut, aucune exception n'est déclenchée). Il est possible de paramétrer ce comportement en utilisant :<br>
            * soit le constructeur de la classe <i>qx::QxSession</i> (pour une session en particulier) ;<br>
            * soit le paramètre du singleton <i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> (pour toutes les sessions).<br>
            <br>
            <b>Autre remarque :</b> il est important de ne pas oublier de passer la connection à la base de données de la session à chaque fonction <i>qx::dao::xxx</i> (en utilisant la méthode <i>session.database()</i>).<br>
            De plus, il est possible d'initialiser une session avec sa propre connection (provenant d'un pool de connections par exemple) en utilisant le constructeur de la classe <i>qx::QxSession</i>.<br>
            <br>
            La classe <i>qx::QxSession</i> propose également des méthodes de persistance (CRUD), ce qui peut simplifier l'écriture du code C++ suivant les habitudes de programmation.<br>
            Voici le même exemple en utilisant les méthodes de la classe <i>qx::QxSession</i> à la place des fonctions du <i>namespace</i> <i>qx::dao</i> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connection valide à la BDD est assignée à la session et une transaction est démarrée
</span>  qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD
</span>  session<span class="operator">.</span>insert<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>update<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>fetchById<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>deleteById<span class="operator">(</span>my_object<span class="operator">);</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
</span><span class="flow">  if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_180"><u><b>Comment persister un type dont on ne possède pas le code source (classe provenant d'une bibliothèque tierce par exemple) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           La bibliothèque QxOrm permet de persister n'importe quel type, même si ce dernier n'est pas enregistré dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           Il est nécessaire d'écrire les fonctions de sérialisation de la bibliothèque boost, en utilisant la méthode <b>non intrusive</b> (puisque le code source n'est pas disponible ou ne peut pas être modifié).
           Pour plus d'informations sur la sérialisation des données avec la bibliothèque boost, rendez-vous sur <a href="http://khayyam.developpez.com/articles/cpp/boost/serialization/" target="_blank">le tutoriel de developpez.com</a>.<br>
           <br>
           Par exemple, imaginons une classe '<i>ExtObject3D</i>' provenant d'une bibliothèque tierce et dont le code source n'est pas disponible ou ne peut pas être modifié.
           Voici le code nécessaire pour pouvoir persister une instance de type '<i>ExtObject3D</i>' en base de données :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Le code ci-dessus est suffisant pour persister une instance de type '<i>ExtObject3D</i>' en base de données : il est ainsi possible d'utiliser une propriété de type '<i>ExtObject3D</i>' dans une classe persistante enregistrée dans le contexte QxOrm.
           Cette propriété peut être mappée sur une colonne de type <i>TEXT</i> ou <i>VARCHAR</i> en base de données.<br>
           <br>
           Le comportement par défaut de la bibliothèque QxOrm est le suivant : l'instance est sérialisée au format XML avant d'être insérée ou mise à jour en base de données.
           Ce comportement par défaut peut être utile par exemple si l'on souhaite enregistrer une collection d'objets sans vouloir faire de relation (et donc gérer une autre table dans la base de données).
           Par exemple, si l'on utilise une propriété de type <i>std::vector&lt;mon_objet&gt;</i> dans une classe persistante sans relation associée, la liste d'éléments sera automatiquement enregistrée au format XML en base de données.<br>
           <br>
           <b>Remarque :</b> ce comportement par défaut peut être facilement modifié pour un type donné.
           Le moteur <i>QtSql</i> utilise le type <i>QVariant</i> pour faire le lien entre le code C++ et la base de données.
           Le type <i>QVariant</i> peut contenir du texte, des valeurs numériques, du binaire, etc.
           Il peut donc être intéressant de spécialiser le comportement par défaut (sérialisation XML) si l'on souhaite stocker des données au format binaire ou bien optimiser les performances (la sérialisation XML peut être couteuse en temps d'exécution).
           Il suffit de proposer (en plus des fonctions de sérialisation boost) les conversions nécessaires en <i>QVariant</i>, par exemple avec la classe '<i>ExtObject3D</i>' :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index<span class="operator">)
{</span><span class="comment"> /* Ici je convertis ExtObject3D en QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index<span class="operator">)
{</span><span class="comment"> /* Ici je convertis QVariant en ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_190"><u><b>Comment utiliser le moteur d'introspection (ou réflexion) de la bibliothèque QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Toute classe enregistrée dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> peut être utilisée par le moteur d'introspection (ou réflexion) de la bibliothèque QxOrm.
           Le moteur d'introspection permet d'obtenir de façon dynamique (donc pendant l'exécution du programme) des informations propres à un type.
           Ces informations correspondent à des <i>méta-données</i> et décrivent de façon exhaustive les caractéristiques d'une classe (propriétés, méthodes, etc.).
           De nombreux langages de programmation (par exemple Java ou C#) intègrent nativement ce mécanisme, ce n'est pas le cas du C++, c'est pourquoi la bibliothèque QxOrm émule un moteur d'introspection.<br>
           <br>
           Voici la liste des classes disponibles pour accéder aux <i>méta-données</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton permettant de parcourir l'ensemble des classes enregistrées dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface pour une classe enregistrée dans le contexte QxOrm ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : liste des propriétés associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface pour une propriété d'une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : liste des méthodes associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface pour une méthode d'une classe.</li>
           </ul>
           Une instance de type <i>qx::IxClass</i> possède la liste des propriétés d'une classe (<i>qx::IxDataMemberX</i>) ainsi que la liste des méthodes d'une classe (<i>qx::IxFunctionX</i>).<br>
           <br>
           Le moteur d'introspection de la bibliothèque QxOrm permet par exemple de :
           <ul>
             <li>créer dynamiquement une instance en fonction du nom d'une classe sous forme de chaîne de caractères (<i>qx::create()</i>) ;</li>
             <li>accéder/modifier le contenu d'un champ d'un objet de façon dynamique en prenant pour paramètres un objet et le nom du champ qu'on souhaite accéder/modifier (<i>qx::IxDataMember::getValue()</i> et <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li>invoquer une méthode de classe de façon dynamique, en gérant bien entendu le passage des paramètres souhaités à la méthode (<i>qx::IxFunction::invoke()</i>) ;</li>
             <li>accéder à la hiérarchie d'une classe (<i>qx::IxClass::getBaseClass()</i>).</li>
           </ul>
           <b>Remarque :</b> le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> de la bibliothèque QxOrm (<a href="./tutorial_2.html" target="_blank">cliquez ici pour accéder au tutoriel</a>) permettant de créer un serveur d'applications C++ est basé sur le moteur d'introspection pour appeler dynamiquement les méthodes de type service (demande du client) sur le serveur.<br>
           <br>
           Voici un exemple d'utilisation du moteur d'introspection de la bibliothèque QxOrm : comment lister toutes les classes, propriétés et méthodes enregistrées dans le contexte QxOrm ?<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si on utilise la méthode <i>qx::QxClassX::dumpAllClasses()</i> avec le <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a>, voici le résultat obtenu :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> il est possible d'ajouter de nouvelles informations au moteur d'introspection en utilisant la notion de <i>property bag</i>.
           En effet, les classes <i>qx::IxClass</i>, <i>qx::IxDataMember</i> et <i>qx::IxFunction</i> possèdent chacune une liste d'éléments de type <i>QVariant</i> accessibles par clé de type <i>QString</i> (voir la classe <i>qx::QxPropertyBag</i> pour plus de détails sur cette notion).<br>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_200"><u><b>Comment déclarer automatiquement les méta-propriétés de Qt (définies par la macro <i>Q_PROPERTY</i>) dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Toute classe héritant du type <i>QObject</i> peut déclarer ses propriétés avec la macro <i><a href="http://doc-snapshots.qt.io/4.8/properties.html" target="_blank">Q_PROPERTY</a></i> : les propriétés deviennent alors des méta-propriétés.
           Ce mécanisme permet au framework Qt de proposer un moteur d'introspection grâce au pré-compilateur <i>moc</i>.
           Les méta-propriétés peuvent alors être utilisées par exemple par le moteur <i>QML</i>, <i>QtScript</i>, etc.<br>
           <br>
           La bibliothèque <b>QxOrm</b> nécessite une déclaration de chacune des propriétés d'une classe dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> afin de proposer l'ensemble de ses fonctionnalités (persistance des données, sérialisation XML, JSON et binaire, etc.).
           Il est possible de déclarer automatiquement dans le contexte QxOrm l'ensemble des méta-propriétés sans maintenir une fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> : la macro <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> utilise le moteur d'introspection de Qt pour parcourir la liste des méta-propriétés.<br>
           <br>
           Voici un exemple d'utilisation avec la classe <i>TestQtProperty</i> se trouvant dans le dossier <i>./test/qxDllSample/dll1/include/</i> de la distribution QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour ceux qui ne souhaitent pas utiliser la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>, il est possible d'écrire à la place les quatre lignes de code suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">); }
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le deuxième paramètre de la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i> permet d'indiquer la propriété qui servira de clé primaire dans la base de données.
           Si ce paramètre est vide, cela signifie que la classe ne possède pas de clé primaire ou bien que celle-ci est définie dans une classe de base.<br>
           <br>
           Toute propriété définie avec la macro <i>Q_PROPERTY</i> peut s'enregistrer dans le contexte QxOrm de deux manières différentes :<br>
           <b>1-</b> par la méthode classique : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> ou bien sans mentionner le pointeur vers la donnée membre de la classe : <i>t.data("my_property", 0);</i><br>
           <br>
           Peu importe la méthode d'enregistrement des propriétés dans le contexte QxOrm, elles seront accessibles par la même interface <i><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i> et proposent donc les mêmes fonctionnalités.
           Il est possible d'utiliser les deux méthodes dans une même fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>.
           Chaque méthode d'enregistrement présente des avantages et inconvénients.<br>
           <br>
           Voici la liste des avantages de la deuxième méthode d'enregistrement des propriétés dans le contexte QxOrm :
           <ul>
             <li>temps de compilation du projet beaucoup plus rapide ;</li>
             <li>taille de l'exécutable généré plus petite ;</li>
             <li>forte intégration avec le moteur d'introspection du framework Qt ;</li>
             <li>pas besoin de maintenir la fonction de mapping en utilisant la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>.</li>
           </ul>
           Voici les inconvénients par rapport à la méthode classique d'enregistrement des propriétés :
           <ul>
             <li>nécessite un héritage de la classe <i>QObject</i> pour pouvoir utiliser la macro <i>Q_PROPERTY</i> ;</li>
             <li>exécution du programme plus lente (utilisation du type <i>QVariant</i> à la place des <i>template</i> C++) ;</li>
             <li>ne supporte pas la notion de relation entre tables de la base de données (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>) ;</li>
             <li>pas d'accès au pointeur sur la donnée membre de la classe (conversion nécessaire au type <i>QVariant</i> pour accéder et modifier une valeur).</li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_210"><u><b>Comment construire une requête pour interroger la base de données sans écrire de SQL avec la classe <i>qx::QxSqlQuery</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           La classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou bien son alias <i>qx_query</i>) permet d'interroger la base de données (trier, filtrer, etc.) de deux manières différentes :
           <ul>
             <li>en écrivant directement la requête SQL ;</li>
             <li>en utilisant des méthodes C++ avec une syntaxe proche du SQL (similaire à ce que propose <a href="http://subsonicproject.com/docs/Simple_Query_Tool" target="_blank">l'excellente bibliothèque SubSonic pour .Net</a>).</li>
           </ul>
           Le principal avantage de la première méthode (écriture manuelle des requêtes SQL) est de pouvoir utiliser certaines optimisations spécifiques à chaque base de données.<br>
           La deuxième méthode (utilisation du code C++ pour générer la requête SQL) permet de mapper automatiquement les paramètres SQL sans utiliser la fonction <i>qx::QxSqlQuery::bind()</i>.<br>
           <br>
           Voici un exemple d'utilisation de la classe <i>qx::QxSqlQuery</i> avec écriture manuelle d'une requête SQL :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx<span class="operator">::</span>QxSqlQuery query<span class="operator">(</span><span class="string">"WHERE author.sex = :sex"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":sex"</span><span class="operator">,</span> author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
           </td></tr></tbody></table>
           <br>
           La bibliothèque QxOrm supporte trois syntaxes pour l'écriture des paramètres SQL.<br>
           Le type de syntaxe peut être modifié de façon globale à un projet en utilisant la méthode suivante : <i>qx::QxSqlDatabase::getSingleton()->setSqlPlaceHolderStyle()</i>.<br>
           Les trois paramètres possibles pour cette méthode sont :
           <ul>
             <li><i>ph_style_2_point_name</i> : "WHERE author.sex = :sex" (syntaxe par défaut) ;</li>
             <li><i>ph_style_at_name</i> : "WHERE author.sex = @sex" ;</li>
             <li><i>ph_style_question_mark</i> : "WHERE author.sex = ?".</li>
           </ul>
           Voici le même exemple en utilisant les méthodes C++ de la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) pour générer la requête automatiquement :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"author.sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
           </td></tr></tbody></table>
           <br>
           Cette utilisation de la classe <i>qx::QxSqlQuery</i> présente l'avantage de ne pas avoir à mapper les paramètres de la requête, tout en restant très proche de l'écriture manuelle d'une requête SQL.<br>
           Les paramètres seront automatiquement injectés en utilisant la syntaxe définie de manière globale par la méthode : <i>qx::QxSqlDatabase::getSingleton()->getSqlPlaceHolderStyle()</i>.<br>
           <br>
           Voici un exemple présentant différentes méthodes disponibles avec la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"age"</span><span class="operator">).</span>isGreaterThan<span class="operator">(</span><span class="int">38</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">).</span>isNotEqualTo<span class="operator">(</span><span class="string">"Dupont"</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"first_name"</span><span class="operator">).</span>like<span class="operator">(</span><span class="string">"Alfred"</span><span class="operator">)
     .</span>and_OpenParenthesis<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>isLessThanOrEqualTo<span class="operator">(</span><span class="int">999</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"birth_date"</span><span class="operator">).</span>isBetween<span class="operator">(</span>date1<span class="operator">,</span> date2<span class="operator">)
     .</span>closeParenthesis<span class="operator">()
     .</span>or_<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>in<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 999</span><span class="operator">,</span><span class="int"> 11</span><span class="operator">,</span><span class="int"> 23</span><span class="operator">,</span><span class="int"> 78945</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"is_deleted"</span><span class="operator">).</span>isNotNull<span class="operator">()
     .</span>orderAsc<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="string"> "sex"</span><span class="operator">)
     .</span>limit<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 150</span><span class="operator">);</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui produira le code SQL suivant pour les bases de données <i>MySQL</i>, <i>PostgreSQL</i> et <i>SQLite</i> (pour <i>Oracle</i> et <i>SQLServer</i>, le traitement de la méthode <i>limit()</i> est différent) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>WHERE sex<span class="operator"> = :</span>sex_1_0 
AND age<span class="operator"> &gt; :</span>age_3_0 
OR last_name<span class="operator"> &lt;&gt; :</span>last_name_5_0 
OR first_name LIKE<span class="operator"> :</span>first_name_7_0 
AND<span class="operator"> (</span> id<span class="operator"> &lt;= :</span>id_10_0 AND birth_date BETWEEN<span class="operator"> :</span>birth_date_12_0_1 AND<span class="operator"> :</span>birth_date_12_0_2<span class="operator"> )</span> 
OR id IN<span class="operator"> (:</span>id_15_0_0<span class="operator">, :</span>id_15_0_1<span class="operator">, :</span>id_15_0_2<span class="operator">, :</span>id_15_0_3<span class="operator">, :</span>id_15_0_4<span class="operator">)</span> 
AND is_deleted IS NOT NULL 
ORDER BY last_name ASC<span class="operator">,</span> first_name ASC<span class="operator">,</span> sex ASC 
LIMIT<span class="operator"> :</span>limit_rows_count_19_0 OFFSET<span class="operator"> :</span>offset_start_row_19_0</pre>
           </td></tr></tbody></table>
           <br>
           Voici la liste des fonctions et méthodes disponibles pour utiliser la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// avec les fonctions du namespace qx::dao
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxSession
</span>qx<span class="operator">::</span>QxSession<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>fetchByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>update<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>deleteByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>destroyByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxRepository&lt;T&gt;
</span>qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>count<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fetchByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>update<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>deleteByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>destroyByQuery<span class="operator">()</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> certaines de ces fonctions ont également deux autres paramètres optionnels :
           <ul>
             <li><i>const QStringList & columns</i> : pour indiquer la liste des colonnes à récupérer (par défaut, toutes les colonnes sont récupérées) ;</li>
             <li><i>const QStringList & relation</i> : pour indiquer les jointures (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i> définies dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>) entre les tables de la base de données (par défaut, aucune relation).</li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_220"><u><b>Comment utiliser le cache (fonctions du namespace <i>qx::cache</i>) pour stocker tous types de données ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Le cache proposé par la bibliothèque QxOrm (<a href="../doxygen/html/group___qx_cache.html" target="_blank">module <i>QxCache</i></a>) est <i>thread-safe</i> et permet de stocker facilement n'importe quel type de données.<br>
           Les fonctions pour accéder au cache se trouvent dans le <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>.<br>
           Le cache permet une optimisation du programme : il est possible par exemple de stocker des éléments issus d'une requête effectuée en base de données.<br>
           <br>
           Chaque élément stocké dans le cache est associé à une clé de type <i>QString</i> : cette clé permet de retrouver rapidement un élément du cache.<br>
           Si un nouvel élément est stocké dans le cache avec une clé qui existe déjà, alors l'ancien élément associé à cette clé est effacé automatiquement du cache.<br>
           <br>
           Le cache de la bibliothèque QxOrm ne gère pas la durée de vie des objets : il n'y a aucun <i>delete</i> effectué par le cache.<br>
           C'est pourquoi il est fortement recommandé (mais ce n'est pas une obligation) de privilégier le stockage de pointeurs intelligents : par exemple, <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" target="_blank"><i>boost::shared_ptr&lt;T&gt;</i></a> pour la bibliothèque <i>boost</i> ou bien <a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer&lt;T&gt;</i></a> pour la bibliothèque <i>Qt</i>.<br>
           <br>
           Le cache peut avoir un coût relatif maximum pour éviter une utilisation de la mémoire trop importante : chaque élément inséré dans le cache peut indiquer un coût représentant une estimation de sa taille mémoire (par exemple, le nombre d'éléments d'une collection).<br>
           Lorsque le coût maximum du cache est atteint, les premiers éléments insérés dans le cache sont supprimés (en respectant l'ordre d'insertion dans le cache) jusqu'à ce que la limite du cache ne soit plus dépassée.<br>
           <br>
           Il est possible d'associer à chaque élément du cache une date-heure d'insertion.<br>
           Si aucune date-heure n'est renseignée, alors la date-heure courante est prise en compte.<br>
           Ce mécanisme permet de vérifier si un élément stocké dans le cache nécessite une mise à jour ou non.<br>
           <br>
           Voici un exemple d'utilisation du cache de la bibliothèque QxOrm (fonctions du <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Défini le coût maximum du cache à 500
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>max_cost<span class="operator">(</span><span class="int">500</span><span class="operator">);</span><span class="comment">

// Récupère une liste de 'author' de la base de données
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author<span class="operator">&gt; &gt;</span> list_author<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_author<span class="operator">);</span><span class="comment">

// Insère la liste de 'author' dans le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">,</span> list_author<span class="operator">);</span><span class="comment">

// Récupère une liste de 'blog' de la base de données
</span>QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt;</span> list_blog<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_blog<span class="operator">);</span><span class="comment">

// Insère la liste de 'blog' dans le cache (coût = nombre de 'blog')
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">,</span> list_blog<span class="operator">.</span>count<span class="operator">());</span><span class="comment">

// Pointeur vers un objet de type 'comment'
</span>comment_ptr my_comment<span class="operator">;</span>
my_comment<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> comment<span class="operator">(</span><span class="int">50</span><span class="operator">));</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_comment<span class="operator">);</span><span class="comment">

// Insère le 'comment' dans le cache en précisant une date-heure d'insertion
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span><span class="int"> 1</span><span class="operator">,</span> my_comment<span class="operator">-&gt;</span>dateModif<span class="operator">());</span><span class="comment">

// Récupère la liste de 'blog' stockée dans le cache
</span>list_blog<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">&lt;</span> QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt; &gt;(</span><span class="string">"list_blog"</span><span class="operator">);</span><span class="comment">

// Récupère la liste de 'blog' sans préciser le type
</span>qx_bool bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">);</span><span class="comment">

// Supprime du cache la liste de 'author'
</span><span class="type">bool</span> bRemoveOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>remove<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">);</span><span class="comment">

// Compte le nombre d'éléments du cache
</span><span class="type">long</span> lCount<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>count<span class="operator">();</span><span class="comment">

// Récupère le coût actuel des éléments stockés dans le cache
</span><span class="type">long</span> lCurrentCost<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>current_cost<span class="operator">();</span><span class="comment">

// Vérifie qu'un élément associé à la clé "comment" existe dans le cache
</span><span class="type">bool</span> bExist<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>exist<span class="operator">(</span><span class="string">"comment"</span><span class="operator">);</span><span class="comment">

// Récupère le 'comment' stocké dans le cache avec sa date-heure d'insertion
</span>QDateTime dt<span class="operator">;</span>
bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span> dt<span class="operator">);</span><span class="comment">

// Vide le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_230"><u><b>Comment générer le schéma SQL (création et mise à jour des tables) en fonction des classes persistantes C++ définies dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <a href="#faq_15">Il est recommandé d'utiliser l'application <b>QxEntityEditor</b> pour gérer cette problématique.</a><br>
           <br>
           La bibliothèque QxOrm ne fournit pas de mécanisme pour gérer automatiquement la création et mise à jour des tables dans la base de données.<br>
           En effet, la fonction <i>qx::dao::create_table&lt;T&gt;</i> doit être utilisée uniquement pour créer des prototypes.<br>
           Il est fortement recommandé d'utiliser un outil spécifique à chaque SGBD pour créer et maintenir les tables de la base de données (par exemple <i>Navicat</i> pour <i>MySql</i>, <i>pgAdmin</i> pour <i>PostgreSQL</i>, <i>SQLite Manager</i> pour <i>SQLite</i>, etc.).<br>
           De plus, un outil spécifique à chaque SGBD permet d'appliquer certaines optimisations (ajout d'index par exemple).<br>
           <br>
           Cependant, il peut être intéressant pour certaines applications de ne pas avoir à gérer manuellement les tables de la base de données.<br>
           Dans ce cas, il est possible de créer une fonction C++ pour parcourir la liste des classes persistantes enregistrées dans le contexte QxOrm (en utilisant le moteur d'introspection de la bibliothèque) et ainsi créer un script SQL de génération et mise à jour des tables de la base de données.<br>
           <br>
           La bibliothèque QxOrm fournit une fonction C++ créée uniquement à titre d'exemple : elle peut donc servir de base de travail pour créer sa propre fonction de génération de script SQL.<br>
           Cette fonction se trouve dans le fichier <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">./src/QxRegister/QxClassX.cpp</a></i> et se nomme <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">QString qx::QxClassX::dumpSqlSchema()</a></i>.<br>
           Elle génère un script SQL et le renvoie sous forme de <i>QString</i> : il est possible d'adapter cette fonction pour générer un fichier contenant le script SQL ou bien appliquer chaque instruction SQL directement au SGBD.<br>
           <br>
           Voici un exemple d'implémentation proposé par <a href="http://www.developpez.net/forums/u449556/dodobibi/" target="_blank">dodobibi</a> pour gérer une base <i>PostgreSQL</i> : cet exemple gère les évolutions futures de son application (ajout de colonnes dans une table existante, ajout d'index sur une colonne existante, etc.).<br>
           Au lancement de l'application, le numéro de version est indiqué de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QApplication app<span class="operator">(</span>argc<span class="operator">,</span> argv<span class="operator">);</span>
app<span class="operator">.</span>setProperty<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span><span class="comment"> // Version incrementée à chaque compilation et diffusion de l'application</span></pre>
           </td></tr></tbody></table>
           <br>
           Une table de la base de données permet de stocker le numéro de version courant.<br>
           Une classe persistante C++ est mappée sur cette table de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _DATABASE_VERSION_H_
#define _DATABASE_VERSION_H_
</span><span class="keyword"> 
class</span> MY_DLL_EXPORT DatabaseVersion<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
  QString name<span class="operator">;</span><span class="type">
  long</span> version<span class="operator">;
};</span>

QX_REGISTER_HPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _DATABASE_VERSION_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/DatabaseVersion.h"
#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>DatabaseVersion<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>version<span class="operator">,</span><span class="string"> "version"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Avec la classe <i>DatabaseVersion</i>, il est possible de vérifier si la version de la base de données est à jour.<br>
           C'est le rôle de la fonction <i>isDatabaseVersionOld()</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">bool</span> isDatabaseVersionOld<span class="operator">()
{</span>
  DatabaseVersion dbVersion<span class="operator">;</span>
  dbVersion<span class="operator">.</span>name<span class="operator"> =</span><span class="string"> "MyAppName"</span><span class="operator">;</span>
  QSqlError err<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="flow">
  if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="bool"> false</span><span class="operator">; }</span><span class="flow">
  return</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &lt;</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">());
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si au lancement de l'application, la fonction <i>isDatabaseVersionOld()</i> renvoie <i>true</i>, alors la mise à jour de la base de données est effectuée de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">void</span> updateDatabaseVersion<span class="operator">()
{</span><span class="flow">
  try</span><span class="operator">
  {</span><span class="type">
    int</span> domainVersion<span class="operator"> =</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">();</span><span class="comment">

    // On se connecte avec un utilisateur de la base de données qui a les droits de modifications du schéma
</span>    QSqlDatabase db<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getDatabaseCloned<span class="operator">();</span>
    db<span class="operator">.</span>setUserName<span class="operator">(</span><span class="string">"MyAdminLogin"</span><span class="operator">);</span>
    db<span class="operator">.</span>setPassword<span class="operator">(</span><span class="string">"MyAdminPassword"</span><span class="operator">);</span><span class="comment">

    // On s'assure que la session démarre une transaction et lève une exception à la moindre erreur
</span>    qx<span class="operator">::</span>QxSession session<span class="operator">(</span>db<span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">);</span><span class="comment">

    // On "fetch" la version de la base de données avec un verrou pour éviter les modifications concurrentes !
    // Si plusieurs utilisateurs lancent l'application en même temps et qu'une mise à jour
    // est nécessaire, le premier fera la mise à jour, et les autres seront en attente
</span>    DatabaseVersion dbVersion<span class="operator">;</span>
    session<span class="operator">.</span>fetchByQuery<span class="operator">(</span>qx_query<span class="operator">(</span><span class="string">"WHERE name='MyAppName' FOR UPDATE"</span><span class="operator">),</span> dbVersion<span class="operator">);</span><span class="comment">

    // Pour les autres utilisateurs, une fois le verrou levé, on vérifie si la mise à jour est toujours nécessaire
</span><span class="flow">    if</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &gt;=</span> domainVersion<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // On exécute chaque instruction SQL avec la variable "query"
</span>    QSqlQuery query<span class="operator">(</span>db<span class="operator">);</span><span class="comment">

    // On récupère toutes les classes persistantes C++ enregistrées dans le contexte QxOrm
</span>    qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> qx<span class="operator">::</span>IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
    if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // on récupère la liste des tables existantes dans la base (fonction de Qt)
</span>    QStringList tables<span class="operator"> =</span> db<span class="operator">.</span>tables<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span><span class="type">long</span> k<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> k<span class="operator"> &lt;</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span> k<span class="operator">++)
    {</span>
      qx<span class="operator">::</span>IxClass<span class="operator"> *</span> pClass<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>getByIndex<span class="operator">(</span>k<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (!</span> pClass<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes non persistantes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxParameter"</span><span class="operator">) ||</span> pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxService"</span><span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes à jour : si la version de pClass est &lt;= à la version enregistrée dans la base, la mise à jour n'est pas nécessaire
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // On crée la table si elle n'existe pas, et on définit son propriétaire
</span><span class="flow">      if</span><span class="operator"> (!</span> tables<span class="operator">.</span>contains<span class="operator">(</span>pClass<span class="operator">-&gt;</span>getName<span class="operator">()))
      {</span>
        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ( ) WITH (OIDS = FALSE);"
                   "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " OWNER TO \"MyAdminLogin\";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
      }</span><span class="comment">

      // On ajoute les colonnes à la table si elles n'existent pas
</span>      qx<span class="operator">::</span>IxDataMemberX<span class="operator"> *</span> pDataMemberX<span class="operator"> =</span> pClass<span class="operator">-&gt;</span>getDataMemberX<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">; (</span>pDataMemberX<span class="operator"> &amp;&amp; (</span>l<span class="operator"> &lt;</span> pDataMemberX<span class="operator">-&gt;</span>count_WithDaoStrategy<span class="operator">()));</span> l<span class="operator">++)
      {</span>
        qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> pDataMemberX<span class="operator">-&gt;</span>get_WithDaoStrategy<span class="operator">(</span>l<span class="operator">);</span><span class="flow">
        if</span><span class="operator"> (!</span> p<span class="operator"> || (</span>p<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span>

        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getSqlType<span class="operator">() +</span><span class="string"> ";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getIsPrimaryKey<span class="operator">())</span><span class="comment"> // PRIMARY KEY
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD PRIMARY KEY ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAllPropertyBagKeys<span class="operator">().</span>contains<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">))</span><span class="comment"> // INDEX
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE INDEX "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_idx"</span><span class="operator"> +</span><span class="string"> 
                     " ON "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " USING "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getPropertyBag<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">).</span>toString<span class="operator">() +</span><span class="string"> " ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getNotNull<span class="operator">())</span><span class="comment"> // NOT NULL
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " SET NOT NULL;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAutoIncrement<span class="operator">())</span><span class="comment"> // AUTO INCREMENT
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE SEQUENCE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> " OWNER TO \"MyAdminLogin\"; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span><span class="string">
                     "SET DEFAULT nextval('"</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "'::regclass);"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getDescription<span class="operator">() !=</span><span class="string"> ""</span><span class="operator">)</span><span class="comment"> // DESCRIPTION
</span><span class="operator">        {</span><span class="comment">
          // $$ceci est un texte ne nécessitant pas de caractères d'échappement dans postgres grace aux doubles dolars$$
</span>          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"COMMENT ON COLUMN "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "."</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " IS $$"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span><span class="string"> "$$ ;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }
      }
    }</span><span class="comment">

    // On enregistre la version courante de la base de données
</span>    dbVersion<span class="operator">.</span>version<span class="operator"> =</span> domainVersion<span class="operator">;</span>
    session<span class="operator">.</span>save<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="comment">

    // Fin du block "try" : la session est détruite =&gt; commit ou rollback automatique
    // De plus, un commit ou rollback sur la transaction lève automatiquement le verrou posé précédemment
</span><span class="operator">  }</span><span class="flow">
  catch</span><span class="operator"> (</span><span class="keyword">const</span> qx<span class="operator">::</span>dao<span class="operator">::</span>sql_error<span class="operator"> &amp;</span> err<span class="operator">)
  {</span>
    QSqlError sqlError<span class="operator"> =</span> err<span class="operator">.</span>get<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>databaseText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>driverText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>number<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>type<span class="operator">();
  }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le code précédent (tout comme la fonction <a href="./resource/qxclassx_dump_sql_schema.html" target="_blank"><i>qx::QxClassX::dumpSqlSchema()</i></a>) peut être modifié pour s'adapter aux besoins spécifiques d'une application.<br>
           Par exemple, il pourrait être intéressant de créer par défaut une seconde table (en plus de la table <i>DatabaseVersion</i>) pour enregistrer la liste des classes persistantes enregistrées dans le contexte QxOrm : ainsi, au lieu d'utiliser la fonction proposée par Qt "<i>db.tables()</i>", il serait possible de récupérer toutes les tables mappées sur des classes persistantes avec des informations supplémentaires (numéro de version pour chaque table, nombre de colonnes enregistrées dans le contexte QxOrm, description de chaque table, etc.).
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_240"><u><b>Comment associer un type SQL à une classe C++ ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Chaque base de données propose des types SQL différents pour stocker l'information.<br>
           La bibliothèque QxOrm propose une association par défaut pour les classes C++ les plus fréquemment utilisées dans un programme.<br>
           Voici cette association par défaut :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
           </td></tr></tbody></table>
           <br>
           Si le type SQL proposé par défaut par la bibliothèque QxOrm ne correspond pas à la base de données utilisée, il peut facilement être modifié (de manière globale à toute l'application) en utilisant la collection suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QHash<span class="operator">&lt;</span>QString<span class="operator">,</span> QString<span class="operator">&gt; *</span> lstSqlType<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllSqlTypeByClassName<span class="operator">();</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"QString"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"std::string"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
// etc.</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour modifier le type SQL de manière spécifique pour une colonne d'une table de la base de données, il faut définir le type SQL dans la fonction de mapping de QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>MyClass<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span><span class="comment">
  //...
</span>  IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> MyClass<span class="operator">::</span>m_MyProperty<span class="operator">,</span><span class="string"> "my_property"</span><span class="operator">);</span>
  p<span class="operator">-&gt;</span>setSqlType<span class="operator">(</span><span class="string">"VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
  //...
</span><span class="operator">}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour les classes non supportées par défaut par la bibliothèque QxOrm (voir cette <i>Question-Réponse</i> de la FAQ : <i><a href="./faq.html#faq_180">Comment persister un type dont on ne possède pas le code source (classe provenant d'une bibliothèque tierce par exemple) ?</a></i>), il est possible d'associer un type SQL par défaut en utilisant la macro suivante (en dehors de tout <i>namespace</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_TRAIT_GET_SQL_TYPE<span class="operator">(</span>MyClass<span class="operator">,</span><span class="string"> "my_sql_type"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_250"><u><b>Comment utiliser le module <i>QxValidator</i> pour valider automatiquement les données ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
            Le module <b><a href="../doxygen/html/group___qx_validator.html" target="_blank">QxValidator</a></b> de la bibliothèque <b>QxOrm</b> permet d'ajouter des contraintes sur les propriétés enregistrées dans le contexte QxOrm.<br>
            Ces contraintes sont définies dans la méthode de mapping : <i>void qx::register_class&lt;T&gt;</i>.<br>
            Si pour une instance de classe donnée, au moins une contrainte n'est pas respectée, alors l'instance est considérée comme invalide : l'objet ne peut alors pas être sauvegardé en base de données (<i>INSERT</i> ou <i>UPDATE</i>).<br>
            <br>
            Il est également possible d'utiliser le module <b>QxValidator</b> pour valider les données au niveau de la couche présentation de l'application : si les données saisies par un utilisateur ne sont pas valides, un message d'erreur peut être signalé, il n'est alors pas nécessaire d'essayer d'enregistrer l'instance courante en base de données.<br>
            Les règles de validation n'ont pas besoin d'être dupliquées : elles peuvent être utilisées aussi bien par la couche présentation que par la couche d'accès aux données de l'application.<br>
            <br>
            Voici la description de quelques classes du module <b>QxValidator</b> :
            <ul>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator.html" target="_blank">qx::IxValidator</a> : chaque contrainte définie dans la fonction de mapping <i>void qx::register_class&lt;T&gt;</i> est associée à une interface de type <i>qx::IxValidator</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator_x.html" target="_blank">qx::IxValidatorX</a> : pour une classe donnée, la liste des contraintes est associée à une interface de type <i>qx::IxValidatorX</i>. Cette collection peut être parcourue à l'exécution du programme : ça peut être intéressant par exemple pour générer le schéma SQL et prendre en compte les contraintes au niveau de la base de données (voir la Q&R de la FAQ : <a href="./faq.html#faq_230" target="_blank">Comment générer le schéma SQL (création et mise à jour des tables) en fonction des classes persistantes C++ définies dans le contexte QxOrm ?</a>) ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value_x.html" target="_blank">qx::QxInvalidValueX</a> : au moment du processus de validation, lorsqu'une instance n'est pas valide, la liste des contraintes non respectées est représentée par une collection de type <i>qx::QxInvalidValueX</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value.html" target="_blank">qx::QxInvalidValue</a> : chaque élément de cette collection est de type <i>qx::QxInvalidValue</i> et contient un message d'erreur (description expliquant pourquoi l'instance est invalide).</li>
            </ul>
            Le module <b>QxValidator</b> gère automatiquement la notion d'héritage de classe : si des contraintes sont définies au niveau de la classe de base, alors elles seront automatiquement vérifiées pour chaque validation d'une classe dérivée.<br>
            <br>
            Voici un exemple d'utilisation du module <b>QxValidator</b> avec une classe '<i>person</i>' :<br>
            <br>
            * fichier '<i>person.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _CLASS_PERSON_H_
#define _CLASS_PERSON_H_
</span><span class="keyword"> 
class</span> person<span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span><span class="keyword">

   enum</span> sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="type">

   long</span>        _id<span class="operator">;</span>
   QString     _firstName<span class="operator">;</span>
   QString     _lastName<span class="operator">;</span>
   QDateTime   _birthDate<span class="operator">;</span>
   sex         _sex<span class="operator">;</span>

   person<span class="operator">() :</span> _id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span>
   person<span class="operator">(</span><span class="type">long</span> id<span class="operator">) :</span> _id<span class="operator">(</span>id<span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span><span class="type">

   void</span> isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">);

};</span>

QX_REGISTER_HPP_MY_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _CLASS_PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>person.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/person.h"
#include "../include/global_validator.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_MY_EXE<span class="operator">(</span>person<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_firstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_lastName<span class="operator">,</span><span class="string"> "lastName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_birthDate<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   QxValidatorX<span class="operator">&lt;</span>person<span class="operator">&gt; *</span> pAllValidator<span class="operator"> =</span> t<span class="operator">.</span>getAllValidator<span class="operator">();</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"lastName"</span><span class="operator">,</span><span class="string"> "a person must have a lastname"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator<span class="operator">(&amp;</span> person<span class="operator">::</span>isValid<span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_QVariant<span class="operator">(&amp;</span> validateFirstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_DataType<span class="operator">&lt;</span>QDateTime<span class="operator">&gt;(&amp;</span> validateDateTime<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);
}}</span><span class="type">

void</span> person<span class="operator">::</span>isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Cette méthode est appelée automatiquement par le module 'QxValidator' :
   // - avant d'insérer ou mettre à jour une instance de type 'person' par les fonctions du namespace 'qx::dao' ;
   // - en utilisant la fonction 'qx::validate()' avec pour paramètre une instance de type 'person'.

   // L'enregistrement de la méthode 'person::isValid()' est effectué dans la fonction de mapping :
   // pAllValidator-&gt;add_CustomValidator(&amp; person::isValid);

   // Dans cette méthode, il est possible de vérifier n'importe quelle valeur de l'instance courante
   // Si une propriété est non valide, il suffit d'insérer un élément dans la collection 'invalidValues'

   // Remarque : cette méthode est déclarée 'private' pour forcer l'utilisateur à utiliser la fonction 'qx::validate()'
   // Mais ce n'est pas une obligation : cette méthode peut être déclarée 'public' ou 'protected'

   // Par exemple, si on souhaite vérifier la propriété '_sex' d'une personne :
</span><span class="flow">   if</span><span class="operator"> ((</span>_sex<span class="operator"> !=</span> male<span class="operator">) &amp;&amp; (</span>_sex<span class="operator"> !=</span> female<span class="operator">))
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"le sexe de la personne doit être défini : masculin ou féminin"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>global_validator.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Les fonctions suivantes ('validateFirstName()' et 'validateDateTime()') sont globales (non liées à une classe)
// Elles peuvent ainsi être utilisées par plusieurs classes pour valider une propriété (par exemple : valider la saisie d'une adresse IP).
// Ces fonctions seront appelées automatiquement par le module 'QxValidator' :
// - avant d'insérer ou mettre à jour une instance de classe par les fonctions du namespace 'qx::dao' ;
// - en utilisant la fonction 'qx::validate()'.
</span><span class="type"> 
void</span> validateFirstName<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (convertie en type QVariant)
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la valeur ne doit jamais être égale à "admin" :
</span><span class="flow">   if</span><span class="operator"> (</span>value<span class="operator">.</span>toString<span class="operator">() ==</span><span class="string"> "admin"</span><span class="operator">)
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la valeur ne peut pas être égale à 'admin'"</span><span class="operator">); }
}</span><span class="type">

void</span> validateDateTime<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (en conservant son vrai type, ici il s'agit de tester une date-heure de type 'QDateTime')
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la date-heure doit forcément être renseignée :
</span><span class="flow">   if</span><span class="operator"> (!</span> value<span class="operator">.</span>isValid<span class="operator">())
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la date-heure doit être renseignée et doit être valide"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>main.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>person personValidate<span class="operator">;</span>
personValidate<span class="operator">.</span>_lastName<span class="operator"> =</span><span class="string"> "admin"</span><span class="operator">;</span>
qx<span class="operator">::</span>QxInvalidValueX invalidValues<span class="operator"> =</span> qx<span class="operator">::</span>validate<span class="operator">(</span>personValidate<span class="operator">);</span>
QString sInvalidValues<span class="operator"> =</span> invalidValues<span class="operator">.</span>text<span class="operator">();</span>
qDebug<span class="operator">(</span><span class="string">"[QxOrm] test 'QxValidator' module :\n%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sInvalidValues<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            A l'exécution de ce bout de code, l'instance '<i>personValidate</i>' est non valide : la collection '<i>invalidValues</i>' contient quatre éléments :<br>
            - "<i>la valeur de la propriété 'firstName' ne peut pas être vide</i>" ;<br>
            - "<i>le sexe de la personne doit être défini : masculin ou féminin</i>" ;<br>
            - "<i>la valeur ne peut pas être égale à 'admin'</i>" ;<br>
            - "<i>la date-heure doit être renseignée et doit être valide</i>".<br>
            <br>
            Le module <b>QxValidator</b> fournit plusieurs validateurs pour effectuer des vérifications basiques :
            <ul>
                <li><i>add_NotNull()</i> : vérifie que la valeur n'est pas nulle ;</li>
                <li><i>add_NotEmpty()</i> : vérifie que la chaîne de caractères n'est pas vide ;</li>
                <li><i>add_MinValue()</i> : vérifie que la valeur numérique n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxValue()</i> : vérifie que la valeur numérique n'est pas supérieure au paramètre ;</li>
                <li><i>add_Range()</i> : vérifie que la valeur numérique est comprise entre les deux paramètres ;</li>
                <li><i>add_MinDecimal()</i> : vérifie que la valeur décimale n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxDecimal()</i> : vérifie que la valeur décimale n'est pas supérieure au paramètre ;</li>
                <li><i>add_RangeDecimal()</i> : vérifie que la valeur décimale est comprise entre les deux paramètres ;</li>
                <li><i>add_MinLength()</i> : vérifie que la chaîne de caractères a une taille minimale ;</li>
                <li><i>add_MaxLength()</i> : vérifie que la chaîne de caractères ne dépasse pas un certain nombre de caractères ;</li>
                <li><i>add_Size()</i> : vérifie que la taille de la chaîne de caractères est comprise entre les deux paramètres ;</li>
                <li><i>add_DatePast()</i> : vérifie que la date-heure est dans le passé ;</li>
                <li><i>add_DateFuture()</i> : vérifie que la date-heure est dans le futur ;</li>
                <li><i>add_RegExp()</i> : vérifie que la chaîne de caractères est compatible avec l'expression régulière passée en paramètre ;</li>
                <li><i>add_EMail()</i> : vérifie que la chaîne de caractères correspond à un e-mail.</li>
            </ul>
            Comme dans l'exemple de la classe '<i>person</i>', il est possible de définir également des validateurs personnalisés : ce sont des fonctions ou méthodes de classe qui seront appelées automatiquement par le module <b>QxValidator</b> pour valider une propriété ou une instance de classe.<br>
            Il existe trois types de validateurs personnalisés :
            <ul>
                <li><i>add_CustomValidator()</i> : méthode de classe, la signature de la méthode doit être "<i>void my_class::my_method(qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_QVariant()</i> : fonction globale avec type <i>QVariant</i> (propriété convertie en <i>QVariant</i>), la signature de la fonction doit être "<i>void my_validator(const QVariant &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_DataType()</i> : fonction globale avec le type réel de la propriété, la signature de la fonction doit être "<i>void my_validator(const T &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
            </ul>
            <b>Remarque :</b> à chaque validateur peut être associé un groupe (paramètre optionnel pour chaque méthode <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>).<br>
            Il est ainsi possible de créer des groupes de validation suivant le contexte d'exécution : par exemple, valider la saisie d'une personne sur une IHM A ne nécessite peut-être pas les mêmes vérifications que valider une personne sur une IHM B.<br>
            Pour exécuter la validation d'une instance pour un groupe donné (par exemple "<i>myGroup</i>"), il faut appeler la fonction suivante : "<i>qx::QxInvalidValueX invalidValues = qx::validate(personValidate, "myGroup");</i>".<br>
            <br>
            <b>Autre remarque :</b> le module <b>QxValidator</b> définit des messages par défaut lorsqu'une contrainte n'est pas vérifiée.<br>
            Il est possible de redéfinir ces messages par défaut en modifiant la collection suivante : "<i>QHash<QString, QString> * lstMessage = QxClassX::getAllValidatorMessage();</i>".<br>
            Par exemple : "<i>lstMessage->insert("min_value", "la valeur '%NAME%' doit être inférieure ou égale à '%CONSTRAINT%'");</i>".<br>
            Les champs <i>%NAME%</i> et <i>%CONSTRAINT%</i> seront automatiquement remplacés par les valeurs correspondantes.<br>
            Pour modifier le message pour un validateur donné (et non de manière globale), il faut utiliser le paramètre optionnel disponible pour les méthodes <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_260"><u><b>Comment utiliser l'interface <i>qx::IxPersistable</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           L'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> (ou classe abstraite) dispose uniquement de méthodes virtuelles pures.<br>
           Elle permet d'avoir une classe de base commune pour appeler les fonctions de persistance sans connaître le type réel de l'instance courante (notion de polymorphisme).<br>
           La bibliothèque QxOrm n'impose pas de travailler avec une classe de base pour enregistrer un type persistant dans le contexte QxOrm, cependant il est parfois utile de disposer d'une interface afin d'écrire des algorithmes génériques.<br>
           <br>
           La classe <i>qx::IxPersistable</i> met à disposition les méthodes virtuelles suivantes (pour plus d'informations sur ces méthodes, rendez-vous sur la <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a>) :<br>
           <br>
           <div style="width:900px; height:290px; overflow:auto; background-color:white">
<pre><span class="keyword">virtual</span><span class="type"> long</span> qxCount<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchAll<span class="operator">(</span>qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxInsert<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxUpdate<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxSave<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx_bool qxExist<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>QxInvalidValueX qxValidate<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> groups<span class="operator"> =</span> QStringList<span class="operator">());</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxCollection_ptr qxNewPersistableCollection<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxClass<span class="operator"> *</span> qxClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></pre>
           </div>
           <br>
           Par exemple, à partir d'une liste de pointeurs de type <i>qx::IxPersistable</i>, il est possible d'enregistrer les éléments dans plusieurs tables différentes de la base de données de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QList<span class="operator">&lt;</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *&gt;</span> lst<span class="operator"> = ...;</span>
foreach<span class="operator">(</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *</span> p<span class="operator">,</span> lst<span class="operator">)
{</span>
   QSqlError daoError<span class="operator"> =</span> p<span class="operator">-&gt;</span>qxSave<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>daoError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="comment"> /* an error occured */</span><span class="operator"> }</span><span class="comment">
   // etc...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour implémenter l'interface <i>qx::IxPersistable</i>, il faut :
           <ul>
           <li>faire hériter la classe persistante du type <i>qx::IxPersistable</i> ;</li>
           <li>dans la définition de la classe (<i>myClass.h</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_HPP(myClass)</i> ;</li>
           <li>dans l'implémentation de la classe (<i>myClass.cpp</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_CPP(myClass)</i>.</li>
           </ul>
           Par exemple, implémenter l'interface <i>qx::IxPersistable</i> pour la classe <a href="./tutorial.html#tuto_6"><i>author</i></a> du tutoriel <i>qxBlog</i> revient à écrire (les modifications par rapport au code du tutoriel apparaissent en gras) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author : <font style="background-color:yellow"><b>public qx::IxPersistable</b></font><span class="operator">
{</span>
   <font style="background-color:yellow"><b>QX_PERSISTABLE_HPP(author)</b></font>
<span class="keyword">public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- propriétés
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   list_blog   m_blogX<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
        </td></tr></tbody></table>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span>
<font style="background-color:yellow"><b>QX_PERSISTABLE_CPP(author)</b></font>

<span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le projet de test <i>./test/qxDllSample/dll1/</i> met à disposition une sorte de 'super classe de base' : la classe <i>qx::QxPersistable</i> implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> et hérite de <i>QObject</i>.<br>
           Le mécanisme <i>SIGNAL-SLOT</i> de Qt peut donc être utilisé avec cette classe, ce qui peut être intéressant par exemple pour la notion de déclencheurs (ou <a href="./faq.html#faq_130"><i>trigger</i></a>).<br>
           La classe <i>qx::QxPersistable</i> met également à disposition des méthodes virtuelles qu'il est possible de surcharger pour gérer notamment la notion de validation des données avec le module <a href="./faq.html#faq_250"><i>QxValidator</i></a>.<br>
           La classe <i>qx::QxPersistable</i> ne fait pas partie de la distribution de QxOrm, mais il est possible de la copier-coller dans un projet afin de profiter de ses fonctionnalités :
           <ul>
           <li>accéder au fichier <a href="./resource/qx_persistable_hpp.html" target="_blank"><i>QxPersistable.hpp</i></a> ;</li>
           <li>accéder au fichier <a href="./resource/qx_persistable_cpp.html" target="_blank"><i>QxPersistable.cpp</i></a>.</li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_270"><u><b>Comment utiliser le moteur de relations pour récupérer des données associées à plusieurs tables ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           La bibliothèque QxOrm supporte quatre types de relations pour lier les classes C++ enregistrées dans le contexte QxOrm : <i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>.<br>
           Pour plus de détails sur la définition de ces relations, il est conseillé de lire <a href="./tutorial.html" target="_blank">le tutoriel qxBlog</a>.<br>
           Nous allons détailler dans cette Q&R les différentes méthodes de récupération des données (module <a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao</a>, fonctions du namespace <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a>) :
           <ul>
           <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query</a> : récupère les données en requêtant une seule table de la base de données (on parle alors de mode <i>lazy fetch</i>) ;</li>
           <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_all_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_all_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_all_relation</a> : récupère les données en requêtant une table + toutes ses tables liées (soit une requête sur plusieurs tables de la base de données, on parle alors de mode <i>eager fetch</i>) ;</li>
           <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> : équivalent aux fonctions ci-dessus (mode <i>eager fetch</i>) avec possibilité de préciser les relations à récupérer sur plusieurs niveaux.</li>
           </ul>
           Le premier paramètre des fonctions <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> correspond à la liste des relations à requêter.<br>
           Cette liste de relations peut contenir les éléments suivants :
           <ul>
           <li>identifiant d'une relation : chaque relation possède une clé définie au niveau de la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> ;</li>
           <li>le mot-clé "<i>*</i>" signifie "<i>récupérer toutes les relations définies dans la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> sur un niveau</i>" ;</li>
           <li>le mot-clé "<i>-></i>" signifie jointure de type "<i>LEFT OUTER JOIN</i>" (jointure par défaut de la bibliothèque QxOrm) ;</li>
           <li>le mot-clé "<i>>></i>" signifie jointure de type "<i>INNER JOIN</i>" entre deux tables.</li>
           </ul>
           <b>Remarque :</b> en utilisant le mot-clé "*" pour indiquer "<i>toutes les relations sur un niveau</i>", les appels suivants sont équivalents :
           <ul>
           <li><i>qx::dao::fetch_by_id_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_id_with_all_relation(...)</i> ;</li>
           <li><i>qx::dao::fetch_by_query_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_query_with_all_relation(...)</i> ;</li>
           <li><i>qx::dao::fetch_all_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_all_with_all_relation(...)</i>.</li>
           </ul>
           <br>
           <b>Exemple :</b> à partir du tutoriel qxBlog, il est possible de récupérer les données suivantes avec une seule requête :<br>
           <br>
           <b>1-</b> récupérer un <i>blog</i> et son <i>author</i> ;<br>
           <b>2-</b> pour l'<i>author</i> valorisé, récupérer tous les <i>blog</i> qu'il a écrit ;<br>
           <b>3-</b> pour chaque <i>blog</i> que l'<i>author</i> a écrit, récupérer tous les <i>comment</i> associés.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui génère la requête SQL suivante :
           <div style="width:900px; height:180px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
WHERE blog.blog_id = :blog_id</span></pre>
           </div>
           <br><br>
           <b>Autre exemple :</b> il est également possible de créer une liste de relations à récupérer, comme ceci par exemple :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QStringList relation<span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_category"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_category"</span><span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>relation<span class="operator">,</span> my_blog<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui génère la requête SQL suivante :
           <div style="width:900px; height:270px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, 
       category_7.category_id AS category_7_category_id_0, category_7.name AS category_7_name_0, category_7.description AS category_7_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN category_blog category_blog_7 ON blog.blog_id = category_blog_7.blog_id 
LEFT OUTER JOIN category category_7 ON category_blog_7.category_id = category_7.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
           </div>
           <br><br>
           <b>Autre exemple :</b> pour récupérer toutes les relations pour un niveau donné, il faut utiliser le mot-clé "*".<br>
           Pour récupérer toutes les données de toutes les relations sur trois niveaux, il faut écrire :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"*-&gt;*-&gt;*"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui génère la requête SQL suivante :
           <div style="width:900px; height:620px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, blog_2.author_id AS blog_2_author_id_0_2, 
       author_3.author_id AS author_3_author_id_0, author_3.name AS author_3_name_0, author_3.birthdate AS author_3_birthdate_0, author_3.sex AS author_3_sex_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, comment_6.blog_id AS comment_6_blog_id_0_6, 
       blog_7.blog_id AS blog_7_blog_id_0, blog_7.blog_text AS blog_7_blog_text_0, blog_7.date_creation AS blog_7_date_creation_0, blog_7.author_id AS blog_7_author_id_0_7, 
       author_8.author_id AS author_8_author_id_0, author_8.name AS author_8_name_0, author_8.birthdate AS author_8_birthdate_0, author_8.sex AS author_8_sex_0, 
       comment_9.comment_id AS comment_9_comment_id_0, comment_9.blog_id AS comment_9_blog_id_0, comment_9.comment_text AS comment_9_comment_text_0, comment_9.date_creation AS comment_9_date_creation_0, 
       category_10.category_id AS category_10_category_id_0, category_10.name AS category_10_name_0, category_10.description AS category_10_description_0, 
       category_11.category_id AS category_11_category_id_0, category_11.name AS category_11_name_0, category_11.description AS category_11_description_0, 
       blog_12.blog_id AS blog_12_blog_id_0, blog_12.blog_text AS blog_12_blog_text_0, blog_12.date_creation AS blog_12_date_creation_0, blog_12.author_id AS blog_12_author_id_0_12, 
       author_13.author_id AS author_13_author_id_0, author_13.name AS author_13_name_0, author_13.birthdate AS author_13_birthdate_0, author_13.sex AS author_13_sex_0, 
       comment_14.comment_id AS comment_14_comment_id_0, comment_14.blog_id AS comment_14_blog_id_0, comment_14.comment_text AS comment_14_comment_text_0, comment_14.date_creation AS comment_14_date_creation_0, 
       category_15.category_id AS category_15_category_id_0, category_15.name AS category_15_name_0, category_15.description AS category_15_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN author author_3 ON author_3.author_id = blog_2.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN blog blog_7 ON blog_7.blog_id = comment_6.blog_id 
LEFT OUTER JOIN author author_8 ON author_8.author_id = blog_7.author_id 
LEFT OUTER JOIN comment comment_9 ON comment_9.blog_id = blog_7.blog_id 
LEFT OUTER JOIN category_blog category_blog_10 ON blog_7.blog_id = category_blog_10.blog_id 
LEFT OUTER JOIN category category_10 ON category_blog_10.category_id = category_10.category_id 
LEFT OUTER JOIN category_blog category_blog_11 ON blog.blog_id = category_blog_11.blog_id 
LEFT OUTER JOIN category category_11 ON category_blog_11.category_id = category_11.category_id 
LEFT OUTER JOIN category_blog category_blog_12 ON category_11.category_id = category_blog_12.category_id 
LEFT OUTER JOIN blog blog_12 ON category_blog_12.blog_id = blog_12.blog_id 
LEFT OUTER JOIN author author_13 ON author_13.author_id = blog_12.author_id 
LEFT OUTER JOIN comment comment_14 ON comment_14.blog_id = blog_12.blog_id 
LEFT OUTER JOIN category_blog category_blog_15 ON blog_12.blog_id = category_blog_15.blog_id 
LEFT OUTER JOIN category category_15 ON category_blog_15.category_id = category_15.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
           </div>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_280"><u><b>Comment appeler une procédure stockée ou une requête SQL personnalisée ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           La bibliothèque QxOrm fournit deux fonctions pour appeler une procédure stockée ou une requête SQL personnalisée :
           <ul>
           <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a></li>
           <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a></li>
           </ul>
           Le premier paramètre de ces deux fonctions, de type <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou <i>qx_query</i>), correspond à la procédure stockée ou à la requête SQL personnalisée.<br>
           Pour plus d'informations sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i>, rendez-vous sur cette Q&R de la FAQ de QxOrm : <a href="./faq.html#faq_210">Comment construire une requête pour interroger la base de données sans écrire de SQL avec la classe <i>qx::QxSqlQuery</i> ?</a><br>
           <br>
           La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a> est une fonction <i>template</i> : le type T doit être enregistré dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>).<br>
           Toutes les données renvoyées par la procédure stockée ou la requête SQL personnalisée qui pourront être associées aux membres des classes C++ (de type T) seront valorisées automatiquement.<br>
           Une recherche automatique est effectuée sur le nom des champs associés aux données.<br>
           Voici un exemple d'utilisation (disponible dans le projet qxBlog du package QxOrm) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom SQL query or a stored procedure and fetch automatically properties (with a collection of items)
</span>qx_query testStoredProcBis<span class="operator">(</span><span class="string">"SELECT * FROM author"</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>execute_query<span class="operator">(</span>testStoredProcBis<span class="operator">,</span> authorX<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span> qAssert<span class="operator">(</span>authorX<span class="operator">.</span>count<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>authorX<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           <br><br>
           La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> n'est pas une fonction <i>template</i> : les résultats de la requête doivent être parcourus manuellement sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou <i>qx_query</i>).<br>
           Pour récupérer un paramètre de sortie (qui doit être passé à la requête en tant que <i>QSql::Out</i> ou <i>QSql::InOut</i>), il suffit d'utiliser la méthode : <i>QVariant qx::QxSqlQuery::boundValue(const QString & sKey) const;</i>.<br>
           <br>
           Pour parcourir la liste des résultats de la requête, il faut utiliser les méthodes suivantes :<br>
             * <i>long qx::QxSqlQuery::getSqlResultRowCount() const;</i><br>
             * <i>long qx::QxSqlQuery::getSqlResultColumnCount() const;</i><br>
             * <i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, long column) const;</i><br>
             * <i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, const QString & column) const;</i><br>
             * <i>QVector qx::QxSqlQuery::getSqlResultAllColumns() const;</i><br>
             * <i>void qx::QxSqlQuery::dumpSqlResult();</i><br>
           <br>
           Voici un exemple d'utilisation avec la fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">(</span><span class="string">"CALL MyStoredProc(:param1, :param2)"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param1"</span><span class="operator">,</span><span class="string"> "myValue1"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param2"</span><span class="operator">,</span><span class="int"> 5024</span><span class="operator">,</span> QSql<span class="operator">::</span>InOut<span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>call_query<span class="operator">(</span>query<span class="operator">);</span>
QVariant vNewValue<span class="operator"> =</span> query<span class="operator">.</span>boundValue<span class="operator">(</span><span class="string">":param2"</span><span class="operator">);</span>
query<span class="operator">.</span>dumpSqlResult<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_290"><u><b>Comment utiliser la classe <i>qx::QxDaoAsync</i> pour appeler des requêtes de manière asynchrone (multi-thread) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Il peut être parfois intéressant d'exécuter certaines requêtes à la base de données de manière asynchrone (multi-thread), par exemple pour éviter de bloquer une IHM si une requête est trop longue à s'exécuter.<br>
           Pour simplifier les requêtes asynchrones, la bibliothèque QxOrm fournit la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>.<br>
           Cette classe exécute une requête dans un thread dédié et renvoie un <i>SIGNAL</i> <i>queryFinished()</i> lorsque la requête est terminée.<br>
           Pour utiliser la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>, il suffit de :
           <ul>
           <li>vérifier que la requête fait appel à une classe qui implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> ;</li>
           <li>créer une instance de type <i>qx::QxDaoAsync</i> (par exemple, une propriété membre d'une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>connecter un <i>SLOT</i> au <i>SIGNAL</i> <i>qx::QxDaoAsync::queryFinished()</i> (par exemple, un <i>SLOT</i> défini dans une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>exécuter une requête à la base de données en utilisant l'une des méthodes commençant par <i>async</i> : <i>qx::QxDaoAsync::asyncXXXX()</i>.</li>
           </ul>
           Voici un exemple d'utilisation avec une classe nommée <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MyWidget<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">
{</span> Q_OBJECT<span class="comment">

   //...
</span>   qx<span class="operator">::</span>QxDaoAsync m_daoAsync<span class="operator">;</span><span class="comment">
   //...
</span>Q_SLOTS<span class="operator">:</span><span class="type">
   void</span> onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">);</span><span class="comment">
   //...

</span><span class="operator">};</span></pre>
           </td></tr></tbody></table>
           <br>
           Et voici l'implémentation de la classe <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>MyWidget<span class="operator">::</span>MyWidget<span class="operator">() :</span> QObject<span class="operator">()
{</span><span class="comment">
   //...
</span>   QObject<span class="operator">::</span>connect<span class="operator">((&amp;</span> m_daoAsync<span class="operator">),</span> SIGNAL<span class="operator">(</span>queryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)),</span><span class="keyword"> 
                    this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)));</span><span class="comment">
   //...
</span><span class="operator">}</span><span class="type">

void</span> MyWidget<span class="operator">::</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> pDaoParams<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>
   qx<span class="operator">::</span>QxSqlQuery query<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>query<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (!</span> daoError<span class="operator">.</span>isValid<span class="operator">()) { ; }</span><span class="comment">
   // If the async query is associated to a simple object, just use 'pDaoParams-&gt;pInstance' method
</span>   qx<span class="operator">::</span>IxPersistable_ptr ptr<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pInstance<span class="operator">;</span><span class="comment">
   // If the async query is associated to a list of objects, just use 'pDaoParams-&gt;pListOfInstances' method
</span>   qx<span class="operator">::</span>IxCollection_ptr lst<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pListOfInstances<span class="operator">;</span><span class="comment">
   //...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_300"><u><b>Comment utiliser le module <i>QxModelView</i> pour travailler avec le moteur <i>model/view</i> de Qt (Qt widgets et vues QML) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet d'utiliser <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">le moteur model/view de Qt</a> avec toutes les classes enregistrées dans le contexte QxOrm :
           <ul>
           <li>Qt widgets : utilisation de <i>QTableView</i> ou <i>QListView</i> par exemple pour afficher/modifier le contenu d'une table de base de données ;</li>
           <li>QML : toute propriété enregistrée dans le contexte QxOrm est accessible en QML : le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet ainsi de faciliter l'intéraction entre QML et les bases de données.</li>
           </ul>
           L'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une base commune pour tous les modèles liés aux classes persistantes déclarées dans le contexte QxOrm. Les méthodes de cette classe préfixées par '<i>qx</i>' appellent les fonctions du namespace '<i>qx::dao</i>' et communiquent donc directement avec la base de données.<br/>
           <br/>
           Le projet de test <i>qxBlogModelView</i> présent dans le dossier <i>./test/</i> du package QxOrm montre comment créer rapidement un modèle et l'associer au moteur <i>model/view</i> de Qt (d'abord dans un widget Qt, puis dans une vue QML).<br/>
           <br/>
           1- Exemple de création d'un modèle pour afficher/modifier les données de la table '<i>author</i>' (voir le <a href="./tutorial.html" target="_blank">tutoriel <i>qxBlog</i></a> pour la définition de la classe '<i>author</i>') dans un QTableView :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QTableView and display it
</span>QTableView tableView<span class="operator">;</span>
tableView<span class="operator">.</span>setModel<span class="operator">(</span>pModel<span class="operator">);</span>
tableView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui donne le résultat suivant à l'exécution :<br/>
           <br/>
           <img alt="qx_model_view_01" src="./resource/qx_model_view_01.png" border="0" /><br/>
           <br/><br/>
           2- Voici un autre exemple en QML (en Qt5, le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> étant également compatible avec Qt4) :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QML view and display it
</span>QQuickView qmlView<span class="operator">;</span>
qmlView<span class="operator">.</span>rootContext<span class="operator">()-&gt;</span>setContextProperty<span class="operator">(</span><span class="string">"myModel"</span><span class="operator">,</span> pModel<span class="operator">);</span>
qmlView<span class="operator">.</span>setSource<span class="operator">(</span>QUrl<span class="operator">(</span><span class="string">"qrc:/documents/main.qml"</span><span class="operator">));</span>
qmlView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           Et voici le contenu du fichier '<i>main.qml</i>' :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>import QtQuick<span class="float"> 2.1</span>
import QtQuick<span class="operator">.</span>Controls<span class="float"> 1.0</span>

Item<span class="operator"> {</span>
   width<span class="operator">:</span><span class="int"> 400</span>
   height<span class="operator">:</span><span class="int"> 300</span>
   Row<span class="operator"> {</span>
      height<span class="operator">:</span><span class="int"> 20</span>
      spacing<span class="operator">:</span><span class="int"> 20</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Clear"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>clear<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Fetch All"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxFetchAll_<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Save"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxSave_<span class="operator">()
      }
   }</span>
   ListView<span class="operator"> {</span>
      y<span class="operator">:</span><span class="int"> 30</span>
      height<span class="operator">:</span><span class="int"> 270</span>
      model<span class="operator">:</span> myModel
      delegate<span class="operator">:</span> Row<span class="operator"> {</span>
         height<span class="operator">:</span><span class="int"> 20</span>
         spacing<span class="operator">:</span><span class="int"> 10</span>
         Text<span class="operator"> {</span> text<span class="operator">:</span><span class="string"> "id: "</span><span class="operator"> +</span> author_id<span class="operator"> }</span>
         TextField<span class="operator"> {</span>
            text<span class="operator">:</span> name
            onTextChanged<span class="operator">:</span> name<span class="operator"> =</span> text<span class="operator">
         }
      }
   }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Ce qui donne le résultat suivant à l'exécution :<br/>
           <br/>
           <img alt="qx_model_view_02" src="./resource/qx_model_view_02.png" border="0" /><br/>
           <br/>
           Comme on peut le constater dans le fichier '<i>main.qml</i>', les propriétés '<i>author_id</i>' et '<i>name</i>' du modèle '<i>author</i>' (variable <i>myModel</i>) sont accessibles automatiquement en lecture/écriture (car elles ont été enregistrées dans le contexte QxOrm).<br/>
           De plus, l'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une liste de méthodes accessibles en QML (utilisation de <i>Q_INVOKABLE</i>) pour communiquer directement avec la base de données : ainsi, le bouton '<i>Save</i>' de l'écran ci-dessus enregistre le modèle en base de données depuis QML.<br/>
           <br/>
           <b>Remarque :</b> un plugin de <b>QxEntityEditor</b> permet de générer automatiquement le code des modèles pour la gestion des relations. Il est ainsi possible de travailler avec des modèles imbriqués.<br/>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2017 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
