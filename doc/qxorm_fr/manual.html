<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Accueil</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Téléchargement</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Exemple rapide</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutoriel (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manuel (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">Manuel QxOrm</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">Manuel QxEntityEditor</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Nos clients</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Manuel d'utilisation de la bibliothèque QxOrm</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Version courante :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.4.8 - <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a> - <a href="https://github.com/QxOrm/QxOrm" target="_blank">GitHub</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.6</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/manual.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/manual.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
      <script>$(function() { initQxOrmManualWebPage(); });</script>
      <table border="0" cellpadding="4">
       <col><col>
       <tbody>
         <tr>
           <td><font class="txt_with_shadow" color="#0B0B61" size="4"><i>Sélection du manuel : </i></font></td>
           <td align="left">
             <a href="./manual.html" class="btn_tuto_selected">Manuel QxOrm</a>
             <a href="./manual_qxee.html" class="btn_tuto">Manuel QxEntityEditor</a>
           </td>
         </tr>
       </tbody>
      </table>
      <hr style="width: 100%" align="center" size="1" color="#100D5A">
      <br>
      <table border="0" style="width: 100%" align="center">
      <col><col>
         <tbody>
            <tr>
               <td>
                  <h3 class="txt_slogan"><b>Manuel d'utilisation de la bibliothèque QxOrm - Table des matières</b></h3>
                  <div id="manual_table_of_contents">
                  <ol class="manual_manual_ol_title_1" type="I">
                     <li class="manual_li_title_1">
                        <a href="#manual_10">Introduction</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_100">Bibliothèque QxOrm</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_110">Aperçu rapide de l'application QxEntityEditor</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_120">Convention d'écriture C++ utilisée par la bibliothèque QxOrm</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_20">Installation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_200">Dépendance à Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_210">Dépendance à boost (optionnel)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_220">Fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_230">Compiler la bibliothèque QxOrm (avec qmake ou CMake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_240">Pilotes SQL fournis par Qt (drivers)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_30">Persistance - Object Relational Mapping (ORM)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_300">Définir une classe dans le contexte QxOrm (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3000">Clé primaire autre que le type par défaut "long"</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3010">Clé primaire sur plusieurs colonnes (composite key)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3020">Données membres public/protected/private</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3030">Espace de nom (namespace)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3040">Types C++ supportés par QxOrm</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3050">Définir une donnée membre <i>transient</i></a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_310">Connexion à la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_320">Sauvegarder une instance C++ en base de données (insert/update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_340">Supprimer une instance C++ de la base de données (delete)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3400">Suppression logique (soft delete)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_350">Récupérer une instance C++ de la base de données (fetch)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_360">Requêtes SQL</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3610">Appel de procédure stockée ou requête SQL personnalisée</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_370">Transactions (commit, rollback, session)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_380">Moteur de relations</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3800">one-to-many (1-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3810">many-to-one (n-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3820">many-to-many (n-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3830">one-to-one (1-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3840">Requête SQL avec relations</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3850">Sélectionner les colonnes des relations à récupérer et définition des alias SQL</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3855">Ajout SQL dans les clauses LEFT OUTER JOIN / INNER JOIN</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_390">Collections supportées par QxOrm</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3900">Collections de Qt</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3910">Collections de boost</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3920">Collections fournies par l'espace de nom standard std</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3930">qx::QxCollection</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4000">Pointeurs intelligents de Qt</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4010">Pointeurs intelligents de boost</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4020">Pointeurs intelligents fournis par l'espace de nom standard std</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4030">qx::dao::ptr</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_410">Déclencheurs (triggers)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_420">Validation d'une instance C++ (validators)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_430">Gérer la valeur NULL de la base de données</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4300">boost::optional</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4310">QVariant</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_440">Héritage et polymorphisme</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_450">Interface qx::IxPersistable (classe abstraite)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_455">Utiliser le pattern C++ PIMPL (Private Implementation idiom ou d-pointer)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_460">Persister des types personnalisés</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_470">Générer le schéma DDL SQL de la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_475">Associer un type SQL à une classe C++</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_480">Effectuer des requêtes asynchrones à la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_490">Gestion du cache pour sauvegarder des instances C++ (module QxCache)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_500">Travailler avec plusieurs bases de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_510">Déclarer une classe abstraite dans le contexte QxOrm</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_520">Déclarer automatiquement les méta-propriétés de Qt (macro <i>Q_PROPERTY</i>)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_60">Sérialisation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_605">N° version pour assurer une compatibilité ascendante</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_600">Moteur QDataStream de Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_606">Moteur JSON de Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_610">Moteur XML de boost::serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_620">Moteur binaire de boost::serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_630">Autres types de sérialisation proposés par boost</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_640">Cloner une instance C++</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_650">Afficher le détail d'une instance C++ (dump au format XML ou JSON)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_70">Introspection - Réflexion</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_710">Obtenir dynamiquement la valeur d'une donnée membre</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_720">Valoriser dynamiquement une donnée membre</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_730">Appeler dynamiquement une fonction</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_740">Créer une instance C++ dynamiquement</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_750">Parcourir la liste des classes/propriétés enregistrées dans le contexte QxOrm</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_80">Services : transférer la couche de données persistante sur le réseau (module QxService)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_810">Paramètres d'entrée/sortie d'un service (requête/réponse)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_820">Définir les fonctions publiées par un service</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_825">Liste des options disponibles côté serveur</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_826">Paramétrage de la connexion côté client</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_830">Gestion de l'authentification dans un service</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_840">Requêtes client/serveur asynchrones</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_90">Moteur modèle/vue (module QxModelView)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_910">Définir un modèle "simple" (sans relation)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_920">Modèles avec relations (notion de modèles imbriqués)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_940">Intéraction avec les vues QML</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_950">Intéraction avec les vues QtWidget</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_960">Connexion d'un modèle au module QxService</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_95">QxOrm et MongoDB (C++ ODM Object Document Mapper)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_980">Pré-requis : driver <i>libmongoc</i> et <i>libbson</i></a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_981">Paramétrage du fichier <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_982">Connexion à la base de données MongoDB</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_983">Définition d'une classe persistante MongoDB (Collection) dans le contexte QxOrm (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9830">Gestion des clés primaires ObjectId</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_984">Insérer une instance C++ (Document) dans la base de données MongoDB (INSERT)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9840">Insérer une liste d'instances C++ (plusieurs Documents) dans la base de données MongoDB (INSERT)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_986">Mettre à jour une instance C++ (Document) dans la base de données MongoDB (UPDATE)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9860">Mettre à jour une liste d'instances C++ (plusieurs Documents) dans la base de données MongoDB (UPDATE)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_988">Supprimer une instance C++ (Document) de la base de données MongoDB (DELETE)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9880">Supprimer une liste d'instances C++ (plusieurs Documents) de la base de données MongoDB (DELETE)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_990">Récupérer une instance C++ (Document) de la base de données MongoDB (FETCH)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9900">Récupérer une liste d'instances C++ (plusieurs Documents) de la base de données MongoDB (FETCH)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_992">Requêtes JSON</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9920">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9921">Utiliser le moteur d'aggregation MongoDB</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9922">Ajouter des propriétés à la requête de type : 'sort', 'limit', 'skip', etc...</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9923">Exécuter une requête personnalisée</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_993">Moteur de relations (nécessite une version MongoDB 3.6 ou +)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9930">Relations : Embedded vs Referenced</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_994">Création automatique des index</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_96">Serveur web HTTP/HTTPS (module QxHttpServer)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_995">Hello World !</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_996">Paramétrage du serveur web HTTP</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9961">Connexions sécurisées SSL/TLS</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_997">Routage des URL (définir les endpoints / dispatcher)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9962">Routage dynamique des URL</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_856">Récupérer les paramètres de la requête HTTP</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_857">Générer la réponse HTTP</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_998">Sessions (stockage par client côté serveur)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_999">Cookies</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_851">Gestion des fichiers statiques</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_852">Encodage de transfert en bloc (chunked responses)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_853">Requêtes par les API JSON (module QxRestApi)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_854">WebSocket</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_855">Performance (testé avec Apache Benchmark)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_8550">Améliorer les performances avec epoll dispatcher sous Linux</a>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_97">API REST JSON (module QxRestApi)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_971">Principe de fonctionnement</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9710">Cas d'utilisation</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_972">Projet de test qxBlogRestApi (QML et serveur web HTTP)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_973">Récupération de données (fetch/count/exist)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9731">fetch_all</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9732">fetch_by_id</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9733">fetch_by_query</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9734">count</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9735">exist</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_974">Ajout de données (insert)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_975">Mise à jour de données (update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_976">Sauvegarde de données (save)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_977">Suppression de données (delete)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9771">delete_all / destroy_all</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9772">delete_by_query / destroy_by_query</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9773">delete_by_id / destroy_by_id</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_978">Validation de données (validate)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_979">Appel RAW SQL ou procédure stockée</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_961">Appel fonctions natives C++</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_962">Meta-data (structure des classes C++ enregistrées dans le contexte QxOrm)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_963">Envoyer une liste de requêtes JSON</a>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  </div>
               </td>
               <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                  <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
               </td>
            </tr>
         </tbody>
      </table>
      <br>
      <hr width="90%">
      <div id="manual_content">

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_10">Introduction</a></p>
      <div class="manual_div_content_1">
         L'objectif de ce manuel utilisateur est de présenter de manière structurée l'ensemble des fonctionnalités proposées par la bibliothèque <b>QxOrm</b>.
         Ce manuel est destiné aux développeurs et architectes logiciel qui souhaitent gérer une couche de données persistante en C++/Qt.
         Des compétences techniques en C++ et base de données sont requises pour la bonne compréhension de ce document.
         <br><br>
         <b>Remarque :</b> la plupart des fonctionnalités présentées dans ce manuel peuvent être définies rapidement et facilement avec l'application <b>QxEntityEditor</b> (l'éditeur graphique de la bibliothèque <b>QxOrm</b>).
         <a href="./manual_qxee.html">Une documentation dédiée à l'application <b>QxEntityEditor</b> est également disponible.</a>
         <br><br>
         <b>Autre remarque :</b> ce manuel est basé en grande partie sur <a href="./faq.html">l'ancienne FAQ du site QxOrm, toujours accessible en cliquant ici</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_100">Bibliothèque QxOrm</a></p>
         <div class="manual_div_content">
           <b>QxOrm est une bibliothèque C++ open source de gestion de données (Object Relational Mapping, ORM).</b><br>
           <b>QxOrm</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
           <br>
           À partir d'une simple <i>fonction de paramétrage</i> (que l'on peut comparer avec un fichier de mapping XML <a href="http://hibernate.org/" target="_blank"><i>Hibernate</i></a>), vous aurez accès aux fonctionnalités suivantes :
           <ul>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_30">Persistance</a></font></b> : support des bases de données SQLite, MySQL, PostgreSQL, Oracle, MS SQL Server, <a href="./manual.html#manual_95">MongoDB</a> (gestion des relations <i>1-1</i>, <i>1-n</i>, <i>n-1</i> et <i>n-n</i>) ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_60">Sérialisation</a></font></b> des données (flux JSON, binaire et XML) ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_70">Réflexion</a></font></b> (ou <b><font style="background-color:yellow"><a href="./manual.html#manual_70">introspection</a></font></b>) pour accéder dynamiquement aux classes, attributs et invoquer des méthodes ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_96">Serveur web HTTP</a></font></b> : serveur web compatible HTTP 1.1 autonome, performant, multi-plateforme et simple d'utilisation ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_97">API JSON</a></font></b> : interopérabilité avec d'autres technologies que C++/Qt (web services REST, applications QML, langages de script).</li>
           </ul>
           <b>QxOrm</b> est dépendant des excellentes bibliothèques <a href="http://www.qt.io/" target="_blank"><b>Qt</b></a> (compatible à partir de la version 4.5.0) et <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (compatible à partir de la version 1.38, par défaut seuls les fichiers d'en-tête <i>*.hpp</i> sont nécessaires).<br>
           La bibliothèque <b>QxOrm</b> a été retenue pour faire partie du programme <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank"><b>Qt Ambassador</b></a>.
           <br><br>
           Si vous trouvez un bug ou si vous avez une question concernant le fonctionnement de la bibliothèque <b>QxOrm</b>, 
           vous pouvez envoyer un mail à : <u><i>support@qxorm.com</i></u>.<br>
           Un forum (en anglais) dédié à <b>QxOrm</b> est disponible <a href="https://www.qxorm.com/forum/phpbb/" target="_blank">en cliquant ici</a>.<br>
           Vous pouvez également retrouver la communauté française de <b>QxOrm</b> sur <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/bases-donnees/qxorm/" target="_blank">le forum de Developpez.com</a>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_110">Aperçu rapide de l'application QxEntityEditor</a></p>
         <div class="manual_div_content">
           <b>QxEntityEditor</b> est un éditeur graphique pour la bibliothèque <b>QxOrm</b> : <b>QxEntityEditor</b> permet de gérer graphiquement le modèle d'entités.<br>
           <b>QxEntityEditor</b> est multi-plateforme (disponible pour Windows, Linux et Mac OS X) et génère du code natif pour tous les environnements : bureau (Windows, Linux, Mac OS X), embarqué et mobile (Android, iOS, Windows Phone, Raspberry Pi, etc.).<br>
           <a href="./tutorial_4.html">Une vidéo de présentation de l'application <b>QxEntityEditor</b> est disponible</a>.<br>
           <br>
           <b>QxEntityEditor</b> est basé sur un système de plugins et propose diverses fonctionnalités pour importer/exporter le modèle de données :
           <ul>
             <li>génération automatique du code C++ (classes persistantes enregistrées dans le contexte QxOrm) ;</li>
             <li>génération automatique des scripts SQL DDL (schéma de base de données) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
             <li>supporte l'évolution du schéma de base de données pour chaque version d'un projet (<i>ALTER TABLE</i>, <i>ADD COLUMN</i>, <i>DROP INDEX</i>, etc.) ;</li>
             <li>génération automatique des classes C++ de services pour transférer le modèle de données sur le réseau, en utilisant le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>, pour créer rapidement des applications client/serveur ;</li>
             <li>importation automatique des structures de bases de données existantes (par connexion ODBC) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
             <li>parce que chaque projet est différent, QxEntityEditor propose plusieurs outils pour personnaliser les fichiers générés (notamment un moteur javascript et un débogueur intégré).</li>
           </ul>
           <a href="../qxentityeditor/resource/qxee_sample.png" target="_blank"><img alt="QxEntityEditor" src="../qxentityeditor/resource/qxee_sample_small.png" border="0" class="img_with_shadow"></a>
           <br><br>
           <b>QxEntityEditor</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
           <a href="./manual_qxee.html">Un manuel utilisateur dédié à l'application <b>QxEntityEditor</b> est disponible.</a><br>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_120">Convention d'écriture C++ utilisée par la bibliothèque QxOrm</a></p>
         <div class="manual_div_content">
           La bibliothèque <b>QxOrm</b> utilise les <b>conventions d'écriture de code C++</b> suivantes :
           <ul>
              <li>toutes les classes, fonctions, variables, etc... sont définies dans <a href="./resource/qxorm.namespace.qx.jpg"><i>l'espace de nom (namespace) qx</i></a> ;
              </li><li>les macro de QxOrm sont écrites sous la forme <i>QX_...</i> ;
              </li><li>les classes abstraites (ou interfaces) ont le préfixe <i>Ix</i> (par exemple : <i>IxFactory</i> est une interface pour la création d'instances) ;
              </li><li>les autres classes ont le préfixe <i>Qx</i> (par exemple : <i>QxDataMember</i>) ;
              </li><li>les collections d'objets ont pour suffixe <i>X</i> (par exemple : <i>QxDataMemberX</i> est une collection de <i>QxDataMember</i>) ;
              </li><li>les fonctions pour communiquer avec les bases de données se trouvent sous le <a href="./resource/qxorm.namespace.qx.dao.jpg"><i>namespace qx::dao</i></a> (par exemple : <i>qx::dao::fetch_by_id()</i>) ;
              </li><li>les fonctions pour la <i>serialization</i> des données se trouvent sous le <a href="./resource/qxorm.namespace.qx.serialization.jpg"><i>namespace qx::serialization</i></a> (par exemple : <i>qx::serialization::xml::to_file()</i>) ;
              </li><li>le moteur de <i>reflection</i> (ou <i>introspection</i>) est accessible depuis la classe <b><i>qx::QxClassX</i></b> (par exemple <i>qx::QxClassX::invoke()</i> pour invoquer une méthode de classe) ;
              </li><li>les classes de traits se trouvent sous le <a href="./resource/qxorm.namespace.qx.trait.jpg"><i>namespace qx::trait</i></a> (par exemple : <i>qx::trait::is_smart_ptr&lt;T&gt;</i>).
              </li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_20">Installation</a></p>
      <div class="manual_div_content_1">
         La bibliothèque QxOrm est multi-plateforme et peut être installée sur tous types d'environnement : Windows, Linux (Unix), Mac OS X, Android, iOS, Windows Phone, etc...<br>
         <a href="./tutorial_3.html">Un tutoriel complet (avec captures d'écran) pour installer un environnement de développement avec QxOrm sous Windows est disponible en cliquant ici.</a>
         <br><br>
         L'objectif de ce chapitre est de présenter rapidement les différentes étapes à suivre pour installer QxOrm sur tous types d'environnement :
         <ul>
            <li><a href="#manual_200">Téléchargement et installation du framework Qt ;</a></li>
            <li><a href="#manual_210">Téléchargement et installation de la bibliothèque boost (optionnel) ;</a></li>
            <li><a href="#manual_220">Paramétrage du fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) ;</a></li>
            <li><a href="#manual_230">Compilation de la bibliothèque QxOrm (avec qmake ou CMake) ;</a></li>
            <li><a href="#manual_240">Vérification des pilotes SQL fournis par Qt (drivers).</a></li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_200">Dépendance à Qt</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.qt.io/" target="_blank"><img alt="Qt"
                   src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : bibliothèque complète : IHM
                   (<i>QtGui</i>), réseau (<i>QtNetwork</i>), XML (<i>QtXml</i>), base de données
                   (<i>QtSql</i>), etc.<br>
                   La documentation est excellente et le code C++ écrit à partir
                   de cette bibliothèque est à la fois performant et simple de
                   compréhension.<br>
                   Depuis le rachat par Nokia puis Digia et sa nouvelle licence LGPL, Qt est
                   sans contexte la bibliothèque phare du moment.<br>
                   QxOrm est compatible avec les principaux objets définis par Qt
                   : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash,
                   QSharedPointer, QScopedPointer, etc.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de Qt disponible à l'adresse suivante : <a
                   href="http://www.qt.io/"
                   target="_blank">http://www.qt.io/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Remarque :</b> par défaut, la bibliothèque QxOrm dépend uniquement des modules <a href="http://doc.qt.io/qt-5/qtcore-index.html" target="_blank">QtCore</a> et <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql</a>.
           Il est possible d'activer des fonctionnalités supplémentaires grâce au <a href="#manual_220">fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a> : ces nouvelles fonctionnalités peuvent alors ajouter des dépendances à QxOrm.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_210">Dépendance à boost (optionnel)</a></p>
         <div class="manual_div_content">
           Par défaut, la bibliothèque QxOrm dépend uniquement de Qt (<i>QtCore</i> et <i>QtSql</i>).
           L'installation de boost est optionnelle et non requise avec la configuration par défaut.
           <br/>
           <b>Remarque :</b> QxOrm propose 2 niveaux de dépendance à boost en option :
           <ul>
             <li>une dépendance uniquement aux fichiers d'en-têtes de boost (<i>*.hpp</i>) : option de compilation <i>_QX_ENABLE_BOOST</i> ;</li>
             <li>une dépendance au module <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost serialization</a> : option de compilation <i>_QX_ENABLE_BOOST_SERIALIZATION</i>.</li>
           </ul>
           <br/>
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.boost.org/" target="_blank"><img alt="boost"
                   src="./resource/logo_boost.jpg" width="161"
                 height="50" border="0"></a></td>
              <td align="justify"><b>boost</b> : de nombreux modules de la
                bibliothèque boost font partie de la nouvelle norme C++.<br>
                C'est une bibliothèque reconnue pour sa qualité, son code 'C++
                moderne', sa documentation, sa portabilité, etc...<br>
                QxOrm utilise les fonctionnalités suivantes de boost :
                <i>smart_pointer, type_traits,
                multi_index_container, unordered_container, any, tuple,
                foreach, function.</i> Toutes ces fonctionnalités sont <i>header only</i>, la dépendance au module <i>serialization</i> est optionnelle.<br>
                Il est conseillé d'installer et d'utiliser la dernière version
                de boost disponible à l'adresse suivante : <a href="http://www.boost.org/" target="_blank">http://www.boost.org/</a> </td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Remarque importante :</b> avec l'option de compilation <i>_QX_ENABLE_BOOST</i>, la bibliothèque QxOrm dépend uniquement des fichiers d'en-tête <i>*.hpp</i> de boost (utilisation des bibliothèques <i>header only</i> uniquement).
           L'installation de boost est donc très simple puisqu'il suffit de dézipper le package boost (pour disposer des fichiers d'en-tête <i>*.hpp</i>).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_220">Fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a></p>
         <div class="manual_div_content">
            Le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) est divisé en plusieurs sections (chacune étant commentée) et regroupe les différents paramétrages et options de compilation disponibles.
            Il est fortement recommandé de lire attentivement le fichier de configuration <i>QxOrm.pri</i> avant de compiler la bibliothèque QxOrm.
            Il est possible de conserver le paramétrage par défaut, seule la variable <b>QX_BOOST_INCLUDE_PATH</b> est nécessaire si votre projet utilise le framework boost : cette variable indique où trouver les fichiers d'en-tête <i>*.hpp</i> de la bibliothèque boost :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>isEmpty(QX_BOOST_INCLUDE_PATH) { QX_BOOST_INCLUDE_PATH = $$quote(<font style="background-color:yellow">D:/Dvlp/_Libs/Boost/1_57/include</font>) }</i>   </pre>
            </td></tr></tbody></table>
            <br>
            Si vous ne souhaitez pas modifier le fichier de configuration <i>QxOrm.pri</i>, il est possible de définir une variable d'environnement nommée <b>BOOST_INCLUDE</b> : cette variable d'environnement sera alors utilisée automatiquement pour valoriser <b>QX_BOOST_INCLUDE_PATH</b> (lire le fichier <i>QxOrm.pri</i> pour plus d'informations).
            <br><br>
            Voici une liste non exhaustive des différentes options de compilation disponibles (lire le fichier de configuration <i>QxOrm.pri</i> pour plus de détails), aucune n'étant activée par défaut :
            <ul>
               <li><b>_QX_ENABLE_BOOST :</b> ajoute une dépendance aux fichiers d'en-têtes de boost (<i>*.hpp</i>), support des classes <i>boost::shared_ptr</i>, <i>boost::optional</i>, <i>boost::container</i>, etc... ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION :</b> active <a href="#manual_610">les fonctionnalités de sérialisation avec le module boost::serialization</a>. Cette option nécessite la compilation du binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> et ajoute donc une dépendance à QxOrm ;</li>
               <br>
               <li><b>_QX_ENABLE_QT_GUI :</b> support de la sérialisation des types du module <a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a> : <i>QBrush, QColor, QFont, QImage, QMatrix, QPicture, QPixmap, QRegion</i>. Cette option ajoute une dépendance à QxOrm (<a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a>) ;</li>
               <li><b>_QX_ENABLE_QT_NETWORK :</b> active <a href="#manual_80">le module QxService</a> pour transférer la couche de données persistante sur le réseau (application client/serveur). Cette option ajoute une dépendance à QxOrm (<a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a>) ;</li>
               <li><b>_QX_NO_PRECOMPILED_HEADER :</b> désactive l'utilisation d'un en-tête précompilé (permet de réduire les temps de compilation d'un projet) : cette option est nécessaire pour <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56926" target="_blank">contourner un bug des versions récentes de MinGW</a>, pour tous les autres compilateurs il est recommandé de travailler avec un <i>precompiled header</i> ;</li>
               <li><b>_QX_NO_RTTI :</b> permet de compiler QxOrm et les projets dépendants sans <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">les informations de type C++ RTTI</a> ;</li>
               <li><b>_QX_STATIC_BUILD :</b> permet de compiler la bibliothèque QxOrm en mode statique ;</li>
               <li><b>_QX_UNITY_BUILD :</b> réduit les temps de compilation de la bibliothèque QxOrm en utilisant le concept <i>unity build</i> : un seul fichier source <i>all.cpp</i> à compiler. Il est recommandé d'activer cette option avec <a href="https://cmake.org/" target="_blank">CMake</a> (car ne supporte pas nativement les en-têtes précompilés) ;</li>
               <li><b>_QX_ENABLE_MONGODB :</b> <a href="#manual_95">support de la base de données MongoDB</a>, la bibliothèque QxOrm devient ainsi un ODM (Object Document Mapper).</li>
            </ul>
            <br>
            <b>Remarque :</b> le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) devra être inclus dans tous les projets dépendants de la bibliothèque QxOrm en ajoutant la ligne suivante dans le fichier <i>*.pro</i> du projet :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   include(<i>my_path_to_QxOrm_library</i>/QxOrm.pri)   </pre>
            </td></tr></tbody></table>
            <br>
            <b>Autre remarque :</b> à la place de <i>qmake</i>, il est possible d'utiliser <a href="https://cmake.org/" target="_blank">l'outil de compilation CMake</a> pour configurer et construire la bibliothèque QxOrm.
            CMake propose un outil graphique afin de visualiser et paramétrer les différentes options disponibles :
            <br><br>
            <img alt="QxOrm and CMake" src="./resource/qxorm_cmake.png" />
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_230">Compiler la bibliothèque QxOrm (avec qmake ou CMake)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> utilise le processus <i>qmake</i> de la bibliothèque <b>Qt</b> pour générer les <i>makefile</i> et compiler le projet (il est également possible d'utiliser <a href="https://cmake.org/" target="_blank">l'outil de compilation CMake</a>, un fichier <i>CMakeLists.txt</i> étant fourni avec la bibliothèque QxOrm).<br>
           <i>qmake</i> est multi-plateforme et fonctionne parfaitement sous Windows, Linux (Unix) et Mac OS X.<br>
           Pour compiler <b>QxOrm</b>, il suffit d'exécuter les commandes suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>qmake</i>
   <i>make debug</i>
   <i>make release</i>   </pre>
           </td></tr></tbody></table>
           <br>
           Sous <b>Windows</b>, des fichiers <i>*.vcproj</i> et <i>*.sln</i> sont disponibles pour les éditeurs <b>Microsoft Visual C++</b>.<br>
           Les fichiers <i>*.pro</i> sont lisibles par l'éditeur <b>Qt Creator</b>, et des plugins existent permettant de s'interfacer avec de nombreux éditeurs C++.<br>
           Les fichiers <i>mingw_build_all_debug.bat</i> et <i>mingw_build_all_release.bat</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec le compilateur <b>MinGW</b> sous Windows.<br>
           Les fichiers <i>gcc_build_all_debug.sh</i> et <i>gcc_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec <b>GCC</b> sous <b>Linux</b>.<br>
           Enfin, les fichiers <i>osx_build_all_debug.sh</i> et <i>osx_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests sous <b>Mac OS X</b> (merci à Dominique Billet pour l'écriture des scripts).<br>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_240">Pilotes SQL fournis par Qt (drivers)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> utilise le moteur <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> de <b>Qt</b> basé sur un système de plugin.<br>
           <a href="http://doc.qt.io/qt-5/sql-driver.html" target="_blank">Une liste détaillée des bases de données supportées est disponible sur le site de Qt</a>.<br>
           Le plugin <i>ODBC</i> (<i>QODBC</i>) assure une compatibilité avec de nombreuses bases de données.<br>
           Pour des performances optimales, il est conseillé d'utiliser un plugin spécifique à une base de données :
           <ul>
              <li><i>QMYSQL</i> : MySQL ;</li>
              <li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;</li>
              <li><i>QOCI</i> : Oracle Call Interface Driver ;</li>
              <li><i>QSQLITE</i> : SQLite version 3 ;</li>
              <li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;</li>
              <li><i>QIBASE</i> : Borland InterBase ;</li>
              <li><i>QTDS</i> : Sybase Adaptive Server.</li>
           </ul>
           <b>Remarque :</b> pour se connecter à une base de données <i>Microsoft SQL Server</i>, il est nécessaire d'utiliser le pilote <i>ODBC</i> (plugin <i>QODBC</i>).
           <br><br>
           <b>Autre remarque :</b> la bibliothèque QxOrm supporte également <a href="#manual_95">la base de données MongoDB (C++ ODM Object Document Mapper)</a>.
           <br><br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_30">Persistance - Object Relational Mapping (ORM)</a></p>
      <div class="manual_div_content_1">
         La bibliothèque QxOrm fournit un moteur de persistance des données basé sur le module <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> de Qt.
         Ce moteur de persistance utilise la technique de programmation : <b>Object Relational Mapping (ORM)</b>.
         <br><br>
         <a href="https://fr.wikipedia.org/wiki/Mapping_objet-relationnel" target="_blank">Définition du site Wikipedia :</a> un mapping objet-relationnel (en anglais <i>object-relational mapping</i> ou <i>ORM</i>) est une technique de programmation informatique qui crée l'illusion d'une base de données orientée objet à partir d'une base de données relationnelle en définissant des correspondances entre cette base de données et les objets du langage utilisé. On pourrait le désigner par « correspondance entre monde objet et monde relationnel ».
         Le mapping objet-relationnel consiste à associer une ou plusieurs classes avec une table, et chaque attribut de la classe avec un champ de la table.
         Les frameworks de mapping objet-relationnel permettent d'éliminer la duplication de code dans les opérations <i>CRUD</i>.
         <br><br>
         Pour effectuer cette correspondance entre le monde objet et le monde relationnel, ainsi pour que proposer l'ensemble de ses fonctionnalités, la bibliothèque QxOrm impose l'enregistrement de classes C++ dans le contexte QxOrm.
         Nous allons donc débuter ce chapitre de la façon suivante : <b>comment enregistrer une classe C++ dans le contexte QxOrm ?</b>
         <br><br>
         <b>Remarque :</b> la bibliothèque QxOrm supporte également <a href="#manual_95">la base de données MongoDB (C++ ODM Object Document Mapper)</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_300">Définir une classe dans le contexte QxOrm (mapping)</a></p>
         <div class="manual_div_content">
            Toutes les classes C++ peuvent être enregistrées dans le contexte QxOrm : il n'y a pas besoin de dériver d'un super objet, et vous pouvez écrire vos méthodes de classes et accesseurs sans aucune contrainte.
            Enregistrer une classe C++ dans le contexte QxOrm signifie :
            <ul>
               <li>dans le fichier en-tête <i>*.h</i> contenant la définition de la classe : utilisation de la macro <b>QX_REGISTER_HPP(class_name, base_class, class_version)</b> ;</li>
               <li>dans le fichier source <i>*.cpp</i> contenant l'implémentation de la classe : utilisation de la macro <b>QX_REGISTER_CPP(class_name)</b> ;</li>
               <li>dans le fichier source <i>*.cpp</i> contenant l'implémentation de la classe : spécialisation de la fonction template : <b>void qx::register_class&lt;T&gt;(qx::QxClass&lt;T&gt; & t)</b>.</li>
            </ul>
            Par exemple, voici comment déclarer une classe <i>person</i> avec 4 propriétés enregistrées dans le contexte QxOrm : <i>id</i>, <i>firstName</i>, <i>lastName</i>, <i>birthDate</i> :<br>
            <br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span></font><span class="comment">

/* This macro is necessary to register 'person' class in QxOrm context */
/* param 1 : the current class to register =&gt; 'person' */
/* param 2 : the base class, if no base class, use the qx trait =&gt; 'qx::trait::no_base_class_defined' */
/* param 3 : the class version used by serialization engine to provide 'ascendant compatibility' */</span><span class="pre">

#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="pre">#include <span class="string">"precompiled.h"</span>   <span class="comment">// Precompiled-header with '#include &lt;QxOrm.h&gt;' and '#include "export.h"'</span>
#include <span class="string">"person.h"</span>          <span class="comment">// Class definition 'person'</span>
#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>     <span class="comment">// Automatic memory leak detection and boost serialization export macro</span>
</span>
<font style="background-color:yellow">QX_REGISTER_CPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">)</span></font><span class="comment">   // This macro is necessary to register 'person' class in QxOrm context
</span><span class="keyword">
namespace</span> qx<span class="operator"> {</span><font style="background-color:yellow"><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
  t<span class="operator">.</span>setName<span class="operator">(</span><span class="string">"t_person"</span><span class="operator">)</span>;<span class="comment">               // 'person' C++ class is mapped to 't_person' database table</span>

  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span><span class="comment">               // Register 'person::id' &lt;=&gt; primary key in your database
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span><span class="comment">      // Register 'person::firstName' property mapped to 'first_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span><span class="comment">  // Register 'person::lastName' property mapped to 'last_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span><span class="comment">  // Register 'person::birthDate' property mapped to 'birth_date' database column name
</span><span class="operator">}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> les méthodes <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::id()</a> et <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> retournent une instance de type : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> (classe de base pour l'enregistrement des données membre).
            Grâce à cette instance, il est possible de personnaliser le comportement par défaut proposé par la classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a>, comme par exemple dans le chapitre : <a href="#manual_3050">Définir une donnée membre <i>transient</i></a>.
            <br><br>
            <b>Autre remarque :</b> il est également possible d'enregistrer des méthodes de classe dans le contexte QxOrm (gestion des méthodes <i>static</i> et <i>non static</i>) avec les méthodes <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a>, <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a>, etc...
            Cette fonctionnalité fait partie du <a href="#manual_70">moteur d'introspection</a> de la bibliothèque QxOrm, plus de détails dans le chapitre : <a href="#manual_730">Appeler dynamiquement une fonction</a>.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3000">Clé primaire autre que le type par défaut "long"</a></p>
            <div class="manual_div_content">
               Par défaut, lorsqu'un mapping d'une classe C++ est écrit avec la méthode <i>void qx::register_class&lt;T&gt;</i>, l'identifiant associé à la classe est de type <i>long</i> (clé primaire avec auto-incrémentation dans la base de données).<br>
               <br>
               Il est possible de définir un identifiant d'un autre type en utilisant la macro <b>QX_REGISTER_PRIMARY_KEY</b>.<br>
               Cette macro spécialise le template <i>qx::trait::get_primary_key&lt;T&gt;</i> pour associer un type d'identifiant à une classe C++.<br>
               <br>
               Par exemple, pour définir un identifiant unique de type <i>QString</i> pour la classe C++ <i>myClass</i> (mappée vers une table de la BDD avec une colonne de type <i>VARCHAR</i> pour clé primaire), il suffit d'écrire :
               <i><b>QX_REGISTER_PRIMARY_KEY(myClass, QString)</b></i><br>
               <br>
               Voici un exemple d'utilisation de la macro <b>QX_REGISTER_PRIMARY_KEY</b> avec une classe <i>author</i> possédant un identifiant de type <i>QString</i> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword"> 
class</span> author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- propriétés
</span>   QString  m_id<span class="operator">;</span>
   QString  m_name<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_</span></pre>
               </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3010">Clé primaire sur plusieurs colonnes (composite key)</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> supporte la notion de '<i>multi-columns primary key</i>'.<br>
              L'identifiant de la classe doit être du type suivant :
              <ul>
              <li><i>QPair</i> ou <i>std::pair</i> pour définir deux colonnes ;
              </li><li><i>boost::tuple</i> (ou <i>std::tuple</i>) pour définir de deux à neuf colonnes.
              </li></ul>
              Il est nécessaire d'utiliser la macro <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> pour spécialiser le template et ainsi définir le type d'identifiant sur plusieurs colonnes.<br>
              La liste des noms des colonnes doit être de la forme suivante : '<i>column1|column2|column3|etc.</i>'.<br>
              <br>
              <b>Exemple d'utilisation</b> avec la classe '<i>author</i>' du projet '<i>qxBlogCompositeKey</i>', cette classe possède un identifiant sur trois colonnes :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- clé composée (clé primaire définie sur plusieurs colonnes dans la base de données)
</span>   <font style="background-color:yellow"><span class="keyword">typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="keyword">static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span></font><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- propriétés
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- méthodes d'accès à la clé composée
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- méthodes de modification de la clé composée
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
              </td></tr></tbody></table>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span></font>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3020">Données membres public/protected/private</a></p>
            <div class="manual_div_content">
              Pour enregistrer des membres <i>private</i> ou <i>protected</i> dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>), il faut déclarer les <i>friend class</i> nécessaires.<br>
              Pour simplifier l'écriture avec les <i>template</i> C++, la bibliothèque QxOrm fournit la macro suivante : <b>QX_REGISTER_FRIEND_CLASS(myClass)</b>.<br>
              Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll1/</i> du package QxOrm avec la classe <i>CPerson</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> test<span class="operator"> {</span><span class="keyword">

class</span> QX_DLL1_EXPORT CPerson<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>qx<span class="operator">::</span>test<span class="operator">::</span>CPerson<span class="operator">)</span></font><span class="comment">

   // etc...
</span><span class="operator">
};

}</span><span class="comment"> // namespace test
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3030">Espace de nom (namespace)</a></p>
            <div class="manual_div_content">
              Si une classe est définie dans un espace de nom (<i>namespace</i>), alors une erreur de compilation se produit avec l'utilisation des macros : <b>QX_REGISTER_HPP</b> et <b>QX_REGISTER_CPP</b>.
              Pour éviter ces erreurs de compilation, il est nécessaire d'utiliser les macros suivantes : <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> et <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b>.<br>
              <br>
              Vous trouverez un exemple d'utilisation dans le dossier <i>./test/qxDllSample/dll1/</i> de la distribution de QxOrm avec la classe <i>CPerson</i> définie dans l'espace de nom <i>qx::test</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)   </pre>
              </td></tr></tbody></table>
              <br>
              Les macros <b>QX_REGISTER_COMPLEX_CLASS_NAME...</b> nécessitent un paramètre supplémentaire (dans l'exemple ci-dessus il s'agit du paramètre <i>qx_test_CPerson</i>) afin de créer une variable globale.<br>
              Celle-ci est appelée dès le lancement de l'application.<br>
              La construction de cette instance globale déclare la classe dans <a href="#manual_740">le module <i>QxFactory</i> (modèle de conception fabrique ou design pattern factory)</a>.<br>
              Un objet C++ ne pouvant pas se nommer avec des caractères "<i>::</i>", le paramètre supplémentaire de la macro permet de remplacer tous les "<i>::</i>" par des "<i>_</i>".
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3040">Types C++ supportés par QxOrm</a></p>
            <div class="manual_div_content">
               La bibliothèque QxOrm supporte la plupart des types primitifs du standard C++ et du framework Qt (numériques, booléens, chaines de caractères, date/heure, collections, pointeurs et pointeurs intelligents, etc...).
               Voici un exemple présentant une liste (non exhaustive) de types C++ supportés ainsi que l'association par défaut du type de base de données (format <i>SQLite</i>) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Remarque :</b> il est également possible de persister un type non géré par défaut par la bibliothèque QxOrm. Rendez-vous au chapitre <a href="#manual_460"><b><i>Persister des types personnalisés</i></b></a> pour plus de détails sur cette fonctionnalité.
               <br><br>
               <b>Autre remarque :</b> concernant l'association d'un type C++ avec le type de base de données associé, rendez-vous au chapitre <a href="#manual_475"><b><i>Associer un type SQL à une classe C++</i></b></a> pour plus de détails.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3050">Définir une donnée membre <i>transient</i></a></p>
            <div class="manual_div_content">
               Une donnée membre <i>transient</i> n'est pas associée à une colonne d'une table de la base de données.
               Le <a href="../doxygen/html/group___qx_dao.html" target="_blank">module QxDao</a> ignore donc cette propriété pour toutes les requêtes à la base de données.
               <br><br>
               A quoi sert l'enregistrement d'une donnée membre <i>transient</i> dans le contexte QxOrm ?<br>
               Enregistrer une donnée membre <i>transient</i> dans le contexte QxOrm permet de disposer des autres fonctionnalités de la bibliothèque QxOrm sur cette propriété, comme par exemple : <a href="./manual.html#manual_60">sérialisation</a>, <a href="./manual.html#manual_70">introspection</a>, etc...
               <br><br>
               La méthode <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> dispose d'un paramètre optionnel nommé : <i>bool bDao</i> (par défaut, valeur à <i>true</i>).
               Par exemple, ajoutons une propriété <i>transient</i> nommée <i>age</i> à la classe <i>person</i> (cette propriété n'a pas besoin d'être stockée en base de données puisque nous disposons déjà de la propriété <i>birthDate</i>) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> <font style="background-color:yellow">false</font></span><span class="operator">);
}}</span></pre>
               </td></tr></tbody></table>
               <br>
               Voici une autre façon de définir une propriété <i>transient</i> en récupérant l'instance de type <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setDao<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_310">Connexion à la base de données</a></p>
         <div class="manual_div_content">
            La connexion à la base de données peut être paramétrée avec la classe singleton : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>.<br>
            Voici un exemple de paramétrage à une base de données SQLite nommée <i>test_qxorm.db</i> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlDatabase">
<pre>   <span class="comment">// Init parameters to connect to database</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDriverName<span class="operator">(</span><span class="string">"QSQLITE"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDatabaseName<span class="operator">(</span><span class="string">"./test_qxorm.db"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setHostName<span class="operator">(</span><span class="string">"localhost"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setUserName<span class="operator">(</span><span class="string">"root"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setPassword<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
</pre>
            </td></tr></tbody></table>
            <br>
            Une fois les paramètres de connexion renseignés dans la classe singleton <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>, toutes les opérations avec la base de données effectuées par la bibliothèque QxOrm utiliserons ces paramètres.
            Pour plus d'informations sur les paramètres de connexion à renseigner, il est recommandé de lire <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">la documentation de la classe QSqlDatabase du framework Qt</a>.
            <br><br>
            <b>Remarque :</b> la classe <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> gère automatiquement les appels à la base de données dans différents threads (<i>multi-threading</i>).
            <br><br>
            <b>Autre remarque :</b> il est possible de gérer son propre pool de connexions à la base de données, et de travailler également avec plusieurs bases de données distinctes : rendez-vous dans le chapitre <a href="#manual_500"><b><i>Travailler avec plusieurs bases de données</i></b></a> pour plus d'informations sur cette fonctionnalité.
            <br><br>
            <b>Autre remarque :</b> suivant le pilote SQL renseigné dans les paramètres de connexion, la bibliothèque QxOrm associe automatiquement un générateur SQL.
            Ce générateur SQL permet de gérer les spécificités propres à chaque type de base de données.
            Tous les générateurs SQL héritent de la classe de base : <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a> :
            <ul>
               <li>pilote <i>QMYSQL</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_MySQL</a> ;</li>
               <li>pilote <i>QPSQL</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_PostgreSQL</a> ;</li>
               <li>pilote <i>QSQLITE</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html" target="_blank">qx::dao::detail::QxSqlGenerator_SQLite</a> ;</li>
               <li>pilote <i>QOCI</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html" target="_blank">qx::dao::detail::QxSqlGenerator_Oracle</a> ;</li>
               <li>pour tous les autres pilotes : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html" target="_blank">qx::dao::detail::QxSqlGenerator_Standard</a> (il est possible de créer son propre générateur SQL en écrivant une classe héritant de <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a>) ;</li>
               <li>pour se connecter à une base de données <i>Microsoft SQL Server</i>, on utilise le pilote <i>QODBC</i> : il est alors nécessaire de préciser le générateur SQL à utiliser en appelant la fonction : </li>
            </ul>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="SQL generator">
<pre>   qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxSqlGenerator_ptr pSqlGenerator<span class="operator">;</span>
   pSqlGenerator<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxSqlGenerator_MSSQLServer<span class="operator">());</span>   
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setSqlGenerator<span class="operator">(</span>pSqlGenerator<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_320">Sauvegarder une instance C++ en base de données (insert/update)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour sauvegarder une instance C++ (ou une liste d'instances C++) en base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert</i></a> : insère une instance (ou une liste d'instances) en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_relation</i></a> : insère une instance (ou une liste d'instances) + ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_all_relation</i></a> : insère une instance (ou une liste d'instances) + toutes ses relations en base de données ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update</i></a> : met à jour une instance (ou une liste d'instances) en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_relation</i></a> : met à jour une instance (ou une liste d'instances) + ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_all_relation</i></a> : met à jour une instance (ou une liste d'instances) + toutes ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query</i></a> : met à jour une instance (ou une liste d'instances) en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_relation</i></a> : met à jour une instance (ou une liste d'instances) + ses relations en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_all_relation</i></a> : met à jour une instance (ou une liste d'instances) + toutes ses relations en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized</i></a> : met à jour uniquement les champs modifiés d'une instance (ou d'une liste d'instances) en base de données en utilisant le pattern <i>is dirty</i> et les fonctionnalités de la classe <a href="#manual_4030">qx::dao::ptr</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized_by_query</i></a> : met à jour uniquement les champs modifiés d'une instance (ou d'une liste d'instances) en base de données en utilisant le pattern <i>is dirty</i> et les fonctionnalités de la classe <a href="#manual_4030">qx::dao::ptr</a> et en filtrant avec une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + ses relations ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_all_relation</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + toutes ses relations ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation_recursive</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + toutes les relations sur tous les niveaux : utile pour sauvegarder en 1 commande une structure en arbre par exemple.</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="insert/update">
<pre>   <span class="comment">// Create 3 drugs instances
   // It is possible to use 'boost' and 'Qt' smart pointer : 'boost::shared_ptr', 'QSharedPointer', etc...
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span>
   drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
   drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
   drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span>

   <span class="comment">// Insert some drugs into a container
   // It is possible to use many containers from 'std', 'boost', 'Qt' and 'qx::QxCollection&lt;Key, Value&gt;'
</span><span class="keyword">   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>drug_ptr<span class="operator">&gt;</span> type_lst_drug<span class="operator">;</span>
   type_lst_drug lst_drug<span class="operator">;</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d1<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d2<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d3<span class="operator">);</span><span class="comment">

   // Insert drugs from container to database
   // 'id' property of 'd1', 'd2' and 'd3' are auto-updated
</span>   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>lst_drug<span class="operator">);</span></font><span class="comment">

   // Modify and update the second drug into database
</span>   d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2 modified"</span><span class="operator">;</span>
   d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2 modified"</span><span class="operator">;</span>
   daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>d2<span class="operator">);</span></font>
</pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> toutes les fonctions de <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a> sont flexibles au niveau des paramètres, elles peuvent accepter : une instance, une liste d'instances, un pointeur, un pointeur intelligent, une liste de pointeurs, une liste de pointeurs intelligents, etc... Par exemple :
            <ul>
               <li><i>my_entity t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>my_entity * t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>std::shared_ptr&lt;my_entity&gt; t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>QList&lt;my_entity&gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
               <li><i>QList&lt;std::shared_ptr&lt;my_entity&gt; &gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
            </ul>
            Pour connaitre la liste des collections supportées, rendez-vous dans le chapitre : <a href="#manual_390">Collections supportées par QxOrm</a>.<br>
            Pour connaitre la liste des pointeurs intelligents supportés, rendez-vous dans le chapitre : <a href="#manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a>.<br>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_340">Supprimer une instance C++ de la base de données (delete)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour supprimer une instance C++ (ou une liste d'instances C++) en base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_id</i></a> : supprime de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_all</i></a> : supprime toutes les entrées d'une table de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_query</i></a> : supprime les entrées d'une table de la base de données en fonction d'une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_id</i></a> : supprime de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_all</i></a> : supprime toutes les entrées d'une table de la base de données avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_query</i></a> : supprime les entrées d'une table de la base de données en fonction d'une requête SQL avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="delete">
<pre>   <span class="comment">// Create a drug instance with id '18'
   </span>drug d<span class="operator">;</span> d<span class="operator">.</span>setId<span class="operator">(</span><span class="int">18</span><span class="operator">);</span><span class="comment">

   // Delete the drug with id '18' from database
   </span>QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>d<span class="operator">);</span></font><span class="comment">

   // Delete all drugs from database
   </span>daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>drug<span class="operator">&gt;();</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3400">Suppression logique (soft delete)</a></p>
            <div class="manual_div_content">
              Une suppression logique permet de ne pas effacer de ligne dans une table d'une base de données (contrairement à une suppression physique) : une colonne supplémentaire est ajoutée à la définition de la table pour indiquer que la ligne est supprimée ou non.<br>
              Cette colonne peut contenir soit un booléen (1 signifie ligne supprimée, 0 ou vide signifie ligne non supprimée), soit la date-heure de suppression de la ligne (si vide, la ligne est considérée comme non supprimée).<br>
              Il est donc à tout moment possible de réactiver une ligne supprimée en réinitialisant la valeur à vide dans la table de la base de données.<br>
              <br>
              Pour activer le mécanisme de suppression logique avec la bibliothèque QxOrm, il faut utiliser la classe <a href="../doxygen/html/classqx_1_1_qx_soft_delete.html" target="_blank"><b>qx::QxSoftDelete</b></a> dans la fonction de mapping <i>qx::register_class&lt;T&gt;</i>.<br>
              Voici un exemple d'utilisation avec une classe <i>Bar</i> contenant deux propriétés <i>m_id</i> et <i>m_desc</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span></font>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
              </td></tr></tbody></table>
              <br>
              Les requêtes SQL générées automatiquement par la bibliothèque QxOrm vont prendre en compte ce paramètre de suppression logique pour ajouter les conditions nécessaires (ne pas récupérer les éléments supprimés, ne pas supprimer physiquement une ligne, etc.).<br>
              Par exemple, si vous exécutez les lignes suivantes avec la classe <i>Bar</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
              </td></tr></tbody></table>
              <br>
              Vous obtiendrez les traces suivantes :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id 
                                         AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
              </td></tr></tbody></table>
              <br>
              <b>Remarque :</b> pour supprimer physiquement une ligne de la base de données, il faut utiliser les fonctions : <i>qx::dao::destroy_by_id()</i> et <i>qx::dao::destroy_all()</i>.<br>
              <br>
              <b>Autre remarque :</b> il peut être intéressant de définir au niveau du SGBD un index sur la colonne <i>deleted_at</i> (ou peu importe le nom que vous donnez) afin d'accélérer l'exécution des requêtes SQL.<br>
              <br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_350">Récupérer une instance C++ de la base de données (fetch)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour valoriser automatiquement les propriétés d'une instance C++ (ou d'une liste d'instances C++) en fonction des données d'une table (ou plusieurs tables si des relations sont définies) de la base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_relation</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) + ses relations en fonction de l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_all_relation</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) + toutes ses relations en fonction de l'id passé en paramètre ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all</i></a> : récupère toutes les entrées d'une table de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_relation</i></a> : récupère toutes les entrées d'une table + ses relations de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_all_relation</i></a> : récupère toutes les entrées d'une table + toutes ses relations de la base de données ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query</i></a> : récupère toutes les entrées d'une table de la base de données en fonction d'une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_relation</i></a> : récupère toutes les entrées d'une table de la base de données + ses relations en fonction d'une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_all_relation</i></a> : récupère toutes les entrées d'une table de la base de données + toutes ses relations en fonction d'une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::exist</i></a> : teste l'existence d'un élément (ou d'une liste d'éléments) en base de données en fonction de son identifiant (<i>primary key</i>).</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="fetch">
<pre><span class="comment">   // Fetch drug with id '3' into a new variable
</span>   drug_ptr d<span class="operator">;</span> d<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_360">Requêtes SQL</a></p>
         <div class="manual_div_content">
            La bibliothèque QxOrm fournit plusieurs outils pour effectuer des requêtes à la base de données :
            <ul>
               <li>la classe <a href="#manual_3600">qx::QxSqlQuery (ou son alias qx_query)</a> ;</li>
               <li>la fonction <a href="#manual_3610">qx::dao::execute_query<T>()</a> ;</li>
               <li>la fonction <a href="#manual_3610">qx::dao::call_query()</a>.</li>
            </ul>
            <b>Remarque :</b> QxOrm étant basé sur le module <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> de Qt, il est toujours possible de requêter la base de données en utilisant la classe <a href="http://doc.qt.io/qt-5/qsqlquery.html" target="_blank">QSqlQuery</a> de Qt si les fonctionnalités proposées par QxOrm ne sont pas suffisantes.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a></p>
            <div class="manual_div_content">
              La classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou bien son alias <i>qx_query</i>) permet d'interroger la base de données (trier, filtrer, etc.) de deux manières différentes :
              <ul>
                <li>en écrivant directement la requête SQL ;</li>
                <li>en utilisant des méthodes C++ avec une syntaxe proche du SQL (similaire à ce que propose <a href="http://subsonicproject.com/docs/Simple_Query_Tool" target="_blank">l'excellente bibliothèque SubSonic pour .Net</a>).</li>
              </ul>
              Le principal avantage de la première méthode (écriture manuelle des requêtes SQL) est de pouvoir utiliser certaines optimisations spécifiques à chaque base de données.<br>
              La deuxième méthode (utilisation du code C++ pour générer la requête SQL) permet de mapper automatiquement les paramètres SQL sans utiliser la fonction <i>qx::QxSqlQuery::bind()</i>.<br>
              <br>
              Voici un exemple d'utilisation de la classe <i>qx::QxSqlQuery</i> avec écriture manuelle d'une requête SQL :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx<span class="operator">::</span>QxSqlQuery query<span class="operator">(</span><span class="string">"WHERE author.sex = :sex"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":sex"</span><span class="operator">,</span> author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              La bibliothèque QxOrm supporte trois syntaxes pour l'écriture des paramètres SQL.<br>
              Le type de syntaxe peut être modifié de façon globale à un projet en utilisant la méthode suivante : <i>qx::QxSqlDatabase::getSingleton()->setSqlPlaceHolderStyle()</i>.<br>
              Les trois paramètres possibles pour cette méthode sont :
              <ul>
                <li><i>ph_style_2_point_name</i> : "WHERE author.sex = :sex" (syntaxe par défaut) ;</li>
                <li><i>ph_style_at_name</i> : "WHERE author.sex = @sex" ;</li>
                <li><i>ph_style_question_mark</i> : "WHERE author.sex = ?".</li>
              </ul>
              Voici le même exemple en utilisant les méthodes C++ de la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) pour générer la requête automatiquement :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"author.sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              Cette utilisation de la classe <i>qx::QxSqlQuery</i> présente l'avantage de ne pas avoir à mapper les paramètres de la requête, tout en restant très proche de l'écriture manuelle d'une requête SQL.<br>
              Les paramètres seront automatiquement injectés en utilisant la syntaxe définie de manière globale par la méthode : <i>qx::QxSqlDatabase::getSingleton()->getSqlPlaceHolderStyle()</i>.<br>
              <br>
              Voici un exemple présentant différentes méthodes disponibles avec la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"age"</span><span class="operator">).</span>isGreaterThan<span class="operator">(</span><span class="int">38</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">).</span>isNotEqualTo<span class="operator">(</span><span class="string">"Dupont"</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"first_name"</span><span class="operator">).</span>like<span class="operator">(</span><span class="string">"Alfred"</span><span class="operator">)
     .</span>and_OpenParenthesis<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>isLessThanOrEqualTo<span class="operator">(</span><span class="int">999</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"birth_date"</span><span class="operator">).</span>isBetween<span class="operator">(</span>date1<span class="operator">,</span> date2<span class="operator">)
     .</span>closeParenthesis<span class="operator">()
     .</span>or_<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>in<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 999</span><span class="operator">,</span><span class="int"> 11</span><span class="operator">,</span><span class="int"> 23</span><span class="operator">,</span><span class="int"> 78945</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"is_deleted"</span><span class="operator">).</span>isNotNull<span class="operator">()
     .</span>orderAsc<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="string"> "sex"</span><span class="operator">)
     .</span>limit<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 150</span><span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui produira le code SQL suivant pour les bases de données <i>MySQL</i>, <i>PostgreSQL</i> et <i>SQLite</i> (pour <i>Oracle</i> et <i>SQLServer</i>, le traitement de la méthode <i>limit()</i> est différent) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>WHERE sex<span class="operator"> = :</span>sex_1_0 
AND age<span class="operator"> &gt; :</span>age_3_0 
OR last_name<span class="operator"> &lt;&gt; :</span>last_name_5_0 
OR first_name LIKE<span class="operator"> :</span>first_name_7_0 
AND<span class="operator"> (</span> id<span class="operator"> &lt;= :</span>id_10_0 AND birth_date BETWEEN<span class="operator"> :</span>birth_date_12_0_1 AND<span class="operator"> :</span>birth_date_12_0_2<span class="operator"> )</span> 
OR id IN<span class="operator"> (:</span>id_15_0_0<span class="operator">, :</span>id_15_0_1<span class="operator">, :</span>id_15_0_2<span class="operator">, :</span>id_15_0_3<span class="operator">, :</span>id_15_0_4<span class="operator">)</span> 
AND is_deleted IS NOT NULL 
ORDER BY last_name ASC<span class="operator">,</span> first_name ASC<span class="operator">,</span> sex ASC 
LIMIT<span class="operator"> :</span>limit_rows_count_19_0 OFFSET<span class="operator"> :</span>offset_start_row_19_0</pre>
              </td></tr></tbody></table>
              <br>
              Voici la liste des fonctions et méthodes disponibles pour utiliser la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// avec les fonctions du namespace qx::dao
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxSession
</span>qx<span class="operator">::</span>QxSession<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>fetchByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>update<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>deleteByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>destroyByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxRepository&lt;T&gt;
</span>qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>count<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fetchByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>update<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>deleteByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>destroyByQuery<span class="operator">()</span></pre>
              </td></tr></tbody></table>
              <br>
              <b>Remarque :</b> certaines de ces fonctions ont également deux autres paramètres optionnels :
              <ul>
                <li><i>const QStringList & columns</i> : pour indiquer la liste des colonnes à récupérer (par défaut, toutes les colonnes sont récupérées) ;</li>
                <li><i>const QStringList & relation</i> : pour indiquer les jointures (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i> définies dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>) entre les tables de la base de données (par défaut, aucune relation).</li>
              </ul>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3610">Appel de procédure stockée ou requête SQL personnalisée</a></p>
            <div class="manual_div_content">
              La bibliothèque QxOrm fournit deux fonctions pour appeler une procédure stockée ou une requête SQL personnalisée :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a></li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a></li>
              </ul>
              Le premier paramètre de ces deux fonctions, de type <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou son alias <i>qx_query</i>), correspond à la procédure stockée ou à la requête SQL personnalisée.<br>
              Pour plus d'informations sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i>, rendez-vous sur ce chapitre du manuel utilisateur : <a href="#manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a>.<br>
              <br>
              La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a> est une fonction <i>template</i> : le type T doit être enregistré dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>).<br>
              Toutes les données renvoyées par la procédure stockée ou la requête SQL personnalisée qui pourront être associées aux membres des classes C++ (de type T) seront valorisées automatiquement.<br>
              Une recherche automatique est effectuée sur le nom des champs associés aux données.<br>
              Voici un exemple d'utilisation (disponible dans le projet qxBlog du package QxOrm) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom SQL query or a stored procedure and fetch automatically properties (with a collection of items)
</span>qx_query testStoredProcBis<span class="operator">(</span><span class="string">"SELECT * FROM author"</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>execute_query<span class="operator">(</span>testStoredProcBis<span class="operator">,</span> authorX<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span> qAssert<span class="operator">(</span>authorX<span class="operator">.</span>count<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>authorX<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
              La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> n'est pas une fonction <i>template</i> : les résultats de la requête doivent être parcourus manuellement sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou <i>qx_query</i>).<br>
              Pour récupérer un paramètre de sortie (qui doit être passé à la requête en tant que <i>QSql::Out</i> ou <i>QSql::InOut</i>), il suffit d'utiliser la méthode : <i>QVariant qx::QxSqlQuery::boundValue(const QString & sKey) const;</i>.<br>
              <br>
              Pour parcourir la liste des résultats de la requête, il faut utiliser les méthodes suivantes :
              <ul>
                <li><i>long qx::QxSqlQuery::getSqlResultRowCount() const;</i></li>
                <li><i>long qx::QxSqlQuery::getSqlResultColumnCount() const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, long column) const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, const QString & column) const;</i></li>
                <li><i>QVector qx::QxSqlQuery::getSqlResultAllColumns() const;</i></li>
                <li><i>void qx::QxSqlQuery::dumpSqlResult();</i></li>
              </ul>
              Voici un exemple d'utilisation avec la fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">(</span><span class="string">"CALL MyStoredProc(:param1, :param2)"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param1"</span><span class="operator">,</span><span class="string"> "myValue1"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param2"</span><span class="operator">,</span><span class="int"> 5024</span><span class="operator">,</span> QSql<span class="operator">::</span>InOut<span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>call_query<span class="operator">(</span>query<span class="operator">);</span>
QVariant vNewValue<span class="operator"> =</span> query<span class="operator">.</span>boundValue<span class="operator">(</span><span class="string">":param2"</span><span class="operator">);</span>
query<span class="operator">.</span>dumpSqlResult<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_370">Transactions (commit, rollback, session)</a></p>
         <div class="manual_div_content">
            Une <a href="http://knol.google.com/k/les-transactions-base-de-données" target="_blank"><b>transaction</b></a> est une suite d'opérations effectuées comme une seule unité logique de travail.<br>
            Une fois terminée, la transaction est :
            <ul>
            <li>soit validée (<b>commit</b>), alors toutes les modifications sont faites dans la base de données ;</li>
            <li>soit annulée (<b>rollback</b>), alors toutes les modifications ne sont pas enregistrée.</li>
            </ul>
            La classe <b><a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a></b> de la bibliothèque QxOrm permet de gérer automatiquement les transactions (validation, annulation) en utilisant le mécanisme <a href="http://fr.wikipedia.org/wiki/RAII" target="_blank">C++ RAII</a> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connexion valide à la BDD est assignée à la session et une transaction est démarrée
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD (en utilisant l'opérateur += de la classe qx::QxSession et la connexion de la session)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> une session peut déclencher une exception de type <a href="../doxygen/html/classqx_1_1dao_1_1sql__error.html" target="_blank"><i>qx::dao::sql_error</i></a> lorsqu'une erreur se produit (par défaut, aucune exception n'est déclenchée). Il est possible de paramétrer ce comportement en utilisant :
            <ul>
            <li>soit le constructeur de la classe <i>qx::QxSession</i> (pour une session en particulier) ;</li>
            <li>soit le paramètre du singleton <i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> (pour toutes les sessions).</li>
            </ul>
            <b>Autre remarque :</b> il est important de ne pas oublier de passer la connexion à la base de données de la session à chaque fonction <i>qx::dao::xxx</i> (en utilisant la méthode <i>session.database()</i>).<br>
            De plus, il est possible d'initialiser une session avec sa propre connexion (provenant d'un pool de connexions par exemple) en utilisant le constructeur de la classe <i>qx::QxSession</i>.<br>
            <br>
            La classe <i>qx::QxSession</i> propose également des méthodes de persistance (CRUD), ce qui peut simplifier l'écriture du code C++ suivant les habitudes de programmation.<br>
            Voici le même exemple en utilisant les méthodes de la classe <i>qx::QxSession</i> à la place des fonctions du <i>namespace</i> <i>qx::dao</i> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connexion valide à la BDD est assignée à la session et une transaction est démarrée
</span>  qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD
</span>  session<span class="operator">.</span>insert<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>update<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>fetchById<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>deleteById<span class="operator">(</span>my_object<span class="operator">);</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
</span><span class="flow">  if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_380">Moteur de relations</a></p>
         <div class="manual_div_content">
            La bibliothèque QxOrm fournit un puissant moteur de relations permettant de définir facilement :
            <ul>
               <li>des relations <a href="#manual_3800">one-to-many (1-n)</a> ;</li>
               <li>des relations <a href="#manual_3810">many-to-one (n-1)</a> ;</li>
               <li>des relations <a href="#manual_3820">many-to-many (n-n)</a> ;</li>
               <li>des relations <a href="#manual_3830">one-to-one (1-1)</a> ;</li>
            </ul>
            <b>Remarque :</b> <a href="./tutorial.html">un tutoriel complet sur les relations basé sur le projet de test <i>qxBlog</i></a> (dont les sources sont présentes dans le package QxOrm) est disponible.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3800">one-to-many (1-n)</a></p>
            <div class="manual_div_content">
              Une relation <i>one-to-many (1-n)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToMany()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 3 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation ;</li>
                <li><i>const QString & sForeignKey</i> : clé étrangère définie dans la classe/table liée.</li>
              </ul>
              <br>
              <b>Par exemple : </b> prenons l'exemple d'un <i>author</i> (une personne) qui peut rédiger plusieurs <i>blog</i>
              : nous allons ainsi montrer comment définir une relation de type
              <b><i>one-to-many</i></b>. <br>
              Au niveau base de données, voici les deux tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.author" src="./resource/qxBlog.table.author.jpg"
              width="318" height="118"><br>
              <br>
              Fichier <i>author.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- propriétés
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
               </td></tr></tbody></table>
               <br>
               Fichier <i>author.cpp</i> :<br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span></font>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3810">many-to-one (n-1)</a></p>
            <div class="manual_div_content">
              Une relation <i>many-to-one (n-1)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToOne()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 2 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation (correspond à une colonne de la table dans la base de données).</li>
              </ul>
              <br>
              <b>Par exemple : </b> un <i>comment</i> est associé à un <i>blog</i> et un <i>blog</i> peut
              contenir plusieurs <i>comment</i> : nous allons ainsi montrer comment
              définir une relation de type <b><i>many-to-one</i></b>. <br>
              Au niveau base de données, voici les deux tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.comment"
              src="./resource/qxBlog.table.comment.jpg" width="335" height="116"><br>
              <br>
              Fichier <i>comment.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.h">
<pre><span class="pre">#ifndef _QX_BLOG_COMMENT_H_
#define _QX_BLOG_COMMENT_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT comment<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="comment">
// -- propriétés
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_text<span class="operator">;</span>
   QDateTime   m_dt_create<span class="operator">;</span>
   <font style="background-color:yellow">blog_ptr    m_blog<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   comment<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>comment<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>comment<span class="operator">&gt;</span> comment_ptr<span class="operator">;</span><span class="keyword">
typedef</span> QList<span class="operator">&lt;</span>comment_ptr<span class="operator">&gt;</span> list_comment<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_COMMENT_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              Fichier <i>comment.cpp</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>comment<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "comment_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_text<span class="operator">,</span><span class="string"> "comment_text"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_dt_create<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToOne<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_blog<span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3820">many-to-many (n-n)</a></p>
            <div class="manual_div_content">
              Une relation <i>many-to-many (n-n)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToMany()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 5 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation ;</li>
                <li><i>const QString & sExtraTable</i> : nom de la table supplémentaire permettant de stocker les <i>id</i> de chaque côté des relations ;</li>
                <li><i>const QString & sForeignKeyOwner</i> : clé étrangère définie dans la table supplémentaire pour représenter la classe/table courante ;</li>
                <li><i>const QString & sForeignKeyDataType</i> : clé étrangère définie dans la table supplémentaire pour représenter la classe/table associée à la relation.</li>
              </ul>
              <br>
              <b>Par exemple : </b> une <i>category</i> référence plusieurs <i>blog</i> et un <i>blog</i> peut
              appartenir à plusieurs <i>category</i> : nous allons ainsi montrer
              comment définir une relation de type <b><i>many-to-many</i></b>.
              Ce type de relation implique une table supplémentaire dans la base de
              données pour stocker la liste des <i>id</i> de chaque côté des
              relations. <br>
              Au niveau base de données, voici les trois tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.category"
              src="./resource/qxBlog.table.category.jpg" width="464" height="115"><br>
              <br>
              Fichier <i>category.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.h">
<pre><span class="pre">#ifndef _QX_BLOG_CATEGORY_H_
#define _QX_BLOG_CATEGORY_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT category<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- propriétés
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   category<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>category<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>category<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> QSharedPointer<span class="operator">&lt;</span>category<span class="operator">&gt;</span> category_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> category_ptr<span class="operator">&gt;</span> list_category<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_CATEGORY_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              Fichier <i>category.cpp</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/category.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>category<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>category<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> category<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "description"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToMany<span class="operator">(&amp;</span> category<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "category_blog"</span><span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3830">one-to-one (1-1)</a></p>
            <div class="manual_div_content">
              Une relation <i>one-to-one (1-1)</i> permet de représenter 2 entités distinctes qui partagent le même identifiant en base de données.
              Une relation <i>one-to-one (1-1)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToOne()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 2 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation.</li>
              </ul>
              <br>
              <b>Par exemple :</b> prenons l'exemple d'une table <i>person</i> et d'une autre table <i>author</i> : un <i>author</i> est également une <i>person</i>, les 2 tables pourraient partager le même identifiant en base de données.
              Au niveau base de données, voici les 2 tables qui correspondent (<i>person_id == author_id</i>) :<br>
              <br>
              <img alt="qxBlog.table.person" src="resource/qxBlog.table.person.jpg" width="279" height="118">
              <br><br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3840">Requête SQL avec relations</a></p>
            <div class="manual_div_content">
              La bibliothèque QxOrm supporte quatre types de relations pour lier les classes C++ enregistrées dans le contexte QxOrm : <i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>.<br>
              Pour plus de détails sur la définition de ces relations, il est conseillé de lire <a href="./tutorial.html" target="_blank">le tutoriel qxBlog</a>.<br>
              Nous allons détailler dans cette Q&R les différentes méthodes de récupération des données (module <a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao</a>, fonctions du namespace <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a>) :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query</a> : récupère les données en requêtant une seule table de la base de données (on parle alors de mode <i>lazy fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_all_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_all_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_all_relation</a> : récupère les données en requêtant une table + toutes ses tables liées (soit une requête sur plusieurs tables de la base de données, on parle alors de mode <i>eager fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> : équivalent aux fonctions ci-dessus (mode <i>eager fetch</i>) avec possibilité de préciser les relations à récupérer sur plusieurs niveaux.</li>
              </ul>
              Le premier paramètre des fonctions <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> correspond à la liste des relations à requêter.<br>
              Cette liste de relations peut contenir les éléments suivants :
              <ul>
              <li>identifiant d'une relation : chaque relation possède une clé définie au niveau de la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> ;</li>
              <li>le mot-clé "<i>*</i>" signifie "<i>récupérer toutes les relations définies dans la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> sur un niveau</i>" ;</li>
              <li>le mot-clé "<i>-></i>" signifie jointure de type "<i>LEFT OUTER JOIN</i>" (jointure par défaut de la bibliothèque QxOrm) ;</li>
              <li>le mot-clé "<i>>></i>" signifie jointure de type "<i>INNER JOIN</i>" entre deux tables.</li>
              </ul>
              <b>Remarque :</b> en utilisant le mot-clé "*" pour indiquer "<i>toutes les relations sur un niveau</i>", les appels suivants sont équivalents :
              <ul>
              <li><i>qx::dao::fetch_by_id_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_id_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_by_query_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_query_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_all_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_all_with_all_relation(...)</i>.</li>
              </ul>
              <br>
              <b>Exemple :</b> à partir du tutoriel qxBlog, il est possible de récupérer les données suivantes avec une seule requête :<br>
              <br>
              <b>1-</b> récupérer un <i>blog</i> et son <i>author</i> ;<br>
              <b>2-</b> pour l'<i>author</i> valorisé, récupérer tous les <i>blog</i> qu'il a écrit ;<br>
              <b>3-</b> pour chaque <i>blog</i> que l'<i>author</i> a écrit, récupérer tous les <i>comment</i> associés.<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:180px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Autre exemple :</b> il est également possible de créer une liste de relations à récupérer, comme ceci par exemple :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QStringList relation<span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_category"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_category"</span><span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>relation<span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:270px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, 
       category_7.category_id AS category_7_category_id_0, category_7.name AS category_7_name_0, category_7.description AS category_7_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN category_blog category_blog_7 ON blog.blog_id = category_blog_7.blog_id 
LEFT OUTER JOIN category category_7 ON category_blog_7.category_id = category_7.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Autre exemple :</b> pour récupérer toutes les relations pour un niveau donné, il faut utiliser le mot-clé "*".<br>
              Pour récupérer toutes les données de toutes les relations sur trois niveaux, il faut écrire :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"*-&gt;*-&gt;*"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:620px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, blog_2.author_id AS blog_2_author_id_0_2, 
       author_3.author_id AS author_3_author_id_0, author_3.name AS author_3_name_0, author_3.birthdate AS author_3_birthdate_0, author_3.sex AS author_3_sex_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, comment_6.blog_id AS comment_6_blog_id_0_6, 
       blog_7.blog_id AS blog_7_blog_id_0, blog_7.blog_text AS blog_7_blog_text_0, blog_7.date_creation AS blog_7_date_creation_0, blog_7.author_id AS blog_7_author_id_0_7, 
       author_8.author_id AS author_8_author_id_0, author_8.name AS author_8_name_0, author_8.birthdate AS author_8_birthdate_0, author_8.sex AS author_8_sex_0, 
       comment_9.comment_id AS comment_9_comment_id_0, comment_9.blog_id AS comment_9_blog_id_0, comment_9.comment_text AS comment_9_comment_text_0, comment_9.date_creation AS comment_9_date_creation_0, 
       category_10.category_id AS category_10_category_id_0, category_10.name AS category_10_name_0, category_10.description AS category_10_description_0, 
       category_11.category_id AS category_11_category_id_0, category_11.name AS category_11_name_0, category_11.description AS category_11_description_0, 
       blog_12.blog_id AS blog_12_blog_id_0, blog_12.blog_text AS blog_12_blog_text_0, blog_12.date_creation AS blog_12_date_creation_0, blog_12.author_id AS blog_12_author_id_0_12, 
       author_13.author_id AS author_13_author_id_0, author_13.name AS author_13_name_0, author_13.birthdate AS author_13_birthdate_0, author_13.sex AS author_13_sex_0, 
       comment_14.comment_id AS comment_14_comment_id_0, comment_14.blog_id AS comment_14_blog_id_0, comment_14.comment_text AS comment_14_comment_text_0, comment_14.date_creation AS comment_14_date_creation_0, 
       category_15.category_id AS category_15_category_id_0, category_15.name AS category_15_name_0, category_15.description AS category_15_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN author author_3 ON author_3.author_id = blog_2.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN blog blog_7 ON blog_7.blog_id = comment_6.blog_id 
LEFT OUTER JOIN author author_8 ON author_8.author_id = blog_7.author_id 
LEFT OUTER JOIN comment comment_9 ON comment_9.blog_id = blog_7.blog_id 
LEFT OUTER JOIN category_blog category_blog_10 ON blog_7.blog_id = category_blog_10.blog_id 
LEFT OUTER JOIN category category_10 ON category_blog_10.category_id = category_10.category_id 
LEFT OUTER JOIN category_blog category_blog_11 ON blog.blog_id = category_blog_11.blog_id 
LEFT OUTER JOIN category category_11 ON category_blog_11.category_id = category_11.category_id 
LEFT OUTER JOIN category_blog category_blog_12 ON category_11.category_id = category_blog_12.category_id 
LEFT OUTER JOIN blog blog_12 ON category_blog_12.blog_id = blog_12.blog_id 
LEFT OUTER JOIN author author_13 ON author_13.author_id = blog_12.author_id 
LEFT OUTER JOIN comment comment_14 ON comment_14.blog_id = blog_12.blog_id 
LEFT OUTER JOIN category_blog category_blog_15 ON blog_12.blog_id = category_blog_15.blog_id 
LEFT OUTER JOIN category category_15 ON category_blog_15.category_id = category_15.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3850">Sélectionner les colonnes des relations à récupérer et définition des alias SQL</a></p>
            <div class="manual_div_content">
               Il est parfois nécessaire de ne pas requêter toutes les colonnes d'une table par soucis d'optimisation : en effet, sélectionner les colonnes réellement utilisées par un traitement permet de limiter les flux réseau entre la base de données et l'application C++, ce qui améliore les performances.<br>
               <br>
               Concernant les relations, la bibliothèque QxOrm fournit une syntaxe spécifique pour sélectionner les colonnes à récupérer, sous la forme : <b>my_relation { col_1, col_2, etc... }</b>.
               Si cette syntaxe n'est pas utilisée, par défaut, QxOrm récupère toutes les colonnes.<br>
               <br>
               <b>Par exemple</b> : imaginons la requête suivante qui permet de récupérer :
               <ul>
                  <li>uniquement la colonne <i>blog_text</i> de la table <i>blog</i> ;</li>
                  <li>uniquement les colonnes <i>name</i> et <i>birthdate</i> de la table <i>author</i> ;</li>
                  <li>uniquement la colonne <i>comment_text</i> de la table <i>comment</i>.</li>
               </ul>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre><span class="comment">   // Fetch relations defining columns to fetch with syntax { col_1, col_2, etc... }
</span>   list_blog lstBlogComplexRelation<span class="operator">;</span>
   <font style="background-color:yellow">QStringList relations<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "{ blog_text }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "author_id { name, birthdate }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "list_comment { comment_text }"</span><span class="operator">;</span></font>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all_with_relation<span class="operator">(</span>relations<span class="operator">,</span> lstBlogComplexRelation<span class="operator">);</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lstBlogComplexRelation<span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_creation<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_sex<span class="operator"> ==</span> author<span class="operator">::</span>unknown<span class="operator">);</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_name<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_create<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Remarque :</b> une autre syntaxe est disponible afin de renseigner les colonnes à ne pas récupérer : <b>my_relation -{ col_1, col_2, etc... }</b>.
               <br><br>
               <b>Autre remarque :</b> il est également possible de définir <b>un alias par relation</b> à utiliser dans la requête SQL.
               Ceci est utile pour l'écriture des conditions dans la clause <i>WHERE</i>.
               Un alias SQL peut être défini entre les caractères <b>&lt;</b> <b>&gt;</b>.
               <br><br>
               <b>Exemple :</b> voici un exemple de fetch avec relations en définissant des alias SQL par relation :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre>list_blog lstBlogComplexRelation3;
QStringList relations;
relations &lt;&lt; <span class="string">"<font style="background-color:yellow">&lt;blog_alias&gt;</font> { blog_text }"</span>;
relations &lt;&lt; <span class="string">"author_id <font style="background-color:yellow">&lt;author_alias&gt;</font> { name, birthdate }"</span>;
relations &lt;&lt; <span class="string">"list_comment <font style="background-color:yellow">&lt;list_comment_alias&gt;</font> { comment_text } -&gt; blog_id <font style="background-color:yellow">&lt;blog_alias_2&gt;</font> -&gt; * <font style="background-color:yellow">&lt;..._my_alias_suffix&gt;</font>"</span>;
QSqlError daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation3);
qx::dump(lstBlogComplexRelation3);</pre>
               </td></tr></tbody></table>
               <br><br>
               Ce qui génère la requête SQL suivante :
               <br>
               <div style="width:900px; height:230px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog_alias.blog_id AS blog_alias_blog_id_0, blog_alias.blog_text AS blog_alias_blog_text_0, blog_alias.author_id AS blog_alias_author_id_0, author_alias.author_id AS author_alias_author_id_0, author_alias.name AS author_alias_name_0, author_alias.birthdate AS author_alias_birthdate_0, list_comment_alias.comment_id AS list_comment_alias_comment_id_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0, list_comment_alias.comment_text AS list_comment_alias_comment_text_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0_2, blog_alias_2.blog_id AS blog_alias_2_blog_id_0, blog_alias_2.blog_text AS blog_alias_2_blog_text_0, blog_alias_2.date_creation AS blog_alias_2_date_creation_0, blog_alias_2.author_id AS blog_alias_2_author_id_0_3, author_my_alias_suffix.author_id AS author_my_alias_suffix_author_id_0, author_my_alias_suffix.name AS author_my_alias_suffix_name_0, author_my_alias_suffix.birthdate AS author_my_alias_suffix_birthdate_0, author_my_alias_suffix.sex AS author_my_alias_suffix_sex_0, comment_my_alias_suffix.comment_id AS comment_my_alias_suffix_comment_id_0, comment_my_alias_suffix.blog_id AS comment_my_alias_suffix_blog_id_0, comment_my_alias_suffix.comment_text AS comment_my_alias_suffix_comment_text_0, comment_my_alias_suffix.date_creation AS comment_my_alias_suffix_date_creation_0, comment_my_alias_suffix.blog_id AS comment_my_alias_suffix_blog_id_0_5, category_my_alias_suffix.category_id AS category_my_alias_suffix_category_id_0, category_my_alias_suffix.name AS category_my_alias_suffix_name_0, category_my_alias_suffix.description AS category_my_alias_suffix_description_0
  FROM blog AS <font style="background-color:yellow">blog_alias</font>
  LEFT OUTER JOIN author <font style="background-color:yellow">author_alias</font> ON author_alias.author_id = blog_alias.author_id
  LEFT OUTER JOIN comment <font style="background-color:yellow">list_comment_alias</font> ON list_comment_alias.blog_id = blog_alias.blog_id
  LEFT OUTER JOIN blog <font style="background-color:yellow">blog_alias_2</font> ON blog_alias_2.blog_id = list_comment_alias.blog_id
  LEFT OUTER JOIN author <font style="background-color:yellow">author_my_alias_suffix</font> ON author_my_alias_suffix.author_id = blog_alias_2.author_id
  LEFT OUTER JOIN comment <font style="background-color:yellow">comment_my_alias_suffix</font> ON comment_my_alias_suffix.blog_id = blog_alias_2.blog_id
  LEFT OUTER JOIN category_blog category_blog_6 ON blog_alias_2.blog_id = category_blog_6.blog_id
  LEFT OUTER JOIN category <font style="background-color:yellow">category_my_alias_suffix</font> ON category_blog_6.category_id = category_my_alias_suffix.category_id</span></pre>
               </div>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3855">Ajout SQL dans les clauses LEFT OUTER JOIN / INNER JOIN</a></p>
            <div class="manual_div_content">
               La classe <a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx_query</a>) dispose de la méthode suivante :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlQuery::addJoinQuery()">
<pre>QxSqlQuery & QxSqlQuery::<font style="background-color:yellow">addJoinQuery</font>(const QString & relationKeyOrAlias, const QxSqlQuery & joinQuery);</pre>
               </td></tr></tbody></table>
               <br><br>
               La méthode <i>qx::QxSqlQuery::addJoinQuery()</i> permet d'insérer des sous-requêtes SQL dans les clauses <i>LEFT OUTER JOIN</i> / <i>INNER JOIN</i>.<br>
               Par exemple :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlQuery::addJoinQuery()">
<pre><span class="comment">// Test to add join SQL sub-queries (inside LEFT OUTER JOIN or INNER JOIN)</span>
list_blog lstBlogWithJoinQueries;
qx_query query = qx_query().where(<span class="string">"blog_alias.blog_text"</span>).isEqualTo(<span class="string">"update blog_text_1"</span>);
<font style="background-color:yellow">query.addJoinQuery</font>(<span class="string">"list_comment_alias"</span>, <span class="string">"AND list_comment_alias.comment_text IS NOT NULL"</span>);
<font style="background-color:yellow">query.addJoinQuery</font>(<span class="string">"author_alias"</span>, qx_query().freeText(<span class="string">"AND author_alias.sex = :sex"</span>, QVariantList() &lt;&lt; author::female));
daoError = qx::dao::fetch_by_query_with_relation(QStringList() &lt;&lt; <span class="string">"&lt;blog_alias&gt; { blog_text }"</span> &lt;&lt; <span class="string">"author_id &lt;author_alias&gt; { name, birthdate, sex }"</span> 
                                                               &lt;&lt; <span class="string">"list_comment &lt;list_comment_alias&gt; { comment_text }"</span>, query, lstBlogWithJoinQueries);
qx::dump(lstBlogWithJoinQueries);
qAssert(lstBlogWithJoinQueries.size() &gt; 0);
qAssert(lstBlogWithJoinQueries[0]-&gt;m_text == <span class="string">"update blog_text_1"</span>);
qAssert(lstBlogWithJoinQueries[0]-&gt;m_author-&gt;m_sex == author::female);</pre>
               </td></tr></tbody></table>
               <br><br>
               Le code C++ ci-dessus va construire la requête SQL suivante :
               <br><br>
               <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog_alias.blog_id AS blog_alias_blog_id_0, blog_alias.blog_text AS blog_alias_blog_text_0, blog_alias.author_id AS blog_alias_author_id_0, author_alias.author_id AS author_alias_author_id_0, author_alias.name AS author_alias_name_0, author_alias.birthdate AS author_alias_birthdate_0, author_alias.sex AS author_alias_sex_0, list_comment_alias.comment_id AS list_comment_alias_comment_id_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0, list_comment_alias.comment_text AS list_comment_alias_comment_text_0
  FROM blog AS blog_alias
  LEFT OUTER JOIN author author_alias ON (author_alias.author_id = blog_alias.author_id
      <font style="background-color:yellow">AND author_alias.sex = :sex</font>)
  LEFT OUTER JOIN comment list_comment_alias ON (list_comment_alias.blog_id = blog_alias.blog_id
      <font style="background-color:yellow">AND list_comment_alias.comment_text IS NOT NULL</font>)
  WHERE blog_alias.blog_text = :blog_alias_blog_text_1_0</span></pre>
               </div>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_390">Collections supportées par QxOrm</a></p>
         <div class="manual_div_content">
            QxOrm supporte de nombreux conteneurs livrés avec <a href="#manual_3900">Qt</a>, <a href="#manual_3910">boost</a> ou la <a href="#manual_3920">bibliothèque standard std</a>.
            La bibliothèque QxOrm fournit également son propre conteneur, nommé <a href="#manual_3930">qx::QxCollection</a>, particulièrement adapté pour stocker les données issues d'une base de données.
            Le développeur a donc à sa disposition un large choix : QxOrm n'impose aucune contrainte sur l'utilisation des collections.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3900">Collections de Qt</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt collections">
<pre>
  QList&lt;T&gt;  
  QVector&lt;T&gt;  
  QSet&lt;T&gt;  
  QLinkedList&lt;T&gt;  
  QHash&lt;Key, Value&gt;  
  QMap&lt;Key, Value&gt;  
  QMultiHash&lt;Key, Value&gt;  
  QMultiMap&lt;Key, Value&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3910">Collections de boost</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost collections">
<pre>
  boost::unordered_map&lt;Key, Value&gt;  
  boost::unordered_set&lt;T&gt;  
  boost::unordered_multimap&lt;Key, Value&gt;  
  boost::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3920">Collections fournies par l'espace de nom standard std</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std collections">
<pre>
  std::list&lt;T&gt;  
  std::vector&lt;T&gt;  
  std::set&lt;T&gt;  
  std::map&lt;Key, Value&gt;  

  std::unordered_map&lt;Key, Value&gt;  
  std::unordered_set&lt;T&gt;  
  std::unordered_multimap&lt;Key, Value&gt;  
  std::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3930">qx::QxCollection</a></p>
            <div class="manual_div_content">
              Il existe de nombreux <i>container</i> dans les bibliothèques <b>stl</b>, <b>boost</b> et <b>Qt</b>.<br>
              Il est donc légitime de se poser cette question : à quoi sert <i>qx::QxCollection&lt;Key, Value&gt;</i> ?<br>
              <i><a href="../doxygen/html/classqx_1_1_qx_collection.html" target="_blank">qx::QxCollection&lt;Key, Value&gt;</a></i> est un nouveau <i>container</i> (basé sur l'excellente bibliothèque <a href="http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a>) qui possède les fonctionnalités suivantes :
              <ul><li>conserve l'ordre d'insertion des éléments dans la liste ;
              </li><li>accès rapide à un élément par son index : équivaut à <i>std::vector&lt;T&gt;</i> ou <i>QList&lt;T&gt;</i> par exemple ;
              </li><li>accès rapide à un élément par une clé (<i>hash-map</i>) : équivaut à <i>QHash&lt;Key, Value&gt;</i> ou <i>boost::unordered_map&lt;Key, Value&gt;</i> par exemple ;
              </li><li>fonctions de tri sur le type <i>Key</i> et sur le type <i>Value</i> ;
              </li><li>thread-safe.
              </li></ul>
              <b>Remarque :</b>
              <i>qx::QxCollection&lt;Key, Value&gt;</i> est compatible avec la macro <i>foreach</i> fournie par la bibliothèque <b>Qt</b> ainsi que par la macro <a href="http://www.boost.org/doc/libs/release/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> fournie par la bibliothèque <b>boost</b>.<br>
              Cependant, chaque élément renvoyé par ces deux macros correspond à un objet de type <i>std::pair&lt;Key, Value&gt;</i>.<br>
              Pour obtenir un résultat 'plus naturel' et plus lisible, il est conseillé d'utiliser la macro <i>_foreach</i> : cette macro utilise <i>BOOST_FOREACH</i> pour tous les <i>container</i> sauf pour <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              Dans ce cas, l'élément renvoyé correspond au type <i>Value</i> (voir par la suite l'exemple d'utilisation).<br>
              La macro <i>_foreach</i> est donc compatible avec tous les <i>container</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>, etc.) puisqu'elle utilise la macro <i>BOOST_FOREACH</i>.<br><br>
              <b>Autre Remarque :</b>
              <i>qx::QxCollection&lt;Key, Value&gt;</i> est particulièrement adapté pour recevoir des données issues d'une base de données.<br>
              En effet, ces données peuvent être triées (en utilisant <i>ORDER BY</i> dans une requête SQL par exemple), il est donc important de conserver l'ordre d'insertion des éléments dans la liste.<br>
              De plus, chaque donnée issue d'une base de données possède un identifiant unique. Il est donc intéressant de pouvoir accéder à un élément en fonction de cet identifiant unique de manière extrèmement rapide (<i>hash-map</i>).<br><br>
              <b>Exemple d'utilisation de la collection <i>qx::QxCollection&lt;Key, Value&gt;</i> :</b><br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* définition d'une classe drug avec 3 propriétés : 'code', 'name', 'description' */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* pointeur intelligent associé à la classe drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection de drugs (accès rapide à un élément de la collection par la propriété 'code') */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* création de 3 nouveaux drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insertion des 3 drugs dans la collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* parcours la collection en utilisant le mot-clé '_foreach' */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* parcours la collection en utilisant une boucle 'for' */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* parcours la collection en utilisant le style Java avec 'QxCollectionIterator' */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* effectue un tri croissant par clé (propriété 'code') et décroissant par valeur */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son 'code' */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son index (position) dans la collection */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* teste si un drug existe dans la collection et si la liste est vide */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* supprime de la collection le 2ème élément */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* supprime de la collection l'élément avec le code 'code3' */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* efface tous les éléments de la collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a></p>
         <div class="manual_div_content">
            QxOrm supporte de nombreux pointeurs intelligents livrés avec <a href="#manual_4000">Qt</a>, <a href="#manual_4010">boost</a> ou la <a href="#manual_4020">bibliothèque standard std</a>.
            La bibliothèque QxOrm fournit également son propre pointeur intelligent, nommé <a href="#manual_4030">qx::dao::ptr</a>, apportant de nouvelles fonctionnalités lorsqu'il est utilisé avec les fonctions de <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.
            Le développeur a donc à sa disposition un large choix : QxOrm n'impose aucune contrainte sur l'utilisation des pointeurs intelligents.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4000">Pointeurs intelligents de Qt</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt smart pointers">
<pre>
  QSharedPointer&lt;T&gt;  
  QScopedPointer&lt;T&gt;  
  QWeakPointer&lt;T&gt;  
  QSharedDataPointer&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4010">Pointeurs intelligents de boost</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost smart pointers">
<pre>
  boost::shared_ptr&lt;T&gt;  
  boost::intrusive_ptr&lt;T&gt;  
  boost::scoped_ptr&lt;T&gt;  
  boost::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4020">Pointeurs intelligents fournis par l'espace de nom standard std</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std smart pointers">
<pre>
  std::shared_ptr&lt;T&gt;  
  std::unique_ptr&lt;T&gt;  
  std::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4030">qx::dao::ptr</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> est compatible avec les pointeurs intelligents des bibliothèques <b>boost</b> et <b>Qt</b>.<br>
              Le pointeur intelligent développé par <b>QxOrm</b> est basé sur <i>QSharedPointer</i> et apporte de nouvelles fonctionnalités s'il est utilisé avec les fonctions '<i>qx::dao::...</i>'.<br>
              <i><a href="../doxygen/html/classqx_1_1dao_1_1ptr.html" target="_blank">qx::dao::ptr&lt;T&gt;</a></i> conserve automatiquement les valeurs issues de la base de données.<br>
              Il est ainsi possible de vérifier à tout moment si une instance d'objet a subi des modifications grâce à la méthode '<i>isDirty()</i>' : cette méthode peut renvoyer la liste de toutes les propriétés ayant été modifiées.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> peut également être utilisé par la fonction '<i>qx::dao::update_optimized()</i>' pour mettre à jour en base de données uniquement les champs modifiés.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> peut être utilisé avec un objet simple ou bien avec la plupart des containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> et <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              <br>
              <b>Exemple d'utilisation du pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> :</b><br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// exemple d'utilisation de la méthode 'isDirty()'
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour uniquement la propriété 'm_text' de l'instance 'blog_isdirty'
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

// exemple d'utilisation de la méthode 'isDirty()' avec une liste d'objets
</span><span class="keyword">typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour la propriété 'm_name' en position 1, la propriété 'm_birthdate' en position 2 et ne change rien en position 0
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

// récupère uniquement la propriété 'm_dt_creation' du blog
</span>QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
{</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_410">Déclencheurs (triggers)</a></p>
         <div class="manual_div_content">
           Les <i>Trigger</i> de <b>QxOrm</b> permettent d'effectuer divers traitements avant et/ou après une insertion, une mise à jour ou bien une suppression dans la base de données.<br>
           Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.<br>
           Cette classe contient cinq propriétés : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> et <i>m_userModification</i>.<br>
           Ces propriétés se mettront à jour automatiquement pour chaque classe héritant de <i>BaseClassTrigger</i> (cf. les classes <i>Foo</i> et <i>Bar</i> du même projet).<br>
           Il est nécessaire de spécialiser le template '<i>qx::dao::detail::QxDao_Trigger&lt;T&gt;</i>' pour profiter de cette fonctionnalité.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span>

   <font style="background-color:yellow"><span class="type">void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>
   <font style="background-color:yellow"><span class="type">void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span>
<font style="background-color:yellow"><span class="keyword">struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;</span></font>
<span class="operator">{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }
   static inline</span><span class="type"> void</span> onAfterFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_420">Validation d'une instance C++ (validators)</a></p>
         <div class="manual_div_content">
            Le module <b><a href="../doxygen/html/group___qx_validator.html" target="_blank">QxValidator</a></b> de la bibliothèque <b>QxOrm</b> permet d'ajouter des contraintes sur les propriétés enregistrées dans le contexte QxOrm.<br>
            Ces contraintes sont définies dans la méthode de mapping : <i>void qx::register_class&lt;T&gt;</i>.<br>
            Si pour une instance de classe donnée, au moins une contrainte n'est pas respectée, alors l'instance est considérée comme invalide : l'objet ne peut alors pas être sauvegardé en base de données (<i>INSERT</i> ou <i>UPDATE</i>).<br>
            <br>
            Il est également possible d'utiliser le module <b>QxValidator</b> pour valider les données au niveau de la couche présentation de l'application : si les données saisies par un utilisateur ne sont pas valides, un message d'erreur peut être signalé, il n'est alors pas nécessaire d'essayer d'enregistrer l'instance courante en base de données.<br>
            Les règles de validation n'ont pas besoin d'être dupliquées : elles peuvent être utilisées aussi bien par la couche présentation que par la couche d'accès aux données de l'application.<br>
            <br>
            Voici la description de quelques classes du module <b>QxValidator</b> :
            <ul>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator.html" target="_blank">qx::IxValidator</a> : chaque contrainte définie dans la fonction de mapping <i>void qx::register_class&lt;T&gt;</i> est associée à une interface de type <i>qx::IxValidator</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator_x.html" target="_blank">qx::IxValidatorX</a> : pour une classe donnée, la liste des contraintes est associée à une interface de type <i>qx::IxValidatorX</i>. Cette collection peut être parcourue à l'exécution du programme : ça peut être intéressant par exemple pour générer le schéma DDL SQL et prendre en compte les contraintes au niveau de la base de données (voir le chapitre suivant du manuel utilisateur : <a href="#manual_470">Générer le schéma DDL SQL de la base de données</a>) ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value_x.html" target="_blank">qx::QxInvalidValueX</a> : au moment du processus de validation, lorsqu'une instance n'est pas valide, la liste des contraintes non respectées est représentée par une collection de type <i>qx::QxInvalidValueX</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value.html" target="_blank">qx::QxInvalidValue</a> : chaque élément de cette collection est de type <i>qx::QxInvalidValue</i> et contient un message d'erreur (description expliquant pourquoi l'instance est invalide).</li>
            </ul>
            Le module <b>QxValidator</b> gère automatiquement la notion d'héritage de classe : si des contraintes sont définies au niveau de la classe de base, alors elles seront automatiquement vérifiées pour chaque validation d'une classe dérivée.<br>
            <br>
            Voici un exemple d'utilisation du module <b>QxValidator</b> avec une classe '<i>person</i>' :<br>
            <br>
            * fichier '<i>person.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _CLASS_PERSON_H_
#define _CLASS_PERSON_H_
</span><span class="keyword"> 
class</span> person<span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span><span class="keyword">

   enum</span> sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="type">

   long</span>        _id<span class="operator">;</span>
   QString     _firstName<span class="operator">;</span>
   QString     _lastName<span class="operator">;</span>
   QDateTime   _birthDate<span class="operator">;</span>
   sex         _sex<span class="operator">;</span>

   person<span class="operator">() :</span> _id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span>
   person<span class="operator">(</span><span class="type">long</span> id<span class="operator">) :</span> _id<span class="operator">(</span>id<span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span>

   <font style="background-color:yellow"><span class="type">void</span> isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _CLASS_PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>person.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/person.h"
#include "../include/global_validator.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_MY_EXE<span class="operator">(</span>person<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_firstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_lastName<span class="operator">,</span><span class="string"> "lastName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_birthDate<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">QxValidatorX<span class="operator">&lt;</span>person<span class="operator">&gt; *</span> pAllValidator<span class="operator"> =</span> t<span class="operator">.</span>getAllValidator<span class="operator">();</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"lastName"</span><span class="operator">,</span><span class="string"> "a person must have a lastname"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator<span class="operator">(&amp;</span> person<span class="operator">::</span>isValid<span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_QVariant<span class="operator">(&amp;</span> validateFirstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_DataType<span class="operator">&lt;</span>QDateTime<span class="operator">&gt;(&amp;</span> validateDateTime<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span></font>
<span class="operator">}}</span>

<font style="background-color:yellow"><span class="type">void</span> person<span class="operator">::</span>isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)</span></font>
<span class="operator">{</span><span class="comment">
   // Cette méthode est appelée automatiquement par le module 'QxValidator' :
   // - avant d'insérer ou mettre à jour une instance de type 'person' par les fonctions du namespace 'qx::dao' ;
   // - en utilisant la fonction 'qx::validate()' avec pour paramètre une instance de type 'person'.

   // L'enregistrement de la méthode 'person::isValid()' est effectué dans la fonction de mapping :
   // pAllValidator-&gt;add_CustomValidator(&amp; person::isValid);

   // Dans cette méthode, il est possible de vérifier n'importe quelle valeur de l'instance courante
   // Si une propriété est non valide, il suffit d'insérer un élément dans la collection 'invalidValues'

   // Remarque : cette méthode est déclarée 'private' pour forcer l'utilisateur à utiliser la fonction 'qx::validate()'
   // Mais ce n'est pas une obligation : cette méthode peut être déclarée 'public' ou 'protected'

   // Par exemple, si on souhaite vérifier la propriété '_sex' d'une personne :
</span><span class="flow">   if</span><span class="operator"> ((</span>_sex<span class="operator"> !=</span> male<span class="operator">) &amp;&amp; (</span>_sex<span class="operator"> !=</span> female<span class="operator">))
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"le sexe de la personne doit être défini : masculin ou féminin"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>global_validator.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Les fonctions suivantes ('validateFirstName()' et 'validateDateTime()') sont globales (non liées à une classe)
// Elles peuvent ainsi être utilisées par plusieurs classes pour valider une propriété (par exemple : valider la saisie d'une adresse IP).
// Ces fonctions seront appelées automatiquement par le module 'QxValidator' :
// - avant d'insérer ou mettre à jour une instance de classe par les fonctions du namespace 'qx::dao' ;
// - en utilisant la fonction 'qx::validate()'.
</span><span class="type"> 
void</span> validateFirstName<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (convertie en type QVariant)
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la valeur ne doit jamais être égale à "admin" :
</span><span class="flow">   if</span><span class="operator"> (</span>value<span class="operator">.</span>toString<span class="operator">() ==</span><span class="string"> "admin"</span><span class="operator">)
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la valeur ne peut pas être égale à 'admin'"</span><span class="operator">); }
}</span><span class="type">

void</span> validateDateTime<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (en conservant son vrai type, ici il s'agit de tester une date-heure de type 'QDateTime')
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la date-heure doit forcément être renseignée :
</span><span class="flow">   if</span><span class="operator"> (!</span> value<span class="operator">.</span>isValid<span class="operator">())
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la date-heure doit être renseignée et doit être valide"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>main.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>person personValidate<span class="operator">;</span>
personValidate<span class="operator">.</span>_lastName<span class="operator"> =</span><span class="string"> "admin"</span><span class="operator">;</span>
qx<span class="operator">::</span>QxInvalidValueX invalidValues<span class="operator"> =</span> qx<span class="operator">::</span>validate<span class="operator">(</span>personValidate<span class="operator">);</span>
QString sInvalidValues<span class="operator"> =</span> invalidValues<span class="operator">.</span>text<span class="operator">();</span>
qDebug<span class="operator">(</span><span class="string">"[QxOrm] test 'QxValidator' module :\n%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sInvalidValues<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            A l'exécution de ce bout de code, l'instance '<i>personValidate</i>' est non valide : la collection '<i>invalidValues</i>' contient quatre éléments :<br>
            - "<i>la valeur de la propriété 'firstName' ne peut pas être vide</i>" ;<br>
            - "<i>le sexe de la personne doit être défini : masculin ou féminin</i>" ;<br>
            - "<i>la valeur ne peut pas être égale à 'admin'</i>" ;<br>
            - "<i>la date-heure doit être renseignée et doit être valide</i>".<br>
            <br>
            Le module <b>QxValidator</b> fournit plusieurs validateurs pour effectuer des vérifications basiques :
            <ul>
                <li><i>add_NotNull()</i> : vérifie que la valeur n'est pas nulle ;</li>
                <li><i>add_NotEmpty()</i> : vérifie que la chaîne de caractères n'est pas vide ;</li>
                <li><i>add_MinValue()</i> : vérifie que la valeur numérique n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxValue()</i> : vérifie que la valeur numérique n'est pas supérieure au paramètre ;</li>
                <li><i>add_Range()</i> : vérifie que la valeur numérique est comprise entre les deux paramètres ;</li>
                <li><i>add_MinDecimal()</i> : vérifie que la valeur décimale n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxDecimal()</i> : vérifie que la valeur décimale n'est pas supérieure au paramètre ;</li>
                <li><i>add_RangeDecimal()</i> : vérifie que la valeur décimale est comprise entre les deux paramètres ;</li>
                <li><i>add_MinLength()</i> : vérifie que la chaîne de caractères a une taille minimale ;</li>
                <li><i>add_MaxLength()</i> : vérifie que la chaîne de caractères ne dépasse pas un certain nombre de caractères ;</li>
                <li><i>add_Size()</i> : vérifie que la taille de la chaîne de caractères est comprise entre les deux paramètres ;</li>
                <li><i>add_DatePast()</i> : vérifie que la date-heure est dans le passé ;</li>
                <li><i>add_DateFuture()</i> : vérifie que la date-heure est dans le futur ;</li>
                <li><i>add_RegExp()</i> : vérifie que la chaîne de caractères est compatible avec l'expression régulière passée en paramètre ;</li>
                <li><i>add_EMail()</i> : vérifie que la chaîne de caractères correspond à un e-mail.</li>
            </ul>
            Comme dans l'exemple de la classe '<i>person</i>', il est possible de définir également des validateurs personnalisés : ce sont des fonctions ou méthodes de classe qui seront appelées automatiquement par le module <b>QxValidator</b> pour valider une propriété ou une instance de classe.<br>
            Il existe trois types de validateurs personnalisés :
            <ul>
                <li><i>add_CustomValidator()</i> : méthode de classe, la signature de la méthode doit être "<i>void my_class::my_method(qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_QVariant()</i> : fonction globale avec type <i>QVariant</i> (propriété convertie en <i>QVariant</i>), la signature de la fonction doit être "<i>void my_validator(const QVariant &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_DataType()</i> : fonction globale avec le type réel de la propriété, la signature de la fonction doit être "<i>void my_validator(const T &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
            </ul>
            <b>Remarque :</b> à chaque validateur peut être associé un groupe (paramètre optionnel pour chaque méthode <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>).<br>
            Il est ainsi possible de créer des groupes de validation suivant le contexte d'exécution : par exemple, valider la saisie d'une personne sur une IHM A ne nécessite peut-être pas les mêmes vérifications que valider une personne sur une IHM B.<br>
            Pour exécuter la validation d'une instance pour un groupe donné (par exemple "<i>myGroup</i>"), il faut appeler la fonction suivante : "<i>qx::QxInvalidValueX invalidValues = qx::validate(personValidate, "myGroup");</i>".<br>
            <br>
            <b>Autre remarque :</b> le module <b>QxValidator</b> définit des messages par défaut lorsqu'une contrainte n'est pas vérifiée.<br>
            Il est possible de redéfinir ces messages par défaut en modifiant la collection suivante : "<i>QHash<QString, QString> * lstMessage = QxClassX::getAllValidatorMessage();</i>".<br>
            Par exemple : "<i>lstMessage->insert("min_value", "la valeur '%NAME%' doit être inférieure ou égale à '%CONSTRAINT%'");</i>".<br>
            Les champs <i>%NAME%</i> et <i>%CONSTRAINT%</i> seront automatiquement remplacés par les valeurs correspondantes.<br>
            Pour modifier le message pour un validateur donné (et non de manière globale), il faut utiliser le paramètre optionnel disponible pour les méthodes <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>.<br>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_430">Gérer la valeur NULL de la base de données</a></p>
         <div class="manual_div_content">
            Les bases de données possèdent la notion de valeur NULL : pour plus de détails sur la valeur NULL, <a href="https://en.wikipedia.org/wiki/Null_%28SQL%29" target="_blank">rendez-vous sur la page Wikipedia</a>.<br>
            La bibliothèque QxOrm permet de gérer la valeur NULL de plusieurs façons différentes :
            <ul>
               <li>utilisation de la classe <a href="#manual_4300">boost::optional</a> fournie par boost ;</li>
               <li>utilisation de la classe <a href="#manual_4310">QVariant</a> fournie par Qt ;</li>
               <li>utilisation de pointeurs ou pointeurs intelligents : un pointeur NULL est associé à la valeur NULL en base de données.</li>
            </ul>
            <br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4300">boost::optional</a></p>
            <div class="manual_div_content">
               La classe <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> fournie par boost est particulièrement adaptée pour gérer la notion de valeur NULL en base de données.<br>
               Pour utiliser <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> avec la bibliothèque QxOrm, il est nécessaire de définir l'option de compilation <b><i>_QX_ENABLE_BOOST</i></b>, ou bien d'inclure l'en-tête <b><i>&lt;QxExtras/QxBoostOptionalOnly.h&gt;</i></b>.<br>
               Voici un exemple de classe dont toutes les propriétés (sauf la clé primaire) peuvent être NULL en utilisant <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional</a> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QDateTime&gt; birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               La classe <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> se manipule facilement : rendez-vous sur <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">la documentation fournie par boost</a> pour plus de détails.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4310">QVariant</a></p>
            <div class="manual_div_content">
               La classe <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> fournie par Qt permet également de gérer la notion de valeur NULL en base de données.<br>
               Voici un exemple de classe dont toutes les propriétés (sauf la clé primaire) peuvent être NULL en utilisant <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">QVariant firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }  
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               Cette solution a pour désavantage de perdre le type de donnée comparé à <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a>.<br>
               Il est donc recommandé d'utiliser <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> pour gérer la valeur NULL avec la bibliothèque QxOrm.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_440">Héritage et polymorphisme</a></p>
         <div class="manual_div_content">
           On retrouve généralement dans les différents outils de type <i>ORM</i> trois différentes stratégies pour gérer la notion d'héritage avec la base de données :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> (une seule table regroupant toutes les propriétés d'une hiérarchie d'héritage de classes) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> (à chaque classe d'une hiérarchie d'héritage est associée une table dans la base de données) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i> (une table par classe concrète dans la hiérarchie d'héritage).
           </li></ul>
           <b>QxOrm</b> utilise par défaut la stratégie <i>Concrete Table Inheritance</i> (les autres stratégies ne sont pas fonctionnelles à l'heure actuelle).<br>
           De nombreux tutoriaux et forums sont disponibles sur internet pour plus de détails sur cette notion d'héritage.<br>
           Un exemple d'utilisation avec une classe de base se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_450">Interface qx::IxPersistable (classe abstraite)</a></p>
         <div class="manual_div_content">
           L'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> (ou classe abstraite) dispose uniquement de méthodes virtuelles pures.<br>
           Elle permet d'avoir une classe de base commune pour appeler les fonctions de persistance sans connaître le type réel de l'instance courante (notion de polymorphisme).<br>
           La bibliothèque QxOrm n'impose pas de travailler avec une classe de base pour enregistrer un type persistant dans le contexte QxOrm, cependant il est parfois utile de disposer d'une interface afin d'écrire des algorithmes génériques.<br>
           <br>
           La classe <i>qx::IxPersistable</i> met à disposition les méthodes virtuelles suivantes (pour plus d'informations sur ces méthodes, rendez-vous sur la <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a>) :<br>
           <br>
           <div style="width:900px; height:290px; overflow:auto; background-color:white">
<pre><span class="keyword">virtual</span><span class="type"> long</span> qxCount<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchAll<span class="operator">(</span>qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxInsert<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxUpdate<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxSave<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx_bool qxExist<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>QxInvalidValueX qxValidate<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> groups<span class="operator"> =</span> QStringList<span class="operator">());</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxPersistableCollection_ptr qxNewPersistableCollection<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxClass<span class="operator"> *</span> qxClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></pre>
           </div>
           <br>
           Par exemple, à partir d'une liste de pointeurs de type <i>qx::IxPersistable</i>, il est possible d'enregistrer les éléments dans plusieurs tables différentes de la base de données de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QList<span class="operator">&lt;</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *&gt;</span> lst<span class="operator"> = ...;</span>
foreach<span class="operator">(</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *</span> p<span class="operator">,</span> lst<span class="operator">)
{</span>
   QSqlError daoError<span class="operator"> =</span> p<span class="operator">-&gt;</span>qxSave<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>daoError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="comment"> /* an error occured */</span><span class="operator"> }</span><span class="comment">
   // etc...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour implémenter l'interface <i>qx::IxPersistable</i>, il faut :
           <ul>
           <li>faire hériter la classe persistante du type <i>qx::IxPersistable</i> ;</li>
           <li>dans la définition de la classe (<i>myClass.h</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_HPP(myClass)</i> ;</li>
           <li>dans l'implémentation de la classe (<i>myClass.cpp</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_CPP(myClass)</i>.</li>
           </ul>
           Par exemple, implémenter l'interface <i>qx::IxPersistable</i> pour la classe <a href="./tutorial.html#tuto_6"><i>author</i></a> du tutoriel <i>qxBlog</i> revient à écrire (les modifications par rapport au code du tutoriel apparaissent en gras) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author : <font style="background-color:yellow"><b>public qx::IxPersistable</b></font><span class="operator">
{</span>
   <font style="background-color:yellow"><b>QX_PERSISTABLE_HPP(author)</b></font>
<span class="keyword">public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- propriétés
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   list_blog   m_blogX<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
        </td></tr></tbody></table>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span>
<font style="background-color:yellow"><b>QX_PERSISTABLE_CPP(author)</b></font>

<span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le projet de test <i>./test/qxDllSample/dll1/</i> met à disposition une sorte de 'super classe de base' : la classe <i>qx::QxPersistable</i> implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> et hérite de <i>QObject</i>.<br>
           Le mécanisme <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank"><i>SIGNAL-SLOT</i></a> de Qt peut donc être utilisé avec cette classe, ce qui peut être intéressant par exemple pour la notion de déclencheurs (ou <a href="#manual_410"><i>trigger</i></a>).<br>
           La classe <i>qx::QxPersistable</i> met également à disposition des méthodes virtuelles qu'il est possible de surcharger pour gérer notamment la notion de validation des données avec le module <a href="#manual_420"><i>QxValidator</i></a>.<br>
           La classe <i>qx::QxPersistable</i> ne fait pas partie de la distribution de QxOrm, mais il est possible de la copier-coller dans un projet afin de profiter de ses fonctionnalités :
           <ul>
           <li>accéder au fichier <a href="./resource/qx_persistable_hpp.html" target="_blank"><i>QxPersistable.hpp</i></a> ;</li>
           <li>accéder au fichier <a href="./resource/qx_persistable_cpp.html" target="_blank"><i>QxPersistable.cpp</i></a>.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_455">Utiliser le pattern C++ PIMPL (Private Implementation idiom ou d-pointer)</a></p>
         <div class="manual_div_content">
           <a href="https://en.cppreference.com/w/cpp/language/pimpl" target="_blank">Définition du site cppreference :</a> "Pointer to implementation" or "pImpl" is a C++ programming technique that removes implementation details of a class from its object representation by placing them in a separate class, accessed through an opaque pointer.
           This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.
           <br><br>
           <a href="https://dzone.com/articles/the-pimpl-pattern-what-you-should-know" target="_blank">Les avantages à utiliser le pattern PIMPL</a> pour définir une classe persistente enregistrée dans le contexte QxOrm :
           <ul>
             <li><b>Compilation Firewall</b> : si l'implémentation privée change, le code client n'a pas besoin d'être recompilé ;</li>
             <li>Réduction des <b>temps de compilation</b> : les fichiers d'en-têtes (*.h, *.hpp) sont moins volumineux ;</li>
             <li><b>Compatibilité binaire</b> : vous pouvez développer plusieurs versions d'une bibliothèque sans casser la compatibilité ;</li>
             <li>Réduction de la <b>taille des exécutables</b> générés.</li>
           </ul>
           <a href="https://www.geeksforgeeks.org/pimpl-idiom-in-c-with-examples/" target="_blank">Les inconvients du pattern PIMPL</a> :
           <ul>
             <li>Légère baisse des performances : nécessité d'utiliser un niveau d'indirection supplémentaire avec le pointeur opaque ;</li>
             <li>Nécessité d'allouer un pointeur par instance (peut causer des problèmes de <i>memory fragmentation</i>).</li>
           </ul>
           <br>
           La bibliothèque QxOrm fournit un projet de test où toutes les classes persistantes sont codées en utilisant le pattern PIMPL : <a href="https://github.com/QxOrm/QxOrm/tree/master/test/qxBlogPImpl" target="_blank"><i>qxBlogPImpl</i> (avec gestion des relations)</a>.<br>
           <font style="background-color:yellow">Il est également possible d'utiliser <a href="./manual_qxee.html#cpp_export_settings_parameters">l'application <b>QxEntityEditor</b></a></font> pour générer facilement et automatiquement toutes les classes persistantes d'un projet C++ avec <b>l'option PIMPL</b>.<br>
           <br>
           Exemple de classe persistante C++ enregistrée dans le contexte QxOrm en utilisant le pattern PIMPL (avec relations <i>1-n</i>, <i>n-1</i> et <i>n-n</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_BLOG_H_
#define _QX_BLOG_BLOG_H_</span>

<span class="keyword">class</span> author;
<span class="keyword">class</span> comment;
<span class="keyword">class</span> category;

<span class="keyword">class</span> QX_BLOG_DLL_EXPORT blog
{

   QX_REGISTER_FRIEND_CLASS(blog)

<font style="background-color:yellow">private:

   <span class="keyword">struct</span> blog_impl;
   std::unique_ptr&lt;blog_impl&gt; m_pImpl; <span class="comment">//!&lt; Private implementation idiom</span></font>

<span class="keyword">public</span>:

   blog();
   virtual ~blog();

   <font style="background-color:yellow">blog(<span class="keyword">const</span> blog & other);
   blog & operator=(<span class="keyword">const</span> blog & other);

#ifdef Q_COMPILER_RVALUE_REFS
   blog(blog && other) Q_DECL_NOEXCEPT;
   blog & operator=(blog && other) Q_DECL_NOEXCEPT;
#endif <span class="comment">// Q_COMPILER_RVALUE_REFS</span></font>

   <span class="type">long</span> id() <span class="keyword">const</span>;
   <span class="type">QString</span> text() <span class="keyword">const</span>;
   <span class="type">QDateTime</span> dateCreation() <span class="keyword">const</span>;

   <span class="type">void</span> setId(long l);
   <span class="type">void</span> setText(<span class="keyword">const</span> QString & s);
   <span class="type">void</span> setDateCreation(<span class="keyword">const</span> QDateTime & d);

   std::shared_ptr&lt;author&gt; & getAuthor();
   QList&lt; std::shared_ptr&lt;comment&gt; &gt; & listOfComments();
   qx::QxCollection&lt;long, QSharedPointer&lt;category&gt; &gt; & listOfCategories();

};

QX_REGISTER_HPP_QX_BLOG(blog, qx::trait::no_base_class_defined, 0)

<span class="keyword">typedef</span> std::shared_ptr&lt;blog&gt; blog_ptr;
<span class="keyword">typedef</span> std::vector&lt;blog_ptr&gt; list_blog;

<span class="pre">#endif <span class="comment">// _QX_BLOG_BLOG_H_</span></span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/blog.h"</span>
#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/category.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span></span>

QX_REGISTER_CPP_QX_BLOG(blog)

<font style="background-color:yellow"><span class="keyword">struct</span> Q_DECL_HIDDEN blog::blog_impl
{
   <span class="type">long</span>           m_id;
   <span class="type">QString</span>        m_text;
   <span class="type">QDateTime</span>      m_dt_creation;
   author_ptr     m_author;
   list_comment   m_commentX;
   list_category  m_categoryX;

   blog_impl() : m_id(0) { ; }
   ~blog_impl() { ; }
};</font>

<span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> register_class(QxClass&lt;blog&gt; & t)
{
   <font style="background-color:yellow">IxDataMember * pImpl = t.pimpl(& blog::m_pImpl);</font>

   t.id(<font style="background-color:yellow">& blog::blog_impl::m_id</font>, <span class="string">"blog_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);

   t.data(<font style="background-color:yellow">& blog::blog_impl::m_text</font>, <span class="string">"blog_text"</span>, 0, true, true, <font style="background-color:yellow">pImpl</font>);
   t.data(<font style="background-color:yellow">& blog::blog_impl::m_dt_creation</font>, <span class="string">"date_creation"</span>, 0, true, true, <font style="background-color:yellow">pImpl</font>);

   t.relationManyToOne(<font style="background-color:yellow">& blog::blog_impl::m_author</font>, <span class="string">"author_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
   t.relationOneToMany(<font style="background-color:yellow">& blog::blog_impl::m_commentX</font>, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
   t.relationManyToMany(<font style="background-color:yellow">& blog::blog_impl::m_categoryX</font>, <span class="string">"list_category"</span>, <span class="string">"category_blog"</span>, <span class="string">"blog_id"</span>, <span class="string">"category_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
}}

blog::blog() : <font style="background-color:yellow">m_pImpl(new blog_impl())</font> { ; }

blog::~blog() { ; }

<font style="background-color:yellow">blog::blog(<span class="keyword">const</span> blog & other) : m_pImpl(new blog_impl(* other.m_pImpl)) { ; }

blog & blog::operator=(<span class="keyword">const</span> blog & other)
{
   if (this != (& other)) { (* m_pImpl) = (* other.m_pImpl); }
   <span class="keyword">return</span> (* this);
}

#ifdef Q_COMPILER_RVALUE_REFS
blog::blog(blog && other) Q_DECL_NOEXCEPT : m_pImpl(std::move(other.m_pImpl)) { ; }
blog & blog::operator=(blog && other) Q_DECL_NOEXCEPT { if (this != (& other)) { m_pImpl = std::move(other.m_pImpl); }; <span class="keyword">return</span> (* this); }
#endif <span class="comment">// Q_COMPILER_RVALUE_REFS</span></font>

<span class="type">long</span> blog::id() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_id</font>; }

<span class="type">QString</span> blog::text() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_text</font>; }

<span class="type">QDateTime</span> blog::dateCreation() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_dt_creation</font>; }

<span class="keyword">void</span> blog::setId(<span class="type">long</span> l) { <font style="background-color:yellow">m_pImpl-&gt;m_id</font> = l; }

<span class="keyword">void</span> blog::setText(<span class="keyword">const</span> <span class="type">QString</span> & s) { <font style="background-color:yellow">m_pImpl-&gt;m_text</font> = s; }

<span class="keyword">void</span> blog::setDateCreation(<span class="keyword">const</span> <span class="type">QDateTime</span> & d) { <font style="background-color:yellow">m_pImpl-&gt;m_dt_creation</font> = d; }

std::shared_ptr&lt;author&gt; & blog::getAuthor() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_author</font>; }

QList&lt; std::shared_ptr&lt;comment&gt; &gt; & blog::listOfComments() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_commentX</font>; }

qx::QxCollection&lt;long, QSharedPointer&lt;category&gt; &gt; & blog::listOfCategories() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_categoryX</font>; }</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_460">Persister des types personnalisés</a></p>
         <div class="manual_div_content">
           La bibliothèque QxOrm permet de persister n'importe quel type, même si ce dernier n'est pas enregistré dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           Il est nécessaire d'écrire les fonctions de sérialisation de la bibliothèque boost, en utilisant la méthode <b>non intrusive</b> (puisque le code source n'est pas disponible ou ne peut pas être modifié).
           Pour plus d'informations sur la sérialisation des données avec la bibliothèque boost, rendez-vous sur <a href="http://khayyam.developpez.com/articles/cpp/boost/serialization/" target="_blank">le tutoriel de developpez.com</a>.<br>
           <br>
           Par exemple, imaginons une classe '<i>ExtObject3D</i>' provenant d'une bibliothèque tierce et dont le code source n'est pas disponible ou ne peut pas être modifié.
           Voici le code nécessaire pour pouvoir persister une instance de type '<i>ExtObject3D</i>' en base de données :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Le code ci-dessus est suffisant pour persister une instance de type '<i>ExtObject3D</i>' en base de données : il est ainsi possible d'utiliser une propriété de type '<i>ExtObject3D</i>' dans une classe persistante enregistrée dans le contexte QxOrm.
           Cette propriété peut être mappée sur une colonne de type <i>TEXT</i> ou <i>VARCHAR</i> en base de données.<br>
           <br>
           Le comportement par défaut de la bibliothèque QxOrm est le suivant : l'instance est sérialisée au format XML avant d'être insérée ou mise à jour en base de données.
           Ce comportement par défaut peut être utile par exemple si l'on souhaite enregistrer une collection d'objets sans vouloir faire de relation (et donc gérer une autre table dans la base de données).
           Par exemple, si l'on utilise une propriété de type <i>std::vector&lt;mon_objet&gt;</i> dans une classe persistante sans relation associée, la liste d'éléments sera automatiquement enregistrée au format XML en base de données.<br>
           <br>
           <b>Remarque :</b> ce comportement par défaut peut être facilement modifié pour un type donné.
           Le moteur <i>QtSql</i> utilise le type <i>QVariant</i> pour faire le lien entre le code C++ et la base de données.
           Le type <i>QVariant</i> peut contenir du texte, des valeurs numériques, du binaire, etc.
           Il peut donc être intéressant de spécialiser le comportement par défaut (sérialisation XML) si l'on souhaite stocker des données au format binaire ou bien optimiser les performances (la sérialisation XML peut être couteuse en temps d'exécution).
           Il suffit de proposer (en plus des fonctions de sérialisation boost) les conversions nécessaires en <i>QVariant</i>, par exemple avec la classe '<i>ExtObject3D</i>' :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Ici je convertis ExtObject3D en QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Ici je convertis QVariant en ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br><br>
           <b>Remarque :</b> Voici un template pour créer un type personnalisé persistable :
           <br><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _MY_CUSTOM_PERSISTABLE_TYPE_H_
#define _MY_CUSTOM_PERSISTABLE_TYPE_H_

#ifdef _MSC_VER
#pragma once
#endif

#include &lt;QxOrm.h&gt;</span>

<span class="keyword">class</span> MyPersistableType
{
   <span class="comment">/* What you want here */</span>
};

QX_REGISTER_CLASS_NAME(MyPersistableType)
QX_CLASS_VERSION(MyPersistableType, 0)

QDataStream & operator&lt;&lt; (QDataStream & stream, const MyPersistableType & t)
{
   <span class="comment">/* Your implementation here */</span>
}

QDataStream & operator&gt;&gt; (QDataStream & stream, MyPersistableType & t)
{
   <span class="comment">/* Your implementation here */</span>
}

<span class="keyword">namespace</span> qx {
<span class="keyword">namespace</span> cvt {
<span class="keyword">namespace</span> detail {

<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> QxConvert_ToVariant&lt; MyPersistableType &gt; {
<span class="keyword">static</span> <span class="keyword">inline</span> QVariant toVariant(const MyPersistableType & t, const QString & format, int index, qx::cvt::context::ctx_type ctx)
{
   <span class="comment">/* Here I convert from MyPersistableType to QVariant */</span>
} };

<span class="keyword">template</span> <> <span class="keyword">struct</span> QxConvert_FromVariant&lt; MyPersistableType &gt; {
<span class="keyword">static</span> <span class="keyword">inline</span> qx_bool fromVariant(const QVariant & v, MyPersistableType & t, const QString & format, int index, qx::cvt::context::ctx_type ctx)
{
   <span class="comment">/* Here I convert from QVariant to MyPersistableType */</span>
   return qx_bool(true);
} };

} <span class="comment">// namespace detail</span>
} <span class="comment">// namespace cvt</span>
} <span class="comment">// namespace qx</span>

<span class="keyword">#ifndef</span> _QX_NO_JSON

<span class="keyword">namespace</span> qx {
<span class="keyword">namespace</span> cvt {
<span class="keyword">namespace</span> detail {

<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct</span> QxConvert_ToJson&lt; MyPersistableType &gt;
{
   <span class="keyword">static inline</span> QJsonValue toJson(const MyPersistableType & t, const QString & format)
   {
      <span class="comment">/* Your implementation here */</span>
   }
};

<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct</span> QxConvert_FromJson&lt; MyPersistableType &gt;
{
   <span class="keyword">static inline</span> qx_bool fromJson(const QJsonValue & j, MyPersistableType & t, const QString & format)
   {
      <span class="comment">/* Your implementation here */</span>
   }
};

} <span class="comment">// namespace detail</span>
} <span class="comment">// namespace cvt</span>
} <span class="comment">// namespace qx</span>

<span class="keyword">#endif</span> <span class="comment">// _QX_NO_JSON</span>

<span class="comment">// ------------------------------------</span>
<span class="comment">// If you are using boost serialization, you have also to implement save/load functions like above 'ExtObject3D' example</span>
<span class="comment">// ------------------------------------</span>

<span class="keyword">#endif</span> <span class="comment">// _MY_CUSTOM_PERSISTABLE_TYPE_H_</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_470">Générer le schéma DDL SQL de la base de données</a></p>
         <div class="manual_div_content">
           <a href="#manual_110"><b><font style="background-color:yellow">!!! Il est fortement recommandé d'utiliser l'application <b>QxEntityEditor</b> pour gérer cette problématique !!!</font></b></a><br>
           <br>
           La bibliothèque QxOrm ne fournit pas de mécanisme pour gérer automatiquement la création et mise à jour des tables dans la base de données.<br>
           En effet, la fonction <i>qx::dao::create_table&lt;T&gt;</i> doit être utilisée uniquement pour créer des prototypes.<br>
           Il est fortement recommandé d'utiliser un outil spécifique à chaque SGBD pour créer et maintenir les tables de la base de données (par exemple <i>Navicat</i> pour <i>MySql</i>, <i>pgAdmin</i> pour <i>PostgreSQL</i>, <i>SQLite Manager</i> pour <i>SQLite</i>, etc.).<br>
           De plus, un outil spécifique à chaque SGBD permet d'appliquer certaines optimisations (ajout d'index par exemple).<br>
           <br>
           Cependant, il peut être intéressant pour certaines applications de ne pas avoir à gérer manuellement les tables de la base de données.<br>
           Dans ce cas, il est possible de créer une fonction C++ pour parcourir la liste des classes persistantes enregistrées dans le contexte QxOrm (en utilisant le moteur d'introspection de la bibliothèque) et ainsi créer un script SQL de génération et mise à jour des tables de la base de données.<br>
           <br>
           La bibliothèque QxOrm fournit une fonction C++ créée uniquement à titre d'exemple : elle peut donc servir de base de travail pour créer sa propre fonction de génération de script SQL.<br>
           Cette fonction se trouve dans le fichier <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">./src/QxRegister/QxClassX.cpp</a></i> et se nomme <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">QString qx::QxClassX::dumpSqlSchema()</a></i>.<br>
           Elle génère un script SQL et le renvoie sous forme de <i>QString</i> : il est possible d'adapter cette fonction pour générer un fichier contenant le script SQL ou bien appliquer chaque instruction SQL directement au SGBD.<br>
           <br>
           Voici un exemple d'implémentation proposé par <a href="http://www.developpez.net/forums/u449556/dodobibi/" target="_blank">dodobibi</a> pour gérer une base <i>PostgreSQL</i> : cet exemple gère les évolutions futures de son application (ajout de colonnes dans une table existante, ajout d'index sur une colonne existante, etc.).<br>
           Au lancement de l'application, le numéro de version est indiqué de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QApplication app<span class="operator">(</span>argc<span class="operator">,</span> argv<span class="operator">);</span>
app<span class="operator">.</span>setProperty<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span><span class="comment"> // Version incrementée à chaque compilation et diffusion de l'application</span></pre>
           </td></tr></tbody></table>
           <br>
           Une table de la base de données permet de stocker le numéro de version courant.<br>
           Une classe persistante C++ est mappée sur cette table de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _DATABASE_VERSION_H_
#define _DATABASE_VERSION_H_
</span><span class="keyword"> 
class</span> MY_DLL_EXPORT DatabaseVersion<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
  QString name<span class="operator">;</span><span class="type">
  long</span> version<span class="operator">;
};</span>

QX_REGISTER_HPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _DATABASE_VERSION_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/DatabaseVersion.h"
#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>DatabaseVersion<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>version<span class="operator">,</span><span class="string"> "version"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Avec la classe <i>DatabaseVersion</i>, il est possible de vérifier si la version de la base de données est à jour.<br>
           C'est le rôle de la fonction <i>isDatabaseVersionOld()</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">bool</span> isDatabaseVersionOld<span class="operator">()
{</span>
  DatabaseVersion dbVersion<span class="operator">;</span>
  dbVersion<span class="operator">.</span>name<span class="operator"> =</span><span class="string"> "MyAppName"</span><span class="operator">;</span>
  QSqlError err<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="flow">
  if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="bool"> false</span><span class="operator">; }</span><span class="flow">
  return</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &lt;</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">());
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si au lancement de l'application, la fonction <i>isDatabaseVersionOld()</i> renvoie <i>true</i>, alors la mise à jour de la base de données est effectuée de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">void</span> updateDatabaseVersion<span class="operator">()
{</span><span class="flow">
  try</span><span class="operator">
  {</span><span class="type">
    int</span> domainVersion<span class="operator"> =</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">();</span><span class="comment">

    // On se connecte avec un utilisateur de la base de données qui a les droits de modifications du schéma
</span>    QSqlDatabase db<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getDatabaseCloned<span class="operator">();</span>
    db<span class="operator">.</span>setUserName<span class="operator">(</span><span class="string">"MyAdminLogin"</span><span class="operator">);</span>
    db<span class="operator">.</span>setPassword<span class="operator">(</span><span class="string">"MyAdminPassword"</span><span class="operator">);</span><span class="comment">

    // On s'assure que la session démarre une transaction et lève une exception à la moindre erreur
</span>    qx<span class="operator">::</span>QxSession session<span class="operator">(</span>db<span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">);</span><span class="comment">

    // On "fetch" la version de la base de données avec un verrou pour éviter les modifications concurrentes !
    // Si plusieurs utilisateurs lancent l'application en même temps et qu'une mise à jour
    // est nécessaire, le premier fera la mise à jour, et les autres seront en attente
</span>    DatabaseVersion dbVersion<span class="operator">;</span>
    session<span class="operator">.</span>fetchByQuery<span class="operator">(</span>qx_query<span class="operator">(</span><span class="string">"WHERE name='MyAppName' FOR UPDATE"</span><span class="operator">),</span> dbVersion<span class="operator">);</span><span class="comment">

    // Pour les autres utilisateurs, une fois le verrou levé, on vérifie si la mise à jour est toujours nécessaire
</span><span class="flow">    if</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &gt;=</span> domainVersion<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // On exécute chaque instruction SQL avec la variable "query"
</span>    QSqlQuery query<span class="operator">(</span>db<span class="operator">);</span><span class="comment">

    // On récupère toutes les classes persistantes C++ enregistrées dans le contexte QxOrm
</span>    qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> qx<span class="operator">::</span>IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
    if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // on récupère la liste des tables existantes dans la base (fonction de Qt)
</span>    QStringList tables<span class="operator"> =</span> db<span class="operator">.</span>tables<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span><span class="type">long</span> k<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> k<span class="operator"> &lt;</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span> k<span class="operator">++)
    {</span>
      qx<span class="operator">::</span>IxClass<span class="operator"> *</span> pClass<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>getByIndex<span class="operator">(</span>k<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (!</span> pClass<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes non persistantes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxParameter"</span><span class="operator">) ||</span> pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxService"</span><span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes à jour : si la version de pClass est &lt;= à la version enregistrée dans la base, la mise à jour n'est pas nécessaire
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // On crée la table si elle n'existe pas, et on définit son propriétaire
</span><span class="flow">      if</span><span class="operator"> (!</span> tables<span class="operator">.</span>contains<span class="operator">(</span>pClass<span class="operator">-&gt;</span>getName<span class="operator">()))
      {</span>
        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ( ) WITH (OIDS = FALSE);"
                   "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " OWNER TO \"MyAdminLogin\";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
      }</span><span class="comment">

      // On ajoute les colonnes à la table si elles n'existent pas
</span>      qx<span class="operator">::</span>IxDataMemberX<span class="operator"> *</span> pDataMemberX<span class="operator"> =</span> pClass<span class="operator">-&gt;</span>getDataMemberX<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">; (</span>pDataMemberX<span class="operator"> &amp;&amp; (</span>l<span class="operator"> &lt;</span> pDataMemberX<span class="operator">-&gt;</span>count_WithDaoStrategy<span class="operator">()));</span> l<span class="operator">++)
      {</span>
        qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> pDataMemberX<span class="operator">-&gt;</span>get_WithDaoStrategy<span class="operator">(</span>l<span class="operator">);</span><span class="flow">
        if</span><span class="operator"> (!</span> p<span class="operator"> || (</span>p<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span>

        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getSqlType<span class="operator">() +</span><span class="string"> ";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getIsPrimaryKey<span class="operator">())</span><span class="comment"> // PRIMARY KEY
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD PRIMARY KEY ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAllPropertyBagKeys<span class="operator">().</span>contains<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">))</span><span class="comment"> // INDEX
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE INDEX "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_idx"</span><span class="operator"> +</span><span class="string"> 
                     " ON "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " USING "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getPropertyBag<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">).</span>toString<span class="operator">() +</span><span class="string"> " ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getNotNull<span class="operator">())</span><span class="comment"> // NOT NULL
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " SET NOT NULL;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAutoIncrement<span class="operator">())</span><span class="comment"> // AUTO INCREMENT
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE SEQUENCE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> " OWNER TO \"MyAdminLogin\"; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span><span class="string">
                     "SET DEFAULT nextval('"</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "'::regclass);"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getDescription<span class="operator">() !=</span><span class="string"> ""</span><span class="operator">)</span><span class="comment"> // DESCRIPTION
</span><span class="operator">        {</span><span class="comment">
          // $$ceci est un texte ne nécessitant pas de caractères d'échappement dans postgres grace aux doubles dolars$$
</span>          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"COMMENT ON COLUMN "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "."</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " IS $$"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span><span class="string"> "$$ ;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }
      }
    }</span><span class="comment">

    // On enregistre la version courante de la base de données
</span>    dbVersion<span class="operator">.</span>version<span class="operator"> =</span> domainVersion<span class="operator">;</span>
    session<span class="operator">.</span>save<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="comment">

    // Fin du block "try" : la session est détruite =&gt; commit ou rollback automatique
    // De plus, un commit ou rollback sur la transaction lève automatiquement le verrou posé précédemment
</span><span class="operator">  }</span><span class="flow">
  catch</span><span class="operator"> (</span><span class="keyword">const</span> qx<span class="operator">::</span>dao<span class="operator">::</span>sql_error<span class="operator"> &amp;</span> err<span class="operator">)
  {</span>
    QSqlError sqlError<span class="operator"> =</span> err<span class="operator">.</span>get<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>databaseText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>driverText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>number<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>type<span class="operator">();
  }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le code précédent (tout comme la fonction <a href="./resource/qxclassx_dump_sql_schema.html" target="_blank"><i>qx::QxClassX::dumpSqlSchema()</i></a>) peut être modifié pour s'adapter aux besoins spécifiques d'une application.<br>
           Par exemple, il pourrait être intéressant de créer par défaut une seconde table (en plus de la table <i>DatabaseVersion</i>) pour enregistrer la liste des classes persistantes enregistrées dans le contexte QxOrm : ainsi, au lieu d'utiliser la fonction proposée par Qt "<i>db.tables()</i>", il serait possible de récupérer toutes les tables mappées sur des classes persistantes avec des informations supplémentaires (numéro de version pour chaque table, nombre de colonnes enregistrées dans le contexte QxOrm, description de chaque table, etc.).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_475">Associer un type SQL à une classe C++</a></p>
         <div class="manual_div_content">
           Chaque base de données propose des types SQL différents pour stocker l'information.<br>
           La bibliothèque QxOrm propose une association par défaut pour les classes C++ les plus fréquemment utilisées dans un programme.<br>
           Voici cette association par défaut :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
           </td></tr></tbody></table>
           <br>
           Si le type SQL proposé par défaut par la bibliothèque QxOrm ne correspond pas à la base de données utilisée, il peut facilement être modifié (de manière globale à toute l'application) en utilisant la collection suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QHash<span class="operator">&lt;</span>QString<span class="operator">,</span> QString<span class="operator">&gt; *</span> lstSqlType<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllSqlTypeByClassName<span class="operator">();</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"QString"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"std::string"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
// etc.</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour modifier le type SQL de manière spécifique pour une colonne d'une table de la base de données, il faut définir le type SQL dans la fonction de mapping de QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>MyClass<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span><span class="comment">
  //...
</span>  IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> MyClass<span class="operator">::</span>m_MyProperty<span class="operator">,</span><span class="string"> "my_property"</span><span class="operator">);</span>
  p<span class="operator">-&gt;</span>setSqlType<span class="operator">(</span><span class="string">"VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
  //...
</span><span class="operator">}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour les classes non supportées par défaut par la bibliothèque QxOrm (voir ce chapitre du manuel utilisateur : <i><a href="#manual_460">Persister des types personnalisés</a></i>), il est possible d'associer un type SQL par défaut en utilisant la macro suivante (en dehors de tout <i>namespace</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_TRAIT_GET_SQL_TYPE<span class="operator">(</span>MyClass<span class="operator">,</span><span class="string"> "my_sql_type"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_480">Effectuer des requêtes asynchrones à la base de données</a></p>
         <div class="manual_div_content">
           Il peut être parfois intéressant d'exécuter certaines requêtes à la base de données de manière asynchrone (multi-thread), par exemple pour éviter de bloquer une IHM si une requête est trop longue à s'exécuter.<br>
           Pour simplifier les requêtes asynchrones, la bibliothèque QxOrm fournit la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>.<br>
           Cette classe exécute une requête dans un thread dédié et renvoie un <i>SIGNAL</i> <i>queryFinished()</i> lorsque la requête est terminée.<br>
           Pour utiliser la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>, il suffit de :
           <ul>
           <li>vérifier que la requête fait appel à une classe qui implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> ;</li>
           <li>créer une instance de type <i>qx::QxDaoAsync</i> (par exemple, une propriété membre d'une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>connecter un <i>SLOT</i> au <i>SIGNAL</i> <i>qx::QxDaoAsync::queryFinished()</i> (par exemple, un <i>SLOT</i> défini dans une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>exécuter une requête à la base de données en utilisant l'une des méthodes commençant par <i>async</i> : <i>qx::QxDaoAsync::asyncXXXX()</i>.</li>
           </ul>
           Voici un exemple d'utilisation avec une classe nommée <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MyWidget<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">
{</span> Q_OBJECT<span class="comment">

   //...
</span>   qx<span class="operator">::</span>QxDaoAsync m_daoAsync<span class="operator">;</span><span class="comment">
   //...
</span>Q_SLOTS<span class="operator">:</span><span class="type">
   void</span> onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">);</span><span class="comment">
   //...

</span><span class="operator">};</span></pre>
           </td></tr></tbody></table>
           <br>
           Et voici l'implémentation de la classe <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>MyWidget<span class="operator">::</span>MyWidget<span class="operator">() :</span> QObject<span class="operator">()
{</span><span class="comment">
   //...
</span>   QObject<span class="operator">::</span>connect<span class="operator">((&amp;</span> m_daoAsync<span class="operator">),</span> SIGNAL<span class="operator">(</span>queryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)),</span><span class="keyword"> 
                    this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)));</span><span class="comment">
   //...
</span><span class="operator">}</span><span class="type">

void</span> MyWidget<span class="operator">::</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> pDaoParams<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>
   qx<span class="operator">::</span>QxSqlQuery query<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>query<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (!</span> daoError<span class="operator">.</span>isValid<span class="operator">()) { ; }</span><span class="comment">
   // If the async query is associated to a simple object, just use 'pDaoParams-&gt;pInstance' method
</span>   qx<span class="operator">::</span>IxPersistable_ptr ptr<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pInstance<span class="operator">;</span><span class="comment">
   // If the async query is associated to a list of objects, just use 'pDaoParams-&gt;pListOfInstances' method
</span>   qx<span class="operator">::</span>IxPersistableCollection_ptr lst<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pListOfInstances<span class="operator">;</span><span class="comment">
   //...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_490">Gestion du cache pour sauvegarder des instances C++ (module QxCache)</a></p>
         <div class="manual_div_content">
           Le cache proposé par la bibliothèque QxOrm (<a href="../doxygen/html/group___qx_cache.html" target="_blank">module <i>QxCache</i></a>) est <i>thread-safe</i> et permet de stocker facilement n'importe quel type de données.<br>
           Les fonctions pour accéder au cache se trouvent dans le <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>.<br>
           Le cache permet une optimisation du programme : il est possible par exemple de stocker des éléments issus d'une requête effectuée en base de données.<br>
           <br>
           Chaque élément stocké dans le cache est associé à une clé de type <i>QString</i> : cette clé permet de retrouver rapidement un élément du cache.<br>
           Si un nouvel élément est stocké dans le cache avec une clé qui existe déjà, alors l'ancien élément associé à cette clé est effacé automatiquement du cache.<br>
           <br>
           Le cache de la bibliothèque QxOrm ne gère pas la durée de vie des objets : il n'y a aucun <i>delete</i> effectué par le cache.<br>
           C'est pourquoi il est fortement recommandé (mais ce n'est pas une obligation) de privilégier le stockage de pointeurs intelligents : par exemple, <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" target="_blank"><i>boost::shared_ptr&lt;T&gt;</i></a> pour la bibliothèque <i>boost</i> ou bien <a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer&lt;T&gt;</i></a> pour la bibliothèque <i>Qt</i>.<br>
           <br>
           Le cache peut avoir un coût relatif maximum pour éviter une utilisation de la mémoire trop importante : chaque élément inséré dans le cache peut indiquer un coût représentant une estimation de sa taille mémoire (par exemple, le nombre d'éléments d'une collection).<br>
           Lorsque le coût maximum du cache est atteint, les premiers éléments insérés dans le cache sont supprimés (en respectant l'ordre d'insertion dans le cache) jusqu'à ce que la limite du cache ne soit plus dépassée.<br>
           <br>
           Il est possible d'associer à chaque élément du cache une date-heure d'insertion.<br>
           Si aucune date-heure n'est renseignée, alors la date-heure courante est prise en compte.<br>
           Ce mécanisme permet de vérifier si un élément stocké dans le cache nécessite une mise à jour ou non.<br>
           <br>
           Voici un exemple d'utilisation du cache de la bibliothèque QxOrm (fonctions du <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Défini le coût maximum du cache à 500
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>max_cost<span class="operator">(</span><span class="int">500</span><span class="operator">);</span><span class="comment">

// Récupère une liste de 'author' de la base de données
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author<span class="operator">&gt; &gt;</span> list_author<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_author<span class="operator">);</span><span class="comment">

// Insère la liste de 'author' dans le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">,</span> list_author<span class="operator">);</span><span class="comment">

// Récupère une liste de 'blog' de la base de données
</span>QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt;</span> list_blog<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_blog<span class="operator">);</span><span class="comment">

// Insère la liste de 'blog' dans le cache (coût = nombre de 'blog')
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">,</span> list_blog<span class="operator">.</span>count<span class="operator">());</span><span class="comment">

// Pointeur vers un objet de type 'comment'
</span>comment_ptr my_comment<span class="operator">;</span>
my_comment<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> comment<span class="operator">(</span><span class="int">50</span><span class="operator">));</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_comment<span class="operator">);</span><span class="comment">

// Insère le 'comment' dans le cache en précisant une date-heure d'insertion
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span><span class="int"> 1</span><span class="operator">,</span> my_comment<span class="operator">-&gt;</span>dateModif<span class="operator">());</span><span class="comment">

// Récupère la liste de 'blog' stockée dans le cache
</span>list_blog<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">&lt;</span> QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt; &gt;(</span><span class="string">"list_blog"</span><span class="operator">);</span><span class="comment">

// Récupère la liste de 'blog' sans préciser le type
</span>qx_bool bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">);</span><span class="comment">

// Supprime du cache la liste de 'author'
</span><span class="type">bool</span> bRemoveOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>remove<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">);</span><span class="comment">

// Compte le nombre d'éléments du cache
</span><span class="type">long</span> lCount<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>count<span class="operator">();</span><span class="comment">

// Récupère le coût actuel des éléments stockés dans le cache
</span><span class="type">long</span> lCurrentCost<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>current_cost<span class="operator">();</span><span class="comment">

// Vérifie qu'un élément associé à la clé "comment" existe dans le cache
</span><span class="type">bool</span> bExist<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>exist<span class="operator">(</span><span class="string">"comment"</span><span class="operator">);</span><span class="comment">

// Récupère le 'comment' stocké dans le cache avec sa date-heure d'insertion
</span>QDateTime dt<span class="operator">;</span>
bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span> dt<span class="operator">);</span><span class="comment">

// Vide le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_500">Travailler avec plusieurs bases de données</a></p>
         <div class="manual_div_content">
            Dans le chapitre <a href="#manual_310">Connexion à la base de données</a>, nous avons vu comment paramétrer la connexion par défaut avec la classe singleton : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a>.
            La bibliothèque QxOrm étant basée sur le moteur <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> de Qt, elle utilise en interne la classe <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase</a> de Qt.
            Toutes les fonctions d'accès à la base de données (<a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">namespace qx::dao</a>, classe <a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a>, etc...) ont un paramètre optionnel : <b><i>QSqlDatabase * pDatabase = NULL</i></b> :
            <ul>
               <li>si la valeur de ce paramètre est à NULL (valeur par défaut) : alors la bibliothèque QxOrm utilise la classe  singleton <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a> pour se connecter à la base de données (avec gestion automatique du multi-threading) ;</li>
               <li>si la valeur est non nulle : alors la bibliothèque QxOrm utilise la connexion fournie par le pointeur <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank"><i>QSqlDatabase * pDatabase</i></a>.</li>
            </ul>
            Ce paramètre permet donc de gérer son propre pool de connexions à une ou plusieurs bases de données.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_510">Déclarer une classe abstraite dans le contexte QxOrm</a></p>
         <div class="manual_div_content">
           Une classe abstraite C++ (contenant au moins une méthode virtuelle pure) ne peut pas être mappée avec une table d'une base de données (puisqu'elle ne peut pas être instanciée).<br>
           Cependant, il peut être intéressant de définir une classe abstraite contenant une liste de propriétés utilisées par plusieurs objets persistants.<br>
           Un exemple de classe abstraite se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> de la distribution de QxOrm avec la classe <i>BaseClassTrigger</i>.<br>
           QxOrm propose le mécanisme suivant pour définir une classe abstraite dans le contexte QxOrm :
           <ul>
              <li>déclarer la classe avec la méthode '<i>void register_class</i>' comme n'importe qu'elle autre classe ;</li>
              <li>utiliser la macro <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> juste après la définition de la classe.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_520">Déclarer automatiquement les méta-propriétés de Qt (macro <i>Q_PROPERTY</i>)</a></p>
         <div class="manual_div_content">
           Toute classe héritant du type <i>QObject</i> peut déclarer ses propriétés avec la macro <i><a href="http://doc-snapshots.qt.io/4.8/properties.html" target="_blank">Q_PROPERTY</a></i> : les propriétés deviennent alors des méta-propriétés.
           Ce mécanisme permet au framework Qt de proposer un moteur d'introspection grâce au pré-compilateur <i>moc</i>.
           Les méta-propriétés peuvent alors être utilisées par exemple par le moteur <i>QML</i>, <i>QtScript</i>, etc.<br>
           <br>
           La bibliothèque <b>QxOrm</b> nécessite une déclaration de chacune des propriétés d'une classe dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> afin de proposer l'ensemble de ses fonctionnalités (persistance des données, sérialisation XML, JSON et binaire, etc.).
           Il est possible de déclarer automatiquement dans le contexte QxOrm l'ensemble des méta-propriétés sans maintenir une fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> : la macro <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> utilise le moteur d'introspection de Qt pour parcourir la liste des méta-propriétés.<br>
           <br>
           Voici un exemple d'utilisation avec la classe <i>TestQtProperty</i> se trouvant dans le dossier <i>./test/qxDllSample/dll1/include/</i> de la distribution QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span></font><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
<font style="background-color:yellow">QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></font></pre>
           </td></tr></tbody></table>
           <br>
           Pour ceux qui ne souhaitent pas utiliser la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>, il est possible d'écrire à la place les quatre lignes de code suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> <font style="background-color:yellow">qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span></font> <span class="operator">}
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le deuxième paramètre de la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i> permet d'indiquer la propriété qui servira de clé primaire dans la base de données.
           Si ce paramètre est vide, cela signifie que la classe ne possède pas de clé primaire ou bien que celle-ci est définie dans une classe de base.<br>
           <br>
           Toute propriété définie avec la macro <i>Q_PROPERTY</i> peut s'enregistrer dans le contexte QxOrm de deux manières différentes :<br>
           <b>1-</b> par la méthode classique : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> ou bien sans mentionner le pointeur vers la donnée membre de la classe : <i>t.data("my_property", 0);</i><br>
           <br>
           Peu importe la méthode d'enregistrement des propriétés dans le contexte QxOrm, elles seront accessibles par la même interface <i><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i> et proposent donc les mêmes fonctionnalités.
           Il est possible d'utiliser les deux méthodes dans une même fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>.
           Chaque méthode d'enregistrement présente des avantages et inconvénients.<br>
           <br>
           Voici la liste des avantages de la deuxième méthode d'enregistrement des propriétés dans le contexte QxOrm :
           <ul>
             <li>temps de compilation du projet beaucoup plus rapide ;</li>
             <li>taille de l'exécutable généré plus petite ;</li>
             <li>forte intégration avec le moteur d'introspection du framework Qt ;</li>
             <li>pas besoin de maintenir la fonction de mapping en utilisant la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>.</li>
           </ul>
           Voici les inconvénients par rapport à la méthode classique d'enregistrement des propriétés :
           <ul>
             <li>nécessite un héritage de la classe <i>QObject</i> pour pouvoir utiliser la macro <i>Q_PROPERTY</i> ;</li>
             <li>exécution du programme plus lente (utilisation du type <i>QVariant</i> à la place des <i>template</i> C++) ;</li>
             <li>ne supporte pas la notion de relation entre tables de la base de données (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>) ;</li>
             <li>pas d'accès au pointeur sur la donnée membre de la classe (conversion nécessaire au type <i>QVariant</i> pour accéder et modifier une valeur).</li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_60">Sérialisation</a></p>
      <div class="manual_div_content_1">
         La <b>sérialisation</b> est un mécanisme permettant de sauvegarder l'état d'une instance d'objet dans un flux (fichier, réseau, etc...) sous un certain format (binaire, XML, JSON, texte, etc...).
         La <b>désérialisation</b> est le processus inverse permettant de restaurer l'état d'un objet à partir d'un flux.
         Pour plus d'informations sur la notion de sérialisation : <a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">rendez-vous sur la page Wikipedia</a>.
         <br><br>
         Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée dans différents formats :
         <ul>
            <li><a href="#manual_600">format binaire avec le moteur QDataStream de Qt</a> ;</li>
            <li><a href="#manual_606">format JSON avec le moteur QJson de Qt</a> ;</li>
            <li><a href="#manual_610">format XML avec le moteur boost::serialization</a> ;</li>
            <li><a href="#manual_620">format binaire avec le moteur boost::serialization</a> ;</li>
            <li><a href="#manual_630">d'autres formats proposés par le moteur boost::serialization</a>.</li>
         </ul>
         <b>Remarque :</b> le moteur de sérialisation de la bibliothèque QxOrm permet de proposer des fonctionnalités supplémentaires comme <a href="#manual_640">le clonage d'entités</a>, <a href="#manual_650">le dump d'entités (format XML ou JSON)</a> ou encore <a href="#manual_80">le module QxService</a>.
         <br><br>
         <b>Autre remarque :</b> par défaut, toutes les propriétés enregistrées dans le contexte QxOrm sont sérialisables. Pour supprimer une propriété du moteur de sérialisation, il est possible d'écrire :<br>
         <br>
         <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setSerialize<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
         </td></tr></tbody></table>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_605">N° version pour assurer une compatibilité ascendante</a></p>
         <div class="manual_div_content">
            La compatibilité ascendante permet à une application de pouvoir désérialiser un flux provenant d'une version antérieure.
            La bibliothèque QxOrm impose un numéro de version par classe ainsi qu'un numéro de version pour chaque propriété enregistrée dans le contexte QxOrm afin de pouvoir assurer une compatibilité ascendante automatiquement.
            <br><br>
            Par exemple, imaginons une classe <i>person</i> créée dans <b>une application en version A</b> : nous renseignons dans la macro <i>QX_REGISTER_HPP</i> une n° de version à 0 (correspond à la 1ère version de notre classe <i>person</i>), ainsi qu'un n° de version à 0 pour chacune des propriétés de la classe (si paramètre non renseigné, 0 est la valeur par défaut).
            Ce qui donne le résultat suivant :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">)</span>

<span class="pre">#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Dans la version B de notre application</b>, nous modifions la classe <i>person</i> pour ajouter 2 nouvelles propriétés : <i>sex</i> et <i>address</i>. Notre classe ayant évoluée, il faut donc incrémenter son n° de version, et les nouvelles propriétés doivent avoir un n° de version à 1, ce qui donne :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>
   <font style="background-color:yellow">QString sex<span class="operator">;</span></font>
   <font style="background-color:yellow">QString address<span class="operator">;</span></font>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 1</font></span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>address<span class="operator">,</span><span class="string"> "address"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> en procédant ainsi, la bibliothèque QxOrm peut sérialiser une instance de la classe <i>person</i> dans une application en version A, puis désérialiser à partir de ce flux issu de la version A afin de recréer une instance de la classe <i>person</i> dans une version B de l'application.
            <br><br>
            <b>Autre remarque :</b> la suppression d'une propriété casse la compatibilité ascendante.
            Il est donc recommandé de ne jamais supprimer de propriété pour utiliser le moteur de sérialisation : il est possible par exemple de mettre une visibilité à <i>private</i> et de supprimer les accesseurs <i>get/set</i>, la propriété devenant ainsi inaccessible à l'extérieur de la classe, elle peut alors être considérée comme étant obsolète.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_600">Moteur QDataStream de Qt</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">le moteur QDataStream de Qt</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">namespace qx::serialization::qt</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_byte_array()</a> : sérialise une instance C++ (dont le type est enregistré dans le contexte QxOrm) en flux binaire de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_byte_array()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_string()</a> : même sérialisation que la fonction <i>to_byte_array()</i> + conversion en base 64 de type <a href="http://doc.qt.io/qt-5/qstring.html" target="_blank">QString</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_string()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé en base 64 ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file()</a> : sérialisation binaire d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file()</a> : restauration d'une instance C++ à partir d'un fichier contenant le flux binaire sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file_compressed()</a> : sérialisation binaire d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier compressé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file_compressed()</a> : restauration d'une instance C++ à partir d'un fichier compressé contenant le flux binaire sérialisé.</li>
            </ul>
            <b>Remarque :</b> la sérialisation <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> est portable (sérialisation/désérialisation compatible sur tous types d'environnement : Windows, Linux, Mac OS X, etc...).
            Le flux sérialisé est au format binaire : la taille du flux est donc réduite (comparé à un flux XML par exemple).
            La sérialisation <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> étant basée sur le moteur d'introspection de la bibliothèque QxOrm, elle est moins performante que les sérialisations basées sur le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a>.
            <br><br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt QDataStream serialization">
<pre><span class="comment">   // Fetch a drug with id '3' in a new variable
   // drug is a C++ class registered in QxOrm context
</span>   drug d<span class="operator">;</span>
   d<span class="operator">.</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span><span class="comment">

   // Serialize the drug to a file
</span>   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>to_file<span class="operator">(</span>d<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Import drug from file in a new instance
</span>   drug d2<span class="operator">;</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>from_file<span class="operator">(</span>d2<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Check if d == d2
</span>   qAssert<span class="operator">(</span>d<span class="operator"> ==</span> d2<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> dans l'exemple ci-dessus, nous sérialisons une instance C++.
            Toutes les fonctions du namespace <a href="../doxygen/html/namespaceqx_1_1serialization.html" target="_blank">qx::serialization</a> peuvent également sérialiser des listes d'instances C++.
            Pour connaitre la liste des collections supportées, rendez-vous dans le chapitre : <a href="#manual_390">Collections supportées par QxOrm</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_606">Moteur JSON de Qt</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://doc.qt.io/qt-5/json.html" target="_blank">le moteur QJson de Qt</a> (nécessite Qt5).
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">namespace qx::serialization::json</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_string()</a> : sérialise une instance C++ au format JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_string()</a> : restaure une instance C++ à partir d'un flux JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file()</a> : sérialisation JSON d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file()</a> : restauration d'une instance C++ à partir d'un fichier contenant le flux JSON sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file_compressed()</a> : sérialisation JSON d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier compressé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file_compressed()</a> : restauration d'une instance C++ à partir d'un fichier compressé contenant le flux JSON sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_byte_array()</a> : sérialise une instance C++ (dont le type est enregistré dans le contexte QxOrm) en flux binaire de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_byte_array()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a>.</li>
            </ul>
            <b>Remarque :</b> le moteur de sérialisation <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> est le plus permissif (comparé au <a href="#manual_610">moteur XML</a> par exemple) : en effet, les propriétés d'une instance peuvent être définies dans n'importe quel ordre, les propriétés peuvent être supprimées ou ajoutées.
            La désérialisation JSON ne retourne jamais d'erreur : elle ignore tout si le format des données est incorrect (le flux JSON doit par contre être valide) ou bien si des propriétés sont absentes : le moteur JSON est donc beaucoup plus flexible que <a href="#manual_610">le moteur XML</a>.
            <br><br>
            <b>Autre remarque :</b> la sérialisation <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> est basée sur le moteur d'introspection de la bibliothèque QxOrm, elle est moins performante que les sérialisations basées sur le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a>.
            <br><br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">   // Fetch a list of authors from database and serialize them to a JSON file
</span>   list_author list_of_author<span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_of_author<span class="operator">);</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>json<span class="operator">::</span>to_file<span class="operator">(</span>list_of_author<span class="operator">,</span><span class="string"> "list_of_author.json"</span><span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            L'exemple ci-dessus génère le flux JSON suivant :<br>
            <div class="json_pretty">
<pre>{
    "author_id_2": {
        "author_id": "author_id_2",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_2",
        "sex": 1
    },
    "author_id_3": {
        "author_id": "author_id_3",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_3",
        "sex": 1
    }
}</pre>
            </div>
            <br><br>
            <b>Remarque :</b> le <a href="#manual_97">module QxRestApi</a> de la bibliothèque QxOrm est basé sur le moteur de sérialisation JSON.
            <br><br>
            <b>Autre remarque :</b> il est possible de personnaliser le format de sortie JSON (filtrer les propriétés du flux JSON généré par la sérialisation).
            Les fonctions de sérialisation JSON dispose d'un paramètre optionnel de type <i>QString</i> nommé <i>format</i>.
            Les pré-requis pour utiliser le paramètre <i>format</i> sont :
            <ul>
               <li>le paramètre <i>format</i> doit être préfixé par : <i><b>filter:</b></i> ;</li>
               <li>les propriétés à exporter sont définies entre <i><b>{ }</b></i> ;</li>
               <li>les relations sont séparées par le caractère <i><b>|</b></i> ;</li>
               <li>il est possible d'utiliser le caractère <i><b>*</b></i> pour définir : <i>toutes les relations sur 1 niveau</i> ;</li>
               <li>le caractère <i><b>-</b></i> devant les <i><b>{ }</b></i> signifie : <i>toutes les propriétés sauf</i>.</li>
            </ul>
            <br>
            <b>Exemple :</b> voici un exemple de sérialisation JSON en définissant un format de sortie pour filtrer certaines propriétés :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">// Serialize a C++ instance to a JSON string</span>
QString jsonFormat = <font style="background-color:yellow"><span class="string">"filter: { blog_text } | author_id { name, birthdate } | list_comment { comment_text } -&gt; blog_id -&gt; *"</span></font>;
QString outputJsonFiltered = qx::serialization::json::to_string(blog, <span class="int">1</span>, <font style="background-color:yellow">jsonFormat</font>);
qDebug(<span class="string">"[QxOrm] custom JSON serialization process (filtered) : \n%s"</span>, qPrintable(outputJsonFiltered));

<span class="comment">// Fill a C++ instance based on a JSON string</span>
blog_ptr blogFromJsonFiltered; blogFromJsonFiltered.reset(<span class="operator">new</span> blog());
qx::serialization::json::from_string(blogFromJsonFiltered, outputJsonFiltered, <span class="int">1</span>, <font style="background-color:yellow">jsonFormat</font>);
qx::dump(blogFromJsonFiltered);
qAssert(blogFromJsonFiltered-&gt;m_text != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_dt_creation.isNull()); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_author->m_sex == author::unknown); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_author->m_name != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX.size() > <span class="int">0</span>);
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_dt_create.isNull()); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_text != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_blog);</pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_610">Moteur XML de boost::serialization</a></p>
         <div class="manual_div_content">
            Le moteur XML de <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> n'est pas activé par défaut : pour activer cette fonctionnalité, il est nécessaire de définir les options de compilation <b>_QX_ENABLE_BOOST_SERIALIZATION</b> et <b>_QX_ENABLE_BOOST_SERIALIZATION_XML</b> dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            Il est également nécessaire de compiler le binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> (ce module de boost n'étant pas <i>header only</i>), et de renseigner le chemin d'accès à ce binaire dans les variables <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> et <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> du <a href="#manual_220">fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            <br><br>
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">le moteur XML de boost::serialization</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">namespace qx::serialization::xml</a> (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>).
            <br><br>
            Ce type de sérialisation possède les caractéristiques suivantes :
            <ul>
               <li><i>portable</i> : compatible sur tous types d'environnement : Windows, Linux, Mac OS X, etc... ;</li>
               <li><i>slowest</i> : plus lente que les sérialisations <i>binary</i> et <i>text</i> ;</li>
               <li><i>largest</i> : taille des flux générés plus importante que les sérialisations <i>binary</i> et <i>text</i> ;</li>
               <li><i>human-readable</i> : un flux XML peut facilement être analysé et lu par un éditeur externe ou un être humain.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_620">Moteur binaire de boost::serialization</a></p>
         <div class="manual_div_content">
            Le moteur binaire de <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> n'est pas activé par défaut : pour activer cette fonctionnalité, il est nécessaire de définir les options de compilation <b>_QX_ENABLE_BOOST_SERIALIZATION</b> et <b>_QX_ENABLE_BOOST_SERIALIZATION_BINARY</b> dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            Il est également nécessaire de compiler le binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> (ce module de boost n'étant pas <i>header only</i>), et de renseigner le chemin d'accès à ce binaire dans les variables <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> et <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> du <a href="#manual_220">fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            <br><br>
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">le moteur binaire de boost::serialization</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">namespace qx::serialization::binary</a> (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>).
            <br><br>
            Ce type de sérialisation possède les caractéristiques suivantes :
            <ul>
               <li><i>non-portable</i> : un flux sérialisé sur un environnement Windows peut être incompatible si désérialisation sur un environnement Linux par exemple : il est donc fortement recommandé de rester sur le même environnement ;</li>
               <li><i>fastest</i> : plus rapide que les sérialisations <i>XML</i> et <i>text</i> ;</li>
               <li><i>smallest</i> : taille des flux générés réduite comparé aux sérialisations <i>XML</i> et <i>text</i> ;</li>
               <li><i>non-human-readable</i> : un flux binaire n'est pas lisible (pas de log possible par exemple).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_630">Autres types de sérialisation proposés par boost</a></p>
         <div class="manual_div_content">
            Le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> propose d'autres types de sérialisation.
            Ces différents types ne sont pas activés par défaut, pour utiliser ces fonctionnalités (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>), il est nécessaire de définir les options de compilation suivantes dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a> :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_POLYMORPHIC :</b> active les fonctions des espaces de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__binary.html" target="_blank">qx::serialization::polymorphic_binary</a>, <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__xml.html" target="_blank">qx::serialization::polymorphic_xml</a> et <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__text.html" target="_blank">qx::serialization::polymorphic_text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_TEXT :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1text.html" target="_blank">qx::serialization::text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_PORTABLE_BINARY :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1portable__binary.html" target="_blank">qx::serialization::portable_binary</a> (non supporté officiellement par la bibliothèque boost) ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_BINARY :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1binary.html" target="_blank">qx::serialization::wide::binary</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_TEXT :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1text.html" target="_blank">qx::serialization::wide::text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_XML :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1xml.html" target="_blank">qx::serialization::wide::xml</a>.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_640">Cloner une instance C++</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être clonée en utilisant une des fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>std::shared_ptr&lt;T&gt;</i> (par défaut type égal à <i>boost::shared_ptr&lt;T&gt;</i>, si C++11 activé alors type égal à <i>std::shared_ptr&lt;T&gt;</i>) ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_boost_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>boost::shared_ptr&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_qt_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>QSharedPointer&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_std_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>std::shared_ptr&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_nude_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> sous forme de pointeur nu : attention à libérer la mémoire (<i>delete</i>) une fois l'utilisation du pointeur nu terminée (afin d'éviter des fuites mémoire).</li>
            </ul>
            <b>Par exemple :</b>
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone">
<pre>   drug_ptr d1<span class="operator">;</span>
   d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span>
   d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span><span class="comment">

   // Clone a drug
</span>   <font style="background-color:yellow">drug_ptr d_clone<span class="operator"> =</span> qx<span class="operator">::</span>clone<span class="operator">(*</span> d1<span class="operator">);</span></font><span class="comment">

   // Check if (d1 == d_clone)
</span>   qAssert<span class="operator">((*</span> d1<span class="operator">) == (*</span> d_clone<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque importante :</b> il faut faire attention lorsqu'on clone un pointeur intelligent (<i>boost::shared_ptr</i> ou <i>QSharedPointer</i> par exemple) dont l'élément parent (<i>root</i>) peut être référencé plusieurs fois dans sa hiérarchie (cas d'une structure en arbre par exemple).
            Dans ce cas, afin de protéger le pointeur parent d'une double suppression (2 pointeurs intelligents qui pointent sur le même pointeur brut), il est conseillé de cloner de cette façon :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone smart-pointer">
<pre><span class="comment">// 'pOther' type is boost::shared_ptr&lt;myClass&gt; (smart-pointer)
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt; *</span> pCloneTemp<span class="operator"> =</span> qx<span class="operator">::</span>clone_to_nude_ptr<span class="operator">(</span>pOther<span class="operator">);</span>
boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;</span> pClone<span class="operator"> = (</span>pCloneTemp<span class="operator"> ? (*</span> pCloneTemp<span class="operator">) :</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;());</span><span class="flow">
if</span><span class="operator"> (</span>pCloneTemp<span class="operator">) {</span><span class="keyword"> delete</span> pCloneTemp<span class="operator">;</span> pCloneTemp<span class="operator"> =</span> NULL<span class="operator">; }</span><span class="comment">
// Now use 'pClone' ...</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_650">Afficher le détail d'une instance C++ (dump au format XML ou JSON)</a></p>
         <div class="manual_div_content">
            Toute instance C++ enregistrée dans le contexte QxOrm peut être affichée <a href="#manual_606">au format JSON</a>.
            Si le <a href="#manual_610">moteur XML de boost::serialization</a> est activé, alors il est également possible d'afficher un dump sous format XML (paramètre d'entrée de la fonction <i>qx::dump</i>).
            Cette fonctionnalité peut être utile pour faire du débogage par exemple, ou bien pour générer des logs.
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::dump">
<pre>   blog_ptr b<span class="operator">;</span>
   b<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   b<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_all_relation<span class="operator">(</span>b<span class="operator">);</span><span class="comment">

   // Dump 'b' instance result from database (XML or JSON serialization)
   // Second parameter is optional : 'true' = JSON format, 'false' = XML format
</span>   <font style="background-color:yellow">qx<span class="operator">::</span>dump<span class="operator">(</span>b, false<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui génère le flux XML suivant :
            <br><br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
[QxOrm] start dump 'boost::shared_ptr&lt;blog&gt;'
&lt;boost.shared_ptr-blog- class_id="0" tracking_level="0" version="1"&gt;
	&lt;px class_id="1" tracking_level="1" version="0" object_id="_0"&gt;
		&lt;blog_id&gt;113&lt;/blog_id&gt;
		&lt;blog_text class_id="2" tracking_level="0" version="0"&gt;update blog_text_1&lt;/blog_text&gt;
		&lt;date_creation class_id="3" tracking_level="0" version="0"&gt;20100409162612000&lt;/date_creation&gt;
		&lt;author_id class_id="4" tracking_level="0" version="1"&gt;
			&lt;px class_id="5" tracking_level="1" version="0" object_id="_1"&gt;
				&lt;author_id&gt;author_id_2&lt;/author_id&gt;
				&lt;name&gt;author_2&lt;/name&gt;
				&lt;birthdate class_id="6" tracking_level="0" version="0"&gt;20100409&lt;/birthdate&gt;
				&lt;sex&gt;1&lt;/sex&gt;
				&lt;list_blog class_id="7" tracking_level="0" version="0"&gt;
					&lt;count&gt;0&lt;/count&gt;
					&lt;item_version&gt;1&lt;/item_version&gt;
				&lt;/list_blog&gt;
			&lt;/px&gt;
		&lt;/author_id&gt;
		&lt;list_comment class_id="8" tracking_level="0" version="0"&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="9" tracking_level="0" version="1"&gt;
				&lt;px class_id="10" tracking_level="1" version="0" object_id="_2"&gt;
					&lt;comment_id&gt;209&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_1 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_3"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category class_id="11" tracking_level="0" version="0"&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;px class_id_reference="10" object_id="_4"&gt;
					&lt;comment_id&gt;210&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_2 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_5"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
		&lt;/list_comment&gt;
		&lt;list_category&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="12" tracking_level="0" version="0"&gt;
				&lt;first&gt;355&lt;/first&gt;
				&lt;second class_id="13" tracking_level="0" version="0"&gt;
					&lt;qt_shared_ptr class_id="14" tracking_level="1" version="0" object_id="_6"&gt;
						&lt;category_id&gt;355&lt;/category_id&gt;
						&lt;name&gt;category_1&lt;/name&gt;
						&lt;description&gt;desc_1&lt;/description&gt;
						&lt;list_blog class_id="15" tracking_level="0" version="0"&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;first&gt;357&lt;/first&gt;
				&lt;second&gt;
					&lt;qt_shared_ptr class_id_reference="14" object_id="_7"&gt;
						&lt;category_id&gt;357&lt;/category_id&gt;
						&lt;name&gt;category_3&lt;/name&gt;
						&lt;description&gt;desc_3&lt;/description&gt;
						&lt;list_blog&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
		&lt;/list_category&gt;
	&lt;/px&gt;
&lt;/boost.shared_ptr-blog-&gt;
[QxOrm] end dump 'boost::shared_ptr&lt;blog&gt;'
</pre>
            </div>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_70">Introspection - Réflexion</a></p>
      <div class="manual_div_content_1">
           Toute classe enregistrée dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> peut être utilisée par le moteur d'introspection (ou réflexion) de la bibliothèque QxOrm.
           Le moteur d'introspection permet d'obtenir de façon dynamique (donc pendant l'exécution du programme) des informations propres à un type.
           Ces informations correspondent à des <i>méta-données</i> et décrivent de façon exhaustive les caractéristiques d'une classe (propriétés, méthodes, etc.).
           De nombreux langages de programmation (par exemple Java ou C#) intègrent nativement ce mécanisme, ce n'est pas le cas du C++, c'est pourquoi la bibliothèque QxOrm émule un moteur d'introspection.
           Pour plus de détails sur l'introspection (ou réflexion), <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" target="_blank">rendez-vous sur la page Wikipedia</a>.
           <br><br>
           Voici la liste des classes disponibles pour accéder aux <i>méta-données</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton permettant de parcourir l'ensemble des classes enregistrées dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface pour une classe enregistrée dans le contexte QxOrm ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : liste des propriétés associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface pour une propriété d'une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : liste des méthodes associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface pour une méthode d'une classe (<i>static</i> ou <i>non static</i>).</li>
           </ul>
           Une instance de type <a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank"><i>qx::IxClass</i></a> possède la liste des propriétés d'une classe (<a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank"><i>qx::IxDataMemberX</i></a>) ainsi que la liste des méthodes d'une classe (<a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank"><i>qx::IxFunctionX</i></a>).<br>
           <br>
           Le moteur d'introspection de la bibliothèque QxOrm permet par exemple de :
           <ul>
             <li><a href="#manual_740">créer dynamiquement une instance en fonction du nom d'une classe sous forme de chaîne de caractères (<i>qx::create()</i>)</a> ;</li>
             <li><a href="#manual_710">accéder/modifier le contenu d'un champ d'un objet de façon dynamique</a> en prenant pour paramètres un objet et le nom du champ qu'on souhaite accéder/modifier (<i>qx::IxDataMember::getValue()</i> et <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li><a href="#manual_730">invoquer une méthode de classe de façon dynamique</a>, en gérant bien entendu le passage des paramètres souhaités à la méthode (<i>qx::IxFunction::invoke()</i>) ;</li>
             <li><a href="#manual_750">accéder à la hiérarchie d'une classe (<i>qx::IxClass::getBaseClass()</i>)</a>.</li>
           </ul>
           <br>
           <b>Remarque :</b> le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> de la bibliothèque QxOrm (<a href="./tutorial_2.html" target="_blank">cliquez ici pour accéder au tutoriel</a>) permettant de créer un serveur d'applications C++ est basé sur le moteur d'introspection pour appeler dynamiquement les méthodes de type service (demande du client) sur le serveur, ainsi que pour créer dynamiquement les instances des classes de paramètre (entrée/sortie).<br>
           <br>
           <b>Autre remarque :</b> il est possible d'ajouter de nouvelles informations au moteur d'introspection en utilisant <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank">la notion de <i>property bag</i></a>.
           En effet, les classes <i>qx::IxClass</i>, <i>qx::IxDataMember</i> et <i>qx::IxFunction</i> possèdent chacune une liste d'éléments de type <i>QVariant</i> accessibles par clé de type <i>QString</i> (voir <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank">la classe <i>qx::QxPropertyBag</i></a> pour plus de détails sur cette notion).
           <br><br>
           <b>Autre remarque :</b> afin d'initialiser le moteur d'introspection QxOrm, il est recommandé d'appeler la fonction suivante en début de programme (<i>main</i> par exemple) :
           <br><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Register introspection engine">
<pre><span class="comment">// Following command is recommanded to initialize QxOrm introspection engine</span>
qx::QxClassX::registerAllClasses(true);</pre>
           </td></tr></tbody></table>
           <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_710">Obtenir dynamiquement la valeur d'une donnée membre</a></p>
         <div class="manual_div_content">
            Pour obtenir dynamiquement la valeur d'une donnée membre en utilisant le moteur d'introspection de la bibliothèque QxOrm, il est nécessaire de passer par la classe : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a>.
            La classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> fournit plusieurs méthodes pour obtenir la valeur d'une donnée membre (chacune prenant en paramètre un pointeur générique de type <i>void *</i> correspondant à l'adresse de l'instance courante) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">toVariant()</a> : retourne la valeur de la donnée membre convertie en <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValue&lt;T&gt;()</a> : retourne la valeur avec son type réel précisé dans le paramètre template T ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValueAnyPtr()</a> : retourne la valeur encapsulée par le type <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any</a> (possibilité de caster ensuite en utilisant : <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any_cast</a>).</li>
            </ul>
            <b>Par exemple :</b> imaginons un pointeur générique de type <i>void *</i> vers une classe <i>person</i>. Nous pouvons obtenir la valeur de la propriété <i>firstName</i> de type <i>QString</i> de la façon suivante :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to get the data member value with the real type
</span>QString sFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">);</span><span class="comment">

// Second method to get the data member value converted in QVariant
</span>QVariant vFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>toVariant<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Third method to get the value encapsulated in qx::any type
</span>boost<span class="operator">::</span>any aFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValueAnyPtr<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Check if all values are equals
</span>qAssert<span class="operator">((</span>sFirstName<span class="operator"> ==</span> vFirstName<span class="operator">.</span>toString<span class="operator">()) &amp;&amp; (</span>sFirstName<span class="operator"> == (*</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span>QString<span class="operator"> *&gt;(</span>aFirstName<span class="operator">))));</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_720">Valoriser dynamiquement une donnée membre</a></p>
         <div class="manual_div_content">
            De la même façon que pour obtenir la valeur d'une donnée membre, la classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> permet de valoriser une donnée membre (modifier sa valeur).
            La classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> fournit les 2 méthodes suivantes (chacune prend en paramètre un pointeur de type <i>void *</i> correspondant à l'adresse de l'instance courante, ainsi que la nouvelle valeur à positionner) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">fromVariant()</a> : valorise la donnée membre en fonction du paramètre de type <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">setValue&lt;T&gt;()</a> : valorise la donnée membre avec un paramètre du type réel T de la donnée membre.</li>
            </ul>
            <b>Par exemple :</b> imaginons un pointeur générique de type <i>void *</i> vers une classe <i>person</i>. Nous pouvons modifier la valeur de la propriété <i>firstName</i> de type <i>QString</i> de la façon suivante :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to change the data member value
</span>QVariant vFirstName<span class="operator"> =</span> QVariant<span class="operator">(</span><span class="string">"my new firstname 1"</span><span class="operator">);</span>
pDataMember<span class="operator">-&gt;</span>fromVariant<span class="operator">(</span>p<span class="operator">,</span> vFirstName<span class="operator">);</span><span class="comment">

// Other method to change the data member value (using real type)
</span>QString sFirstName<span class="operator"> =</span><span class="string"> "other firstname 2"</span><span class="operator">;</span>
pDataMember<span class="operator">-&gt;</span>setValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">,</span> sFirstName<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_730">Appeler dynamiquement une fonction</a></p>
         <div class="manual_div_content">
            Tout comme les données membre (propriétés), il est possible d'enregistrer des méthodes membre (fonctions) dans le contexte QxOrm (support des méthodes <i>static</i> et <i>non static</i>).
            Le moteur d'introspection de la bibliothèque QxOrm permet d'invoquer dynamiquement des méthodes de classe.
            Toutes les fonctions enregistrées dans le contexte QxOrm sont associées à une instance de la classe : <a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a>.
            Pour enregistrer des méthodes dans le contexte QxOrm, il faut utiliser :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a> : enregistre une méthode de classe sans paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a> : enregistre une méthode de classe avec 1 paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_2()</a> : enregistre une méthode de classe avec 2 paramètres ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_X()</a> : le suffixe <i>X</i> correspondant au nombre de paramètres de la méthode de classe ;</li>
               <br>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_0()</a> : enregistre une méthode de classe <i>static</i> sans paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_1()</a> : enregistre une méthode de classe <i>static</i> avec 1 paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_2()</a> : enregistre une méthode de classe <i>static</i> avec 2 paramètres ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_X()</a> : le suffixe <i>X</i> correspondant au nombre de paramètres de la méthode de classe <i>static</i> ;</li>
            </ul>
            <b>Par exemple :</b> on souhaite enregistrer dans le contexte QxOrm plusieurs méthodes d'une classe <i>person</i> :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span>

   <font style="background-color:yellow"><span class="type">long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="type">void</span> myMethodWith2Params<span class="operator">(</span><span class="type">int</span> param1<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> param2<span class="operator">);</span></font>

   <font style="background-color:yellow"><span class="keyword">static</span><span class="type"> double</span> myStaticMethodWith1Param<span class="operator">(</span><span class="type">long</span> param1<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  <font style="background-color:yellow">t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>getId<span class="operator">,</span><span class="string"> "getId"</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>fct_2<span class="operator">&lt;</span><span class="type">void</span><span class="operator">,</span><span class="type"> int</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;&gt;(&amp;</span> person<span class="operator">::</span>myMethodWith2Params<span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">);</span></font>

  <font style="background-color:yellow">t<span class="operator">.</span>fctStatic_1<span class="operator">&lt;</span><span class="type">double</span><span class="operator">,</span><span class="type"> long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>myStaticMethodWith1Param<span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Une fois enregistrées dans le contexte QxOrm, il est possible d'appeler dynamiquement ces fonctions avec les méthodes <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invoke()</a> et <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invokeStatic()</a> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre>   <span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">   void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

   // Call method 'long getId() const' and get return value
</span>   boost<span class="operator">::</span>any returnValue<span class="operator">;</span>
   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "getId"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> ""</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   long</span> lId<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a string (default separator for parameters is character '|')
   // This way to pass parameters to the function works only if parameters are numeric or string
   // If parameters are more complex, then you have to encapsulate parameters in a list of qx::any, as shown below
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> "36|my string param 2"</span><span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a list of qx::any : std::vector&lt;qx::any&gt;
</span>   std<span class="operator">::</span>vector<span class="operator">&lt;</span>boost<span class="operator">::</span>any<span class="operator">&gt;</span> lstParams<span class="operator">;</span><span class="type">
   int</span> iParam1<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>iParam1<span class="operator">);</span><span class="comment"> // Parameter at position 1
</span>   QString sParam2<span class="operator"> =</span><span class="string"> "my string param 2"</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>sParam2<span class="operator">);</span><span class="comment"> // Parameter at position 2
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span> lstParams<span class="operator">);</span><span class="comment">

   // Call static method 'myStaticMethodWith1Param' with 1 parameter and get return value
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invokeStatic<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">,</span><span class="string"> "19"</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   double</span> dValue<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_740">Créer une instance C++ dynamiquement</a></p>
         <div class="manual_div_content">
            Le moteur d'introspection de la bibliothèque QxOrm permet de créer dynamiquement des instances de classe (<a href="../doxygen/html/group___qx_factory.html" target="_blank">module QxFactory</a>, modèle de conception fabrique ou design pattern factory) avec les méthodes suivantes :
            <ul>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any</a> (contenant un pointeur intelligent de type <i>std::shared_ptr</i>, alias de <i>boost::shared_ptr</i> par défaut) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_nude_ptr&lt;T&gt;(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme d'un pointeur nu de type <i>T *</i> (attention à libérer la mémoire de ce pointeur pour éviter les fuites mémoire) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_void_ptr(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme d'un pointeur nu de type <i>void *</i> (attention à libérer la mémoire de ce pointeur pour éviter les fuites mémoire).</li>
            </ul>
            <b>Par exemple :</b> <a href="#manual_80">le module QxService</a> de la bibliothèque QxOrm utilise ce mécanisme pour créer dynamiquement les instances de classe de service pour exécuter les routines côté serveur :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - factory">
<pre>   qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator"> *</span> ptr<span class="operator"> =</span> qx<span class="operator">::</span>create_nude_ptr<span class="operator">&lt;</span>qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">&gt;(</span>m_sServiceName<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_750">Parcourir la liste des classes/propriétés enregistrées dans le contexte QxOrm</a></p>
         <div class="manual_div_content">
           Voici un exemple d'utilisation du moteur d'introspection de la bibliothèque QxOrm : comment lister toutes les classes, propriétés et méthodes enregistrées dans le contexte QxOrm ?<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si on utilise la méthode <i>qx::QxClassX::dumpAllClasses()</i> avec le <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a>, voici le résultat obtenu :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_80">Services : transférer la couche de données persistante sur le réseau (module QxService)</a></p>
      <div class="manual_div_content_1">
         Le module <a href="../doxygen/html/group___qx_service.html" target="_blank"><b>QxService</b></a> de la bibliothèque <b>QxOrm</b> permet de créer rapidement un <b>serveur d'applications C++</b> performant (notion de <i>services</i> avec <i>demande</i> du client et <i>réponse</i> du serveur).
         <font style="background-color:yellow"><b><a href="./tutorial_2.html">Un tutoriel est disponible sur le site QxOrm</a></b></font> afin de présenter un exemple d'utilisation du module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
         Le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> est basé sur <a href="#manual_70">le moteur d'introspection</a> ainsi que <a href="#manual_60">le moteur de sérialisation</a> de la bibliothèque QxOrm afin de transférer la couche de données persistante sur le réseau et exécuter automatiquement les routines côté serveur.
         <br><br>
         <b>Remarque :</b> pour activer le module <b>QxService</b>, il faut définir l'option de compilation <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> dans <a href="#manual_220">le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a>.
         Cette option de compilation ajoute une dépendance au binaire <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> fourni avec la bibliothèque Qt.
         <br><br>
         <b>Autre remarque :</b> l'application <b>QxEntityEditor</b> est livrée avec le plugin <i>QxEECppServicesExport</i> : ce plugin génère automatiquement le code source nécessaire pour transférer l'ensemble des entités d'un projet sur le réseau.
         Une liste de méthodes client/serveur est générée automatiquement :
         <ul>
            <li><i>count() :</i> requête client/serveur pour compter le nombre d'éléments (avec possibilité d'utiliser un filtre SQL) ;</li>
            <li><i>fetchById() :</i> requête client/serveur pour alimenter les propriétés d'une entité en fonction de son identifiant ;</li>
            <li><i>fetchAll() :</i> requête client/serveur pour alimenter les propriétés de toutes les entités d'une table ;</li>
            <li><i>fetchByQuery() :</i> requête client/serveur pour alimenter les propriétés des entités filtrées par une requête SQL ;</li>
            <li><i>insert() :</i> requête client/serveur pour insérer les données d'une entité ;</li>
            <li><i>update() :</i> requête client/serveur pour mettre à jour les données d'une entité ;</li>
            <li><i>save() :</i> requête client/serveur pour sauvegarder les données d'une entité (insertion ou mise à jour) ;</li>
            <li><i>deleteById() :</i> requête client/serveur pour supprimer une entité en fonction de son identifiant ;</li>
            <li><i>deleteAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée à une entité ;</li>
            <li><i>deleteByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL ;</li>
            <li><i>destroyById() :</i> requête client/serveur pour supprimer une entité en fonction de son identifiant (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>destroyAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée à une entité (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>destroyByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>executeQuery() :</i> requête client/serveur pour exécuter <a href="#manual_3610">une requête SQL personnalisée ou procédure stockée</a> ;</li>
            <li><i>exist() :</i> requête client/serveur pour tester l'existence d'une entité en fonction de son identifiant ;</li>
            <li><i>isValid() :</i> requête client/serveur pour tester la validité d'une entité (<a href="#manual_420">module QxValidator</a>).</li>
         </ul>
         Il est possible d'ajouter de nouveaux services ou de personnaliser les services générés automatiquement par l'application <b>QxEntityEditor</b>.
         <br><br>
         L'objectif de ce chapite est de présenter les concepts à mettre en oeuvre pour utiliser le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> :
         <ul>
            <li><a href="#manual_810">Définition des paramètres d'entrée/sortie d'un service (requête/réponse)</a> ;</li>
            <li><a href="#manual_820">Définition des fonctions publiées par un service</a> ;</li>
            <li><a href="#manual_825">Liste des options disponibles côté serveur</a> ;</li>
            <li><a href="#manual_826">Paramétrage de la connexion côté client</a> ;</li>
            <li><a href="#manual_830">Gestion de l'authentification dans un service</a> ;</li>
            <li><a href="#manual_840">Requêtes client/serveur asynchrones</a>.</li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_810">Paramètres d'entrée/sortie d'un service (requête/réponse)</a></p>
         <div class="manual_div_content">
            Chaque fonction publiée par un service dispose de paramètres d'entrée (demande du client) et de paramètres de sortie (réponse du serveur).
            Ces paramètres d'entrée/sortie doivent hériter de l'interface <a href="../doxygen/html/classqx_1_1service_1_1_ix_parameter" target="_blank">qx::service::IxParameter</a> et doivent être enregistrées dans le contexte QxOrm (par la fonction <i>void qx::register_class&lt;T&gt;</i>).
            <br><br>
            <b>Par exemple :</b> voici un exemple de paramètres d'entrée/sortie générés automatiquement par l'application <b>QxEntityEditor</b> basé sur la classe <i>blog</i> du <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a> :
            <br><br>
            <i>* Fichier blog.services.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_of_blog<span class="operator">;</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>list_of_blog<span class="operator">&gt;</span> list_of_blog_ptr<span class="operator">;</span><span class="comment">

/* -- Service Input Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_input<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_input<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_input<span class="operator">();</span><span class="type">

   long</span> id<span class="operator">;</span><span class="comment">                   //!&lt; Id to fetch or delete
</span>   blog_ptr instance<span class="operator">;</span><span class="comment">         //!&lt; Single instance to fetch, insert, update, delete or validate
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">     //!&lt; List of instances to fetch, insert, update, delete or validate
</span>   qx_query query<span class="operator">;</span><span class="comment">            //!&lt; Query to execute when fetching, updating or deleting
</span>   QStringList columns<span class="operator">;</span><span class="comment">       //!&lt; List of columns to fetch or update
</span>   QStringList relations<span class="operator">;</span><span class="comment">     //!&lt; List of relations to fetch
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt;</span> blog_input_ptr<span class="operator">;</span><span class="comment">

/* -- Service Output Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_output<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_output<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_output<span class="operator">();</span>

   blog_ptr instance<span class="operator">;</span><span class="comment">            //!&lt; Single instance from server
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">        //!&lt; List of instances from server
</span>   QSqlError error<span class="operator">;</span><span class="comment">              //!&lt; If a SQL error occurred, this output parameter is not empty
</span>   qx<span class="operator">::</span>QxInvalidValueX invalid<span class="operator">;</span><span class="comment">  //!&lt; Check if a single instance (or a list of instances) is valid
</span>   qx_query query<span class="operator">;</span><span class="comment">               //!&lt; Query which contains all results
</span><span class="type">   long</span> count<span class="operator">;</span><span class="comment">                   //!&lt; Count how many items in database using a query or not
</span>   qx_bool exist<span class="operator">;</span><span class="comment">                //!&lt; Check if a single instance (or a list of instances) exist in database
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt;</span> blog_output_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_output<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier blog.services.gen.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> services_blog_output<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>columns<span class="operator">,</span><span class="string"> "columns"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>relations<span class="operator">,</span><span class="string"> "relations"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>error<span class="operator">,</span><span class="string"> "error"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>invalid<span class="operator">,</span><span class="string"> "invalid"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>count<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>exist<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> comme on peut le constater sur l'exemple ci-dessus, les paramètres d'entrée/sortie peuvent contenir des types complexes (des collections, des pointeurs, etc...).
            Il est donc possible et très simple de transférer des structures complexes sur le réseau avec le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_820">Définir les fonctions publiées par un service</a></p>
         <div class="manual_div_content">
            Chaque service enregistré dans le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> publie une liste de fonctions accessibles côté client (requêtes client/serveur).
            Les services doivent hériter de la classe de base <a href="../doxygen/html/classqx_1_1service_1_1_qx_service.html" target="_blank">qx::service::QxService&lt;INPUT, OUTPUT&gt;</a> (les paramètres template <i>INPUT</i> et <i>OUTPUT</i> correspondant <a href="#manual_810">aux paramètres d'entrée/sortie</a>) et doivent être enregistrés dans le contexte QxOrm (par la fonction <i>void qx::register_class&lt;T&gt;</i>).
            <br><br>
            <b>Par exemple :</b> voici un exemple de service généré automatiquement par l'application <b>QxEntityEditor</b> basé sur la classe <i>blog</i> du <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a> :
            <br><br>
            <i>* Fichier blog.services.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="comment">

/* -- Service Definition -- */</span>

<font style="background-color:yellow"><span class="keyword">typedef</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span> blog_input<span class="operator">,</span> blog_output<span class="operator"> &gt;</span> blog_base_class<span class="operator">;</span><span class="keyword">
class</span> QXBLOG_SERVICES_EXPORT blog_services<span class="operator"> :</span><span class="keyword"> public</span> blog_base_class</font><span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_services<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_services<span class="operator">();</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   void</span> fetchById_<span class="operator">();</span><span class="type">
   void</span> fetchAll_<span class="operator">();</span><span class="type">
   void</span> fetchByQuery_<span class="operator">();</span><span class="type">

   void</span> insert_<span class="operator">();</span><span class="type">
   void</span> update_<span class="operator">();</span><span class="type">
   void</span> save_<span class="operator">();</span><span class="type">
   void</span> deleteById_<span class="operator">();</span><span class="type">
   void</span> deleteAll_<span class="operator">();</span><span class="type">
   void</span> deleteByQuery_<span class="operator">();</span><span class="type">
   void</span> destroyById_<span class="operator">();</span><span class="type">
   void</span> destroyAll_<span class="operator">();</span><span class="type">
   void</span> destroyByQuery_<span class="operator">();</span><span class="type">

   void</span> executeQuery_<span class="operator">();</span><span class="type">
   void</span> callQuery_<span class="operator">();</span><span class="type">
   void</span> exist_<span class="operator">();</span><span class="type">
   void</span> count_<span class="operator">();</span><span class="type">
   void</span> isValid_<span class="operator">();</span><span class="pre">

#ifdef _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="keyword">
public</span><span class="operator">:</span>

   blog_ptr fetchById<span class="operator">(</span><span class="type">long</span> id<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchAll<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span>
                                      <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError insert<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError insert<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError deleteById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError deleteAll<span class="operator">();</span>
   QSqlError deleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError destroyAll<span class="operator">();</span>
   QSqlError destroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>

   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError callQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError count<span class="operator">(</span><span class="type">long</span><span class="operator"> &amp;</span> lCount<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">());</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span><span class="pre">

#endif // _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt;</span> blog_services_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_services<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier blog.services.gen.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> services_blog_services<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span>

<font style="background-color:yellow"><span class="keyword">template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchById_<span class="operator">,</span><span class="string"> "fetchById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchAll_<span class="operator">,</span><span class="string"> "fetchAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchByQuery_<span class="operator">,</span><span class="string"> "fetchByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>insert_<span class="operator">,</span><span class="string"> "insert"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>update_<span class="operator">,</span><span class="string"> "update"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>save_<span class="operator">,</span><span class="string"> "save"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteById_<span class="operator">,</span><span class="string"> "deleteById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteAll_<span class="operator">,</span><span class="string"> "deleteAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteByQuery_<span class="operator">,</span><span class="string"> "deleteByQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyById_<span class="operator">,</span><span class="string"> "destroyById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyAll_<span class="operator">,</span><span class="string"> "destroyAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyByQuery_<span class="operator">,</span><span class="string"> "destroyByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>executeQuery_<span class="operator">,</span><span class="string"> "executeQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>callQuery_<span class="operator">,</span><span class="string"> "callQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>exist_<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>count_<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>isValid_<span class="operator">,</span><span class="string"> "isValid"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx

// Then there is the implementation of all functions provided by the service...</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> une fois définies dans le contexte QxOrm, le client peut appeler les fonctions publiées par le service : les routines côté serveur sont alors exécutées automatiquement.
            La sérialisation des données ainsi que la gestion de la couche réseau pour le transfert des données sont gérées de manière transparente par le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_825">Liste des options disponibles côté serveur</a></p>
         <div class="manual_div_content">
            Le serveur d'application C++ basé sur le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> dispose de plusieurs paramètres accessibles par la classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> :
            <ul>
               <li><i>setPort() :</i> port d'écoute pour recevoir les requêtes du client et envoyer les réponses du serveur ;</li>
               <li><i>setThreadCount() :</i> nombre de threads disponibles côté serveur pour traiter les demandes du client ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">type de sérialisation</a> utilisé pour envoyer les réponses du serveur ;</li>
               <li><i>setCompressData() :</i> permet de définir si les données renvoyées par le serveur sont compressées ou non ;</li>
               <li><i>setEncryptData() :</i> permet de définir si les données renvoyées par le serveur sont cryptées ou non (avec possibilité de renseigner une clé de cryptage).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_826">Paramétrage de la connexion côté client</a></p>
         <div class="manual_div_content">
            La couche cliente basée sur le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> dispose de plusieurs paramètres accessibles par la classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> :
            <ul>
               <li><i>setIp() :</i> adresse IP du serveur d'application C++ ;</li>
               <li><i>setPort() :</i> port utilisé par le serveur d'application C++ ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">type de sérialisation</a> utilisé par la couche cliente pour envoyer les requêtes du client au serveur ;</li>
               <li><i>setCompressData() :</i> permet de définir si les données envoyées au serveur sont compressées ou non ;</li>
               <li><i>setEncryptData() :</i> permet de définir si les données envoyées au serveur sont cryptées ou non (avec possibilité de renseigner une clé de cryptage).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_830">Gestion de l'authentification dans un service</a></p>
         <div class="manual_div_content">
            Il est classique d'implémenter un contrôle au niveau du serveur pour vérifier l'utilisateur connecté à la couche cliente.
            L'interface <a href="../doxygen/html/classqx_1_1service_1_1_ix_service.html" target="_blank">qx::service::IxService</a> (classe de base de tous les services enregistrés par le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>) fournit des méthodes virtuelles qui peuvent être surchargées pour gérer cette problématique :
            <ul>
               <li><i>onBeforeProcess() :</i> méthode virtuelle appelée systématiquement avant exécution de la routine serveur ;</li>
               <li><i>onAfterProcess() :</i> méthode virtuelle appelée systématiquement après exécution de la routine serveur.</li>
            </ul>
            <br>
            <b>Par exemple :</b> voici une classe de base nommée <i>ParameterAuthentication</i> qui peut être utilisée par tous les paramètres d'entrée/sortie, cette classe fournit 3 propriétés <i>login</i>, <i>password</i> et <i>token</i> :
            <br><br>
            <i>* Fichier ParameterAuthentication.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MY_DLL_EXPORT ParameterAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ParameterAuthentication<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ParameterAuthentication<span class="operator">();</span>
 
   QString login<span class="operator">;</span>
   QString password<span class="operator">;</span>
   QString token<span class="operator">;</span><span class="comment">
   // etc..., put here all properties required by the authentication process
</span><span class="operator"> 
};</span><span class="keyword">
 
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt;</span> ParameterAuthentication_ptr<span class="operator">;</span>
 
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> ParameterAuthentication<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier ParameterAuthentication.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> ParameterAuthentication<span class="operator">)</span><span class="keyword">
 
namespace</span> qx<span class="operator"> {</span><span class="keyword">
 
template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>login<span class="operator">,</span><span class="string"> "login"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>password<span class="operator">,</span><span class="string"> "password"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>token<span class="operator">,</span><span class="string"> "token"</span><span class="operator">);
}
 
}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Maintenant que l'on dispose d'une classe de base pour nos paramètres (<i>ParameterAuthentication</i>), nous allons créer une classe de base utilisée par tous nos services nommée <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i>.
            Cette classe de base des services va surcharger la méthode virtuelle <i>onBeforeProcess()</i> afin de gérer l'authentification avant exécution de la routine serveur :
            <br><br>
            <i>* Fichier ServiceAuthentication.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "ParameterAuthentication.h"
</span><span class="keyword"> 
template</span><span class="operator"> &lt;</span><span class="keyword">class</span> INPUT<span class="operator">,</span><span class="keyword"> class</span> OUTPUT<span class="operator">&gt;</span><span class="keyword">
class</span> ServiceAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ServiceAuthentication<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> sServiceName<span class="operator">) :</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;(</span>sServiceName<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ServiceAuthentication<span class="operator">() { ; }</span>
 
   <font style="background-color:yellow"><span class="keyword">virtual</span><span class="type"> void</span> onBeforeProcess<span class="operator">()</span></font>
   <span class="operator">{</span><span class="comment">
      // Here you can implement your own authentication control (checking login/password for example)
      // You can get input authentication parameters like this :
</span>      ParameterAuthentication_ptr pParams<span class="operator"> =</span> getInputParameter<span class="operator">();</span>
      <i>pParams<span class="operator">-&gt;</span>login<span class="operator">,</span> pParams<span class="operator">-&gt;</span>password<span class="operator">,</span> etc<span class="operator">...</span></i><span class="comment">
 
      // If authentication is not valid, then you can throw an exception (and stop process before executing service function)
</span><span class="flow">      throw</span> qx<span class="operator">::</span>exception<span class="operator">(</span><span class="string">"Authentication error !"</span><span class="operator">);
   }
 
};</span></pre>
            </td></tr></tbody></table>
            <br><br>
            A présent, nous disposons des classes de base <i>ParameterAuthentication</i> et <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i> : toutes les classes de paramètres et toutes les classes de services doivent hériter de ces classes de base pour gérer automatiquement l'authentification, et retourner une erreur au client si les paramètres de l'utilisateur ne sont pas valides.
            <br><br>
            <b>Remarque :</b> de la même façon que pour gérer l'authentification, il est possible de mettre en place des logs automatiques en surchargeant les méthodes virtuelles <i>onBeforeProcess()</i> et <i>onAfterProcess()</i>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_840">Requêtes client/serveur asynchrones</a></p>
         <div class="manual_div_content">
            Par défaut, les requêtes client/serveur sont synchrones : ce qui signifie que la couche cliente attend la réponse du serveur pour continuer son exécution.
            Dans une interface graphique utilisateur (<i>GUI</i>), une requête client/serveur bloque l'application (<i>freeze</i>) si elle est exécutée dans le thread principal : si le serveur met du temps pour renvoyer sa réponse, l'utilisateur peut alors penser qu'il s'agit d'un crash de l'application.
            La module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> propose une solution simple pour effectuer des requêtes asynchrones (qui ne bloquent donc pas l'interface graphique de l'utilisateur) grâce à la classe <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a>.
            <br><br>
            La classe <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> utilise <a href="#manual_70">le moteur d'introspection</a> de la bibliothèque QxOrm ainsi que le mécanisme <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank"><i>SIGNAL-SLOT</i> de Qt</a>.
            Elle prend en paramètre :
            <ul>
               <li>une instance de service ;</li>
               <li>les paramètres d'entrée/sortie du service ;</li>
               <li>le nom de la routine serveur à exécuter (sous forme de chaine de caractères) ;</li>
               <li>une fonction à appeler une fois que la transaction est terminée (connexion à l'évènement <i>signal</i> <i>finished()</i>).</li>
            </ul>
            <br>
            Voici l'exemple issu du <a href="./tutorial_2.html#tuto_302">tutoriel qxClientServer</a> qui exécute une routine serveur de manière asynchrone :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTimeAsync(), main_dlg::onDateTimeAsyncFinished()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTimeAsync<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDateTimeAsync<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] '%s' transaction is already running"</span><span class="operator">,</span><span class="string"> "server_infos::get_current_date_time"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur (mode asynchrone)
</span>   server_infos_ptr service<span class="operator"> =</span> server_infos_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxClientAsync<span class="operator">());</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pDateTimeAsync<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>finished<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onDateTimeAsyncFinished<span class="operator">()));</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>setService<span class="operator">(</span>service<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">);</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>start<span class="operator">();
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onDateTimeAsyncFinished<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_pDateTimeAsync<span class="operator"> || !</span> m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()) {</span><span class="flow"> return</span><span class="operator">; }</span>
   updateLastTransactionLog<span class="operator">(</span>m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()-&gt;</span>getTransaction<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">();
}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> l'exemple ci-dessus montre comment effectuer une requête asynchrone avec les actions suivantes :
            <ul>
               <li>création d'une instance d'un service (de type <i>server_infos_ptr</i> pour cet exemple) ;</li>
               <li>création d'une instance de type <i>qx::service::QxClientAsync</i> ;</li>
               <li>connexion à l'évènement <i>finished</i> (pour indiquer qu'une réponse du serveur vient d'arriver) ;</li>
               <li>passage de l'instance du service et de la méthode à appeler (sous forme de chaine de caractères) à l'objet <i>qx::service::QxClientAsync</i> ;</li>
               <li>démarrage de la transaction avec l'appel de la méthode <i>start()</i>.</li>
            </ul>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_90">Moteur modèle/vue (module QxModelView)</a></p>
      <div class="manual_div_content_1">
         Le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet d'utiliser <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">le moteur model/view de Qt</a> avec toutes les classes enregistrées dans le contexte QxOrm :
         <ul>
            <li><a href="#manual_940">QML</a> : toute propriété enregistrée dans le contexte QxOrm est accessible en QML : le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet ainsi de faciliter l'intéraction entre QML et les bases de données ;</li>
            <li><a href="#manual_950">Qt widgets</a> : utilisation de <i>QTableView</i> ou <i>QListView</i> par exemple pour afficher/modifier le contenu d'une table de la base de données.</li>
         </ul>
         L'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une base commune pour tous les modèles liés aux classes persistantes déclarées dans le contexte QxOrm.
         Les méthodes de cette classe préfixées par '<i>qx</i>' appellent les fonctions du <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">namespace qx::dao</a> et communiquent donc directement avec la base de données.
         L'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> fournit également des méthodes définies <b>Q_INVOKABLE</b> et sont donc accessibles directement en <a href="#manual_940">QML</a> :
         <ul>
            <li><i>qxCount_() :</i> compte le nombre d'éléments dans la table de la base de données associée au modèle (avec possibilité d'indiquer un filtre SQL) ;</li>
            <li><i>qxFetchById_() :</i> alimente le modèle en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxFetchAll_() :</i> alimente le modèle avec tous les éléments contenus dans la table de la base de données associée au modèle ;</li>
            <li><i>qxFetchByQuery_() :</i> alimente le modèle avec les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL ;</li>
            <li><i>qxFetchRow_() :</i> alimente (met à jour) une ligne du modèle (chaque ligne du modèle dispose de son propre identifiant de base de données) ;</li>
            <li><i>qxInsert_() :</i> insère l'intégralité du modèle en base de données ;</li>
            <li><i>qxInsertRow_() :</i> insère une ligne du modèle en base de données ;</li>
            <li><i>qxUpdate_() :</i> met à jour l'intégralité du modèle en base de données ;</li>
            <li><i>qxUpdateRow_() :</i> met à jour une ligne du modèle en base de données ;</li>
            <li><i>qxSave_() :</i> sauvegarde l'intégralité du modèle en base de données (insertion ou mise à jour) ;</li>
            <li><i>qxSaveRow_() :</i> sauvegarde une ligne du modèle en base de données (insertion ou mise à jour) ;</li>
            <li><i>qxDeleteById_() :</i> supprime un élément de la base de données en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxDeleteAll_() :</i> supprime tous les éléments de la table de la base de données associée au modèle ;</li>
            <li><i>qxDeleteByQuery_() :</i> supprime les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL ;</li>
            <li><i>qxDeleteRow_() :</i> supprime une ligne du modèle de la base de données (chaque ligne du modèle dispose de son propre identifiant de base de données) ;</li>
            <li><i>qxDestroyById_() :</i> supprime un élément de la base de données en fonction de l'identifiant passé en paramètre (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyAll_() :</i> supprime tous les éléments de la table de la base de données associée au modèle (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyByQuery_() :</i> supprime les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyRow_() :</i> supprime une ligne du modèle de la base de données (chaque ligne du modèle dispose de son propre identifiant de base de données), avec prise en compte de <a href="#manual_3400">la suppression logique</a> ;</li>
            <li><i>qxExecuteQuery_() :</i> alimente le modèle en fonction d'une <a href="#manual_3610">requête SQL personnalisée ou procédure stockée</a> ;</li>
            <li><i>qxExist_() :</i> teste l'existence d'un élément en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxValidate_() :</i> teste la validité de l'intégralité du modèle (<a href="#manual_420">module QxValidator</a>) ;</li>
            <li><i>qxValidateRow_() :</i> teste la validité d'une ligne du modèle (<a href="#manual_420">module QxValidator</a>).</li>
         </ul>
         <br/>
         <b>Remarque :</b> le projet de test <i>qxBlogModelView</i> présent dans le dossier <i>./test/</i> du package QxOrm montre comment créer rapidement un modèle et l'associer au moteur <i>model/view</i> de Qt (d'abord dans <a href="#manual_950">un widget Qt</a>, puis dans <a href="#manual_940">une vue QML</a>).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_910">Définir un modèle "simple" (sans relation)</a></p>
         <div class="manual_div_content">
            Toute classe enregistrée dans le contexte QxOrm peut être utilisée en tant que modèle afin d'alimenter des vues.
            La classe de base <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> des modèles QxOrm hérite de la classe Qt <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a> : les modèles QxOrm sont donc entièrement compatibles avec <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">le moteur model/view de Qt</a>.
            <br/><br/>
            Une seule ligne de code est suffisante pour instancier un modèle QxOrm :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <font style="background-color:yellow">qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>MyClass<span class="operator">&gt;();</span></font>   </pre>
            </td></tr></tbody></table>
            <br/>
            <b>Remarque :</b> le modèle créé avec cette ligne de code expose automatiquement toutes les propriétés enregistrées dans le contexte QxOrm au <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">moteur model/view</a>.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_920">Modèles avec relations (notion de modèles imbriqués)</a></p>
         <div class="manual_div_content">
            Adapter les relations entre classe (<i>1-n</i>, <i>n-1</i> ou <i>n-n</i>) au moteur model/view de Qt est complexe : la solution proposée par la bibliothèque QxOrm est l'utilisation de <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a>.
            Pour plus de détails sur la notion de modèles imbriqués, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">un tutoriel est disponible sur le site developpez.com</a>.
            <br/><br/>
            Pour utiliser les relations (<i>1-n</i>, <i>n-1</i> ou <i>n-n</i>) avec le <a href="../doxygen/html/group___qx_model_view.html" target="_blank">module QxModelView</a>, il est important de comprendre qu'il peut y avoir <b>une hiérarchie entre modèles</b> (un modèle parent peut avoir plusieurs modèles enfants associés, c'est la notion de <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a>).
            <br/><br/>
            Afin de pouvoir travailler avec des relations (modèles imbriqués), il est nécessaire de créer des classes modèles qui héritent de : <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::QxModel&lt;T&gt;</a>.
            Ainsi, toutes les propriétés simples (non relation) sont automatiquement exposées aux vues (grâce à la classe de base), il reste à écrire uniquement les accesseurs pour accéder aux relations.
            L'application <b>QxEntityEditor</b> est livrée avec le plugin <i>QxEECppModelViewExport</i> : <b>ce plugin génère automatiquement le code source pour pouvoir travailler avec des modèles imbriqués</b>.
            <br/><br/>
            Voici un exemple de code généré par l'application <b>QxEntityEditor</b> afin de créer un modèle basé sur la classe <i>blog</i> (voir <a href="./tutorial.html" target="_blank">le tutoriel <i>qxBlog</i></a> pour plus de détails).
            La classe <i>blog</i> dispose de 3 relations : <i>author (n-1)</i>, <i>list_of_comment (1-n)</i> et <i>list_of_category (n-n)</i> :
            <br/><br/>
            <i>* Fichier blog.model_view.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span><span class="keyword">

typedef</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_model_base_class<span class="operator">;</span><span class="keyword">

class</span> QXBLOG_MODEL_VIEW_EXPORT blog_model<span class="operator"> :</span><span class="keyword"> public</span> blog_model_base_class<span class="operator">
{</span>

   Q_OBJECT<span class="keyword">

public</span><span class="operator">:</span>

   blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="operator"> =</span><span class="int"> 0</span><span class="operator">);</span>
   blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">);</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_model<span class="operator">();</span>

   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>

   <span class="comment">/* List of properties exposed by the model (3) :
      - blog_id
      - title
      - text
   */</span><span class="keyword">

protected</span><span class="operator">:</span><span class="keyword">

   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="keyword">
   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="operator">

};

}</span><span class="comment"> // namespace model_view</span></pre>
            </td></tr></tbody></table>
            <br/>
            <i>* Fichier blog.model_view.gen.cpp :</i><br>
            <div style="width:1000px; height:300px; overflow:auto; background-color:white;">
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="comment"> /* = 0 */</span><span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>other<span class="operator">,</span> parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::~</span>blog_model<span class="operator">() { ; }</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "author"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_author value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getauthor<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getauthor<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>author_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_comment"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_comment value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_comment<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_comment<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>comment_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_category"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_category value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_category<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_category<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>category_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span>
   Q_UNUSED<span class="operator">(</span>relation<span class="operator">);</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pNestedModel<span class="operator"> =</span> NULL<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span><span class="flow"> return</span><span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_author value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_comment value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_category value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lstChild<span class="operator">.</span>count<span class="operator">() &lt;=</span><span class="int"> 0</span><span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="flow">
   for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
   {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>syncNestedModel<span class="operator">(</span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(</span>l<span class="operator">),</span> relation<span class="operator">); }
}

}</span><span class="comment"> // namespace model_view</span></pre>
            </div>
            <br/><br/>
            <b>Remarque :</b> comme on peut le constater sur l'exemple ci-dessus, le code source à écrire pour travailler avec des modèles imbriqués est verbeux.
            <b>Afin de travailler avec les relations, il est donc fortement recommandé d'utiliser l'application QxEntityEditor afin de générer le code source automatiquement.</b>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_940">Intéraction avec les vues QML</a></p>
         <div class="manual_div_content">
            Voici un exemple en QML (en Qt5, le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> étant également compatible avec Qt4) qui utilise la table '<i>author</i>' définie dans <a href="./tutorial.html" target="_blank">le tutoriel <i>qxBlog</i></a> (le code source de cet exemple QML est disponible dans le projet de test <i>qxBlogModelView</i> présent dans le package QxOrm) :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QML view and display it
</span>QQuickView qmlView<span class="operator">;</span>
qmlView<span class="operator">.</span>rootContext<span class="operator">()-&gt;</span>setContextProperty<span class="operator">(</span><span class="string">"myModel"</span><span class="operator">,</span> pModel<span class="operator">);</span>
qmlView<span class="operator">.</span>setSource<span class="operator">(</span>QUrl<span class="operator">(</span><span class="string">"qrc:/documents/main.qml"</span><span class="operator">));</span>
qmlView<span class="operator">.</span>show<span class="operator">();</span></pre>
            </td></tr></tbody></table>
            <br/>
            Et voici le contenu du fichier '<i>main.qml</i>' :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>import QtQuick<span class="float"> 2.1</span>
import QtQuick<span class="operator">.</span>Controls<span class="float"> 1.0</span>

Item<span class="operator"> {</span>
   width<span class="operator">:</span><span class="int"> 400</span>
   height<span class="operator">:</span><span class="int"> 300</span>
   Row<span class="operator"> {</span>
      height<span class="operator">:</span><span class="int"> 20</span>
      spacing<span class="operator">:</span><span class="int"> 20</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Clear"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>clear<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Fetch All"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxFetchAll_<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Save"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxSave_<span class="operator">()
      }
   }</span>
   ListView<span class="operator"> {</span>
      y<span class="operator">:</span><span class="int"> 30</span>
      height<span class="operator">:</span><span class="int"> 270</span>
      model<span class="operator">:</span> myModel
      delegate<span class="operator">:</span> Row<span class="operator"> {</span>
         height<span class="operator">:</span><span class="int"> 20</span>
         spacing<span class="operator">:</span><span class="int"> 10</span>
         Text<span class="operator"> {</span> text<span class="operator">:</span><span class="string"> "id: "</span><span class="operator"> +</span> author_id<span class="operator"> }</span>
         TextField<span class="operator"> {</span>
            text<span class="operator">:</span> name
            onTextChanged<span class="operator">:</span> name<span class="operator"> =</span> text<span class="operator">
         }
      }
   }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui donne le résultat suivant à l'exécution :<br/>
            <br/>
            <img alt="qx_model_view_02" src="./resource/qx_model_view_02.png" border="0" /><br/>
            <br/>
            <b>Remarque :</b> comme on peut le constater dans le fichier '<i>main.qml</i>', les propriétés '<i>author_id</i>' et '<i>name</i>' du modèle '<i>author</i>' (variable <i>myModel</i>) sont accessibles automatiquement en lecture/écriture (car elles ont été enregistrées dans le contexte QxOrm).<br/>
            De plus, l'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une liste de méthodes accessibles en QML (utilisation de <i>Q_INVOKABLE</i>) pour communiquer directement avec la base de données : ainsi, le bouton '<i>Save</i>' de l'écran ci-dessus enregistre le modèle en base de données depuis QML.
            <br/><br/>
            <b>Autre remarque :</b> <a href="#manual_920">un plugin de l'application <b>QxEntityEditor</b> permet de générer automatiquement le code des modèles pour la gestion des relations</a>. Il est ainsi possible de travailler avec des <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a> (pour plus de détails sur la notion de modèles imbriqués, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">rendez-vous sur ce tutoriel du site developpez.com</a>).
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_950">Intéraction avec les vues QtWidget</a></p>
         <div class="manual_div_content">
            Voici un exemple de création d'un modèle pour afficher/modifier les données de la table '<i>author</i>' (voir le <a href="./tutorial.html" target="_blank">tutoriel <i>qxBlog</i></a> pour la définition de la classe '<i>author</i>') dans un <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a> (le code source de cet exemple est disponible dans le projet de test <i>qxBlogModelView</i> présent dans le package QxOrm) :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
   <pre>   <span class="comment">// Create a model and fetch all data from database
   </span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
   pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

   // Associate the model to a QTableView and display it   
   </span>QTableView tableView<span class="operator">;</span>
   tableView<span class="operator">.</span>setModel<span class="operator">(</span>pModel<span class="operator">);</span>
   tableView<span class="operator">.</span>show<span class="operator">();</span></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui donne le résultat suivant à l'exécution :<br/>
            <br/>
            <img alt="qx_model_view_01" src="./resource/qx_model_view_01.png" border="0" /><br/>
            <br/>
            <b>Remarque :</b> Qt propose par défaut plusieurs vues <i>QtWidget</i> qui peuvent être mappées sur un modèle, par exemple : <a href="http://doc.qt.io/qt-5/qlistview.html" target="_blank">QListView</a>, <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a>, <a href="http://doc.qt.io/qt-5/qtreeview.html" target="_blank">QTreeView</a>.
            Il est également possible d'utiliser la classe <a href="http://doc.qt.io/qt-4.8/qdatawidgetmapper.html" target="_blank">QDataWidgetMapper</a> pour créer ses propres formulaires basés sur des modèles (<a href="http://qt-quarterly.developpez.com/qq-21/widget-correspondance-donnees/" target="_blank">un tutoriel est disponible sur le site developpez.com</a>).
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_960">Connexion d'un modèle au module QxService</a></p>
         <div class="manual_div_content">
            Le module <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a> fournit la classe template : <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> (qui hérite de : <a href="../doxygen/html/classqx_1_1_qx_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> &gt;&gt; <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> &gt;&gt; <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a>).
            Cette classe dispose de 2 paramètres template :
            <ul>
               <li><i>T</i> : classe enregistrée dans le contexte QxOrm dont toutes les propriétés sont exposées au <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">moteur model/view de Qt</a> ;</li>
               <li><i>S</i> : classe de services du <a href="#manual_80">module QxService</a> pour accéder/enregistrer les données du modèle (requêtes client/serveur).</li>
            </ul>
            Les données proposées par le modèle sont ainsi issues de requêtes client/serveur grâce au <a href="#manual_80">module QxService</a> (elles ne proviennent pas directement de la base de données).
            La classe de services <i>S</i> doit proposer les méthodes suivantes :
            <ul>
               <li><i>count() :</i> requête client/serveur pour compter le nombre d'éléments (avec possibilité d'utiliser un filtre SQL) ;</li>
               <li><i>fetchById() :</i> requête client/serveur pour alimenter les propriétés du modèle en fonction de son identifiant ;</li>
               <li><i>fetchAll() :</i> requête client/serveur pour alimenter les propriétés du modèle qui contiendra tous les éléments d'une table ;</li>
               <li><i>fetchByQuery() :</i> requête client/serveur pour alimenter les propriétés du modèle qui contiendra les éléments filtrés par une requête SQL ;</li>
               <li><i>insert() :</i> requête client/serveur pour insérer les données du modèle ;</li>
               <li><i>update() :</i> requête client/serveur pour mettre à jour les données du modèle ;</li>
               <li><i>save() :</i> requête client/serveur pour sauvegarder les données du modèle (insertion ou mise à jour) ;</li>
               <li><i>deleteById() :</i> requête client/serveur pour supprimer un modèle en fonction de son identifiant ;</li>
               <li><i>deleteAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée au modèle ;</li>
               <li><i>deleteByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL ;</li>
               <li><i>destroyById() :</i> requête client/serveur pour supprimer un modèle en fonction de son identifiant (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>destroyAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée au modèle (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>destroyByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>executeQuery() :</i> requête client/serveur pour exécuter <a href="#manual_3610">une requête SQL personnalisée ou procédure stockée</a> ;</li>
               <li><i>exist() :</i> requête client/serveur pour tester l'existence du modèle en fonction de son identifiant ;</li>
               <li><i>isValid() :</i> requête client/serveur pour tester la validité du modèle (<a href="#manual_420">module QxValidator</a>).</li>
            </ul>
            <br/>
            <b>Remarque :</b> l'application <b>QxEntityEditor</b> est livrée avec les plugins <i>QxEECppServicesExport</i> et <i>QxEECppModelViewExport</i> : ces plugins génèrent automatiquement tout le code source nécessaire pour travailler avec des modèles qui utilisent le <a href="#manual_80">module QxService</a>.
            <b>Afin de travailler avec la classe <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a>, il est donc fortement recommandé d'utiliser l'application QxEntityEditor afin de générer le code source automatiquement.</b>
            <br/><br/>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_95">QxOrm et MongoDB (C++ ODM Object Document Mapper)</a></p>
      <div class="manual_div_content_1">
         En plus des bases de données relationnelles classiques (MySQL, PostgreSQL, SQLite, Oracle, Microsoft SQLServer, MariaDB, etc...), la bibliothèque QxOrm supporte également <a href="https://www.mongodb.com/" target="_blank">la base de données MongoDB</a>.
         <br/><br/>
         <a href="https://fr.wikipedia.org/wiki/MongoDB" target="_blank">Définition du site Wikipedia :</a> MongoDB est un système de gestion de base de données orientée documents, répartissable sur un nombre quelconque d'ordinateurs et ne nécessitant pas de schéma prédéfini des données.
         Il fait partie de la mouvance <b>NoSQL</b>.
         <br/><br/>
         La base de données MongoDB présente de nombreux avantages par rapport à une base de données relationnelle classique (liste non exhaustive) :
         <ul>
            <li><b>Aucun schéma à définir</b> : il est inutile d'avoir à maintenir des tables et colonnes (donc fini les scripts complexes pour migrer la base de données d'une version à une autre). Les <i>Collections</i> MongoDB peuvent contenir des <i>Documents</i> avec différents champs, différentes tailles, etc... Concernant QxOrm, ça signifie que vous pouvez faire évoluer vos classes C++ sans vous soucier d'un schéma DDL à maintenir d'une version à une autre (convient parfaitement dans <b>un environnement de développement AGILE</b> par exemple) ;</li>
            <li><b>Les données sont stockées dans un format BSON (correspond à du JSON)</b> : facile à lire même avec des structures de données complexes ;</li>
            <li><b>Moteur de requêtes (JSON)</b> très puissant avec possibilité de positionner des index sur n'importe qu'elle propriété d'un <i>Document</i> ;</li>
            <li>La base de données est <b>gratuite</b>, et propose un <b>support pour les professionnels</b> ;</li>
            <li>Depuis la version 3.6 de MongoDB : le moteur de requêtes permet de créer des <b>jointures</b> (entre <i>Documents</i>) de manière équivalente à une base de données relationnelle classique.</li>
         </ul>
         <br/>
         L'utilisation de la bibliothèque QxOrm avec MongoDB est très proche des bases de données relationnelles classiques.
         Toutes les fonctionnalités de la bibliothèque QxOrm sont supportées avec MongoDB : donc tout ce qui se trouve dans ce manuel utilisateur est disponible avec une base de données MongoDB.
         Les principales différences à prendre en compte sont :
         <ul>
            <li>Il est conseillé de définir en C++ une clé primaire de type QString. Il n'y a pas de notion de clé numérique auto-incrémentée : <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB utilise un type ObjectId</a> qui peut être mappé en C++ avec QString et généré automatiquement (il est également possible de définir son propre type C++ pour mapper un ObjectId MongoDB).</li>
            <li><a href="#manual_992">Les requêtes ne sont pas au format SQL mais au format JSON</a>.</li>
         </ul>
         <br/>
         <b>Remarque :</b> le package QxOrm fournit un projet de test nommé <b>qxBlogMongoDB</b> (dans le dossier <i>./test/</i>).
         Ce projet montre comment se connecter à une base de données MongoDB avec la bibliothèque QxOrm.
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_980">Pré-requis : driver <i>libmongoc</i> et <i>libbson</i></a></p>
         <div class="manual_div_content">
            Le module <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql</a> fourni par le framework Qt sur lequel est basé la bibliothèque QxOrm ne propose pas de connecteur à une base de données MongoDB.
            La bibliothèque QxOrm a donc besoin de 2 dépendances supplémentaires pour se connecter à une base MongoDB :
            <ul>
               <li><a href="http://mongoc.org/libmongoc/current/" target="_blank">MongoDB C Driver (libmongoc)</a></li>
               <li><a href="http://mongoc.org/libbson/current/index.html" target="_blank">Libbson</a> : a cross-platform BSON library for C</li>
            </ul>
            <br/>
            <a href="http://mongoc.org/libmongoc/current/installing.html" target="_blank">Un guide d'installation est disponible</a> pour installer ces 2 bibliothèques sur votre environnement de développement.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_981">Paramétrage du fichier <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a></p>
         <div class="manual_div_content">
            Une fois que les bibliothèques <i>libmongoc</i> et <i>libbson</i> sont correctement installées sur votre environnement de développement, il est nécessaire de paramétrer le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) en activant l'option de compilation <b>_QX_ENABLE_MONGODB</b>.
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>#######################################
# MongoDB Driver Library Dependencies #
#######################################

# If you enable <font style="background-color:yellow">_QX_ENABLE_MONGODB</font> option, then QxOrm library will be able to use mongoc driver to store all QxOrm registered classes in a MongoDB database
# When _QX_ENABLE_MONGODB compilation option is defined, you must provide following paths to manage mongoc library dependencies :
#  - a BSON_INCLUDE environment variable to define where bson library source code is located (or a QX_BSON_INCLUDE_PATH qmake variable)
#  - a MONGOC_INCLUDE environment variable to define where mongoc library source code is located (or a QX_MONGOC_INCLUDE_PATH qmake variable)
#  - a BSON_LIB environment variable to define where bson library is located (or a QX_BSON_LIB_PATH qmake variable)
#  - a MONGOC_LIB environment variable to define where mongoc library is located (or a QX_MONGOC_LIB_PATH qmake variable)</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Remarque :</b> une fois l'option de compilation <b>_QX_ENABLE_MONGODB</b> activée, il est possible de compiler et exécuter le projet de test <b>qxBlogMongoDB</b> du dossier <i>./test/</i> afin de valider l'environnement de développement.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_982">Connexion à la base de données MongoDB</a></p>
         <div class="manual_div_content">
            Voici un exemple de paramétrage pour se connecter à une base de données MongoDB :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Parameters to connect to MongoDB database</span>
qx::QxSqlDatabase * pDatabase = qx::QxSqlDatabase::getSingleton();
pDatabase->setDriverName(<font style="background-color:yellow"><span class="string">"QXMONGODB"</span></font>);
pDatabase->setDatabaseName(<span class="string">"qxBlog"</span>);
pDatabase->setHostName(<span class="string">"localhost"</span>);
pDatabase->setPort(<span class="int">27017</span>);
pDatabase->setUserName(<span class="string">""</span>);
pDatabase->setPassword(<span class="string">""</span>);</pre>
            </td></tr></tbody></table>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_983">Définition d'une classe persistante MongoDB (Collection) dans le contexte QxOrm (mapping)</a></p>
         <div class="manual_div_content">
            Déclarer une classe persistante MongoDB dans le contexte QxOrm est équivalent à <a href="#manual_300">déclarer une classe persistante pour une base de données relationnelle classique</a>.
            Voici un exemple du projet de test <i>qxBlogMongoDB</i> :
            <br/><br/>
            Fichier <i>blog.h</i> :
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_BLOG_H_
#define _QX_BLOG_BLOG_H_</span>

<span class="keyword">#include</span> <span class="string">"author.h"</span>
<span class="keyword">#include</span> <span class="string">"comment.h"</span>
<span class="keyword">#include</span> <span class="string">"category.h"</span>

<span class="keyword">class</span> QX_BLOG_DLL_EXPORT blog
{
<span class="keyword">public:</span>
<span class="comment">// -- properties</span>
   <font style="background-color:yellow">QString        m_id;</font>
   QString        m_text;
   QDateTime      m_dt_creation;
   author_ptr     m_author;
   list_comment   m_commentX;
   list_category  m_categoryX;
<span class="comment">// -- contructor, virtual destructor</span>
   blog() { ; }
   virtual ~blog() { ; }
};

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY(blog, QString)</font>
QX_REGISTER_HPP_QX_BLOG(blog, qx::trait::no_base_class_defined, 0)

<span class="keyword">typedef</span> std::shared_ptr&lt;blog&gt; blog_ptr;
<span class="keyword">typedef</span> std::vector&lt;blog_ptr&gt; list_blog;

<span class="pre">#endif</span> <span class="comment">// _QX_BLOG_BLOG_H_</span></pre>
            </td></tr></tbody></table>
            <br/>
            Fichier <i>blog.cpp</i> :
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">#include</span> <span class="string">"../include/precompiled.h"</span>
<span class="keyword">#include</span> <span class="string">"../include/blog.h"</span>
<span class="keyword">#include</span> <span class="string">&lt;QxOrm_Impl.h&gt;</span>

QX_REGISTER_CPP_QX_BLOG(blog)

<span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; void register_class(QxClass&lt;blog&gt; & t)
{
   t.id(& blog::m_id, <span class="string">"blog_id"</span>);

   t.data(& blog::m_text, <span class="string">"blog_text"</span>);
   t.data(& blog::m_dt_creation, <span class="string">"date_creation"</span>);
   <font style="background-color:yellow">t.data(& blog::m_categoryX, <span class="string">"list_category"</span>); <span class="comment">// Embedded relationship</span></font>

   <font style="background-color:yellow">t.relationManyToOne(& blog::m_author, <span class="string">"author_id"</span>); <span class="comment">// Referenced relationship</span></font>
   <font style="background-color:yellow">t.relationOneToMany(& blog::m_commentX, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>); <span class="comment">// Referenced relationship</span></font>
}}</pre>
            </td></tr></tbody></table>
            <br/>
            <b>Remarque :</b> l'exemple ci-dessus montre comment définir :
            <ul>
               <li><a href="#manual_9830">la clé primaire <i>QString</i> (MongoDB ObjectId)</a> ;</li>
               <li><a href="#manual_9930">les relations Embedded vs Referenced</a>.</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9830">Gestion des clés primaires ObjectId</a></p>
            <div class="manual_div_content">
               Comme indiqué en jaune dans l'exemple précédent, il est conseillé de définir en C++ une clé primaire de type QString.
               Il n'y a pas de notion de clé numérique auto-incrémentée : <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB utilise un type ObjectId</a> qui peut être mappé en C++ avec QString et généré automatiquement (il est également possible de définir son propre type C++ pour mapper un ObjectId MongoDB).
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_984">Insérer une instance C++ (Document) dans la base de données MongoDB (INSERT)</a></p>
         <div class="manual_div_content">
            Voici un exemple d'insertion de document avec génération automatique de la clé primaire (de type <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB ObjectId</a>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert one author without id</span>
author_ptr author_1 = std::make_shared&lt;author&gt;();
author_1->m_name = <span class="string">"author_1"</span>;
author_1->m_sex = author::male;
author_1->m_birthdate = QDate(1998, 07, 12);
daoError = qx::dao::insert(author_1);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici un exemple d'insertion de document avec une clé primaire personnalisée :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert one author with a custom id</span>
author_ptr author_2 = std::make_shared&lt;author&gt;();
<font style="background-color:yellow">author_2->m_id = <span class="string">"my_custom_id_author_2"</span>;</font>
author_2->m_name = <span class="string">"author_2"</span>;
author_2->m_sex = author::female;
author_2->m_birthdate = QDate(2003, 02, 28);
daoError = qx::dao::insert(author_2);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9840">Insérer une liste d'instances C++ (plusieurs Documents) dans la base de données MongoDB (INSERT)</a></p>
            <div class="manual_div_content">
               Voici un exemple d'insertion de plusieurs documents dans la base de données MongoDB :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert many authors with/without ids</span>
QList&lt;author&gt; authorX;
author author_3; author_3.m_name = <span class="string">"author_3"</span>; author_3.m_sex = author::female; author_3.m_birthdate = QDate(1968, 05, 01);
author author_4; author_4.m_id = <span class="string">"my_custom_id_author_4"</span>; author_4.m_name = <span class="string">"author_4"</span>; author_4.m_sex = author::male;
author author_5; author_5.m_name = <span class="string">"author_5"</span>; author_5.m_sex = author::female; author_5.m_birthdate = QDate(1978, 03, 03);
authorX.append(author_3); authorX.append(author_4); authorX.append(author_5);
daoError = qx::dao::insert(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> <a href="#manual_390">QxOrm supporte plusieurs types C++ de listes / collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_986">Mettre à jour une instance C++ (Document) dans la base de données MongoDB (UPDATE)</a></p>
         <div class="manual_div_content">
            Voici un exemple de mise à jour d'un document dans la base MongoDB :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Update one author</span>
author author_4;
author_4.m_id = <span class="string">"my_custom_id_author_4"</span>;
author_4.m_name = <span class="string">"author_4_modified"</span>;
daoError = qx::dao::update(author_4);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9860">Mettre à jour une liste d'instances C++ (plusieurs Documents) dans la base de données MongoDB (UPDATE)</a></p>
            <div class="manual_div_content">
               Voici un exemple de mise à jour de plusieurs documents dans la base MongoDB :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Update many authors</span>
QList&lt;author&gt; authorX;
author_3.m_name = <span class="string">"author_3_modified_twice"</span>; authorX.append(author_3);
author_2->m_name = <span class="string">"author_2_modified"</span>; authorX.append(* author_2);
author_1->m_name = <span class="string">"author_1_modified"</span>; authorX.append(* author_1);
daoError = qx::dao::update(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> <a href="#manual_390">QxOrm supporte plusieurs types C++ de listes / collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_988">Supprimer une instance C++ (Document) de la base de données MongoDB (DELETE)</a></p>
         <div class="manual_div_content">
            Voici un exemple de suppression d'un document de la base MongoDB :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete one author by id</span>
author_ptr pAuthor = std::make_shared&lt;author&gt;();
pAuthor->m_id = <span class="string">"my_custom_id_author_4"</span>;
daoError = qx::dao::delete_by_id(pAuthor);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9880">Supprimer une liste d'instances C++ (plusieurs Documents) de la base de données MongoDB (DELETE)</a></p>
            <div class="manual_div_content">
               Voici un exemple de suppression de plusieurs documents de la base MongoDB par identifiant (clé primaire) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete many authors by id</span>
QList&lt;author&gt; authorX;
author_3.m_id = <span class="string">"id_author_3"</span>; authorX.append(author_3);
author_2->m_id = <span class="string">"id_author_2"</span>; authorX.append(* author_2);
author_1->m_id = <span class="string">"id_author_1"</span>; authorX.append(* author_1);
daoError = qx::dao::delete_by_id(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Voici un exemple de suppression de plusieurs documents de la base MongoDB par <a href="#manual_992">requête JSON</a> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete authors by query (all male)</span>
qx_query query{ { <span class="string">"sex"</span>, author::male } };
daoError = qx::dao::delete_by_query&lt;author&gt;(query);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Pour supprimer tous les documents de la Collection <i>author</i> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete all authors</span>
daoError = qx::dao::delete_all&lt;author&gt;();</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> <a href="#manual_390">QxOrm supporte plusieurs types C++ de listes / collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_990">Récupérer une instance C++ (Document) de la base de données MongoDB (FETCH)</a></p>
         <div class="manual_div_content">
            Voici un exemple pour récupérer (FETCH) un document de la base MongoDB par identifiant (clé primaire) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch one author by id</span>
author_ptr pAuthor = std::make_shared&lt;author&gt;();
pAuthor->m_id = <span class="string">"my_custom_id_author_2"</span>;
daoError = qx::dao::fetch_by_id(pAuthor);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9900">Récupérer une liste d'instances C++ (plusieurs Documents) de la base de données MongoDB (FETCH)</a></p>
            <div class="manual_div_content">
               Voici un exemple pour récupérer (FETCH) plusieurs documents de la base MongoDB par identifiant (clé primaire) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by id</span>
QList&lt;author&gt; authorX;
author_3.m_id = <span class="string">"id_author_3"</span>; authorX.append(author_3);
author_2->m_id = <span class="string">"id_author_2"</span>; authorX.append(* author_2);
author_1->m_id = <span class="string">"id_author_1"</span>; authorX.append(* author_1);
daoError = qx::dao::fetch_by_id(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Voici un exemple pour récupérer (FETCH) plusieurs documents de la base MongoDB par <a href="#manual_992">requête JSON</a> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by query (only female)</span>
list_author list_of_female_author;
qx_query query{ { <span class="string">"sex"</span>, author::female } };
daoError = qx::dao::fetch_by_query(query, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Voici un exemple pour récupérer (FETCH) tous les documents de la Collection <i>author</i> de la base MongoDB :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch all authors</span>
list_author allAuthors;
daoError = qx::dao::fetch_all(allAuthors);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Voici un exemple pour récupérer (FETCH) tous les documents de la Collection <i>author</i> de la base MongoDB (en sélectionnant les propriétés/colonnes à récupérer) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch all authors (with only 'date_creation' and 'name' properties)</span>
list_author allAuthors;
QStringList columns = QStringList() &lt;&lt; <span class="string">"date_creation"</span> &lt;&lt; <span class="string">"name"</span>;
daoError = qx::dao::fetch_all(allAuthors, NULL, columns);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> <a href="#manual_390">QxOrm supporte plusieurs types C++ de listes / collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_992">Requêtes JSON</a></p>
         <div class="manual_div_content">
            La principale différence entre une base de données relationnelle classique et MongoDB est la façon de requêter les données : à la place du SQL, MongoDB propose <a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank">un moteur de requête JSON</a>.
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9920">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a></p>
            <div class="manual_div_content">
               La classe <a href="#manual_3600">qx::QxSqlQuery (ou son alias qx_query)</a> utilisée pour construire du SQL classique est également compatible pour construire des requêtes JSON MongoDB.
               Cette classe utilise <a href="https://fr.cppreference.com/w/cpp/utility/initializer_list" target="_blank">la fonctionnalité C++11 std::initializer_list</a> afin d'écrire les requêtes en C++ avec une syntaxe proche du JSON (il est également possible d'écrire la requête sous forme de chaîne de caractères).
               Par exemple :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by query (only female)</span>
list_author list_of_female_author;
qx_query query <font style="background-color:yellow">{ { <span class="string">"sex"</span>, author::female } }</font>;
daoError = qx::dao::fetch_by_query(query, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9921">Utiliser le moteur d'aggregation MongoDB</a></p>
            <div class="manual_div_content">
               La base de données MongoDB fournit également <a href="https://docs.mongodb.com/manual/aggregation/" target="_blank">un puissant moteur d'aggregation</a> qui étend encore plus les possibilités pour requêter les données.
               Voici comment utiliser ce moteur d'aggregation avec la classe <a href="#manual_3600">qx::QxSqlQuery (ou son alias qx_query)</a>, le 1er paramètre du constructeur doit être égal à <i>aggregate</i> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch by query using MongoDB aggregation framework (only female)</span>
list_author list_of_female_author;
qx_query queryAggregate(<font style="background-color:yellow"><span class="string">"aggregate"</span></font>,
               <span class="string">"[ { \"$match\" : { \"sex\" : " + QString::number(static_cast&lt;int&gt;(author::female)) + " } } ]"</span>);
daoError = qx::dao::fetch_by_query(queryAggregate, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9922">Ajouter des propriétés à la requête de type : 'sort', 'limit', 'skip', etc...</a></p>
            <div class="manual_div_content">
               Il est souvent nécessaire de limiter les données, ou bien de les trier par exemple.
               Pour effectuer ces opérations, la base de données MongoDB utilise <a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/" target="_blank">la notion de projection</a>.
               Voici un exemple d'utilisation avec la classe <a href="#manual_3600">qx::QxSqlQuery (ou son alias qx_query)</a>, avec une QStringList en constructeur (ou bien 2ème paramètre <a href="https://fr.cppreference.com/w/cpp/utility/initializer_list" target="_blank">std::initializer_list</a>) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch by query (only female) adding 'sort', 'limit', 'skip', etc... commands (see second query QStringList parameter)</span>
list_of_female_author.clear();
qx_query queryOpts(QStringList() &lt;&lt; <span class="string">"{ \"sex\" : " + QString::number(static_cast<int>(author::female)) + " }"</span>
                              &lt;&lt; <font style="background-color:yellow"><span class="string">"{ \"sort\" : { \"sex\" : -1 }, \"limit\" : 2 }"</span></font>);
daoError = qx::dao::fetch_by_query(queryOpts, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9923">Exécuter une requête personnalisée</a></p>
            <div class="manual_div_content">
               Il est possible d'exécuter une requête personnalisée avec <a href="#manual_3610">la fonction qx::dao::call_query()</a>.
               Le résultat de la requête peut être facilement convertie en <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariantMap ou bien QList&lt;QVariantMap&gt;</a> (si la requête retourne un curseur) afin de faciliter la lecture des résultats de la requête personnalisée.
               Voici quelques exemples d'appels de requêtes personnalisées :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Drop database</span>
qx_query dropDB(<span class="string">"{ \"dropDatabase\" : 1 }"</span>);
QSqlError daoError = qx::dao::call_query(dropDB);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom query and get JSON response as QVariantMap</span>
qx_query customQuery(<span class="string">"{ \"find\": \"author\", \"filter\": { } }"</span>);
daoError = qx::dao::call_query(customQuery); qAssert(! daoError.isValid());
QString responseCustomQuery = customQuery.response().toString();
QVariantMap responseCustomQueryAsJson;
qx::serialization::json::from_string(responseCustomQueryAsJson, responseCustomQuery);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom query with cursor and get JSON response as QList&lt;QVariantMap&gt;</span>
qx_query customQueryCursor(<font style="background-color:yellow"><span class="string">"cursor"</span></font>, <span class="string">"{ \"find\": \"author\", \"filter\": { } }"</span>);
daoError = qx::dao::call_query(customQueryCursor); qAssert(! daoError.isValid());
QString responseCustomQueryCursor = customQueryCursor.response().toString();
QList&lt;QVariantMap&gt; responseCustomQueryCursorAsJson;
qx::serialization::json::from_string(responseCustomQueryCursorAsJson, responseCustomQueryCursor);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_993">Moteur de relations (nécessite une version MongoDB 3.6 ou +)</a></p>
         <div class="manual_div_content">
            <a href="#manual_380">Le moteur de relations de la bibliothèque QxOrm</a> est compatible avec la base de données MongoDB (version 3.6 minimale).
            QxOrm est donc capable de récupérer les données d'un Document sur plusieurs Collections en une seule requête.
            <br/><br/>
            Voici un exemple pour récupérer un Document et toutes ses relations sur 1 niveau de profondeur (parent > enfants) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch blog with all relations : 'author', 'comment' and 'category' (MongoDB version 3.6+ is required for relationships)</span>
blog_ptr blog = std::make_shared&lt;blog&gt;();
blog->m_id = <span class="string">"id_blog_1"</span>;
daoError = qx::dao::fetch_by_id_with_all_relation(blog);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici un exemple pour récupérer un Document et toutes ses relations sur 4 niveaux de profondeur (utilisation de la syntaxe <i>*-&gt;*-&gt;*-&gt;*</i>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch blog with many relations using "*-&gt;*-&gt;*-&gt;*" (4 levels of relationships)</span>
blog_ptr blog = std::make_shared&lt;blog&gt;();
blog->m_id = <span class="string">"id_blog_1"</span>;
daoError = qx::dao::fetch_by_id_with_relation(<span class="string">"*-&gt;*-&gt;*-&gt;*"</span>, blog);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici un exemple pour récupérer un Document en sélectionnant les relations et propriétés à alimenter (utilisation de la syntaxe <i>{ &lt;col_1&gt;, &lt;col_2&gt;, etc... }</i>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch relations defining fields to fetch with syntax { col_1, col_2, etc... }</span>
list_blog lstBlogComplexRelation;
QStringList relations = QStringList() &lt;&lt; <span class="string">"{ blog_text }"</span> &lt;&lt; <span class="string">"author_id { name, birthdate }"</span> &lt;&lt; <span class="string">"list_comment { comment_text } -&gt; blog_id -&gt; *"</span>;
daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici un exemple pour récupérer un Document en sélectionnant les relations et les propriétés à ne pas alimenter (utilisation de la syntaxe <i>-{ &lt;col_1&gt;, &lt;col_2&gt;, etc... }</i>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch relations defining columns to remove before fetching with syntax -{ col_1, col_2, etc... }</span>
list_blog lstBlogComplexRelation2;
QStringList relations = QStringList() &lt;&lt; <span class="string">"-{ blog_text }"</span> &lt;&lt; <span class="string">"author_id -{ name, birthdate }"</span> &lt;&lt; <span class="string">"list_comment -{ comment_text } -&gt; blog_id -&gt; *"</span>;
daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation2);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9930">Relations : Embedded vs Referenced</a></p>
            <div class="manual_div_content">
               Un des points forts de la base de données MongoDB est de pouvoir stocker des structures complexes de données (on n'est pas limité à une structure en tableau table/colonne des bases de données relationnelles classiques).
               Un Document MongoDB peut donc contenir un objet et plusieurs sous-objets (notion de hiérarchie dans la structure du Document).
               Inclure un sous-objet dans un même Document présente des avantages (aucune jointure par exemple, donc plus rapide à récupérer) et inconvénients (un même objet peut être dupliqué plusieurs fois dans la base).
               Il est donc important de réfléchir sur la stratégie à adopter pour stocker les données.
               <br/><br/>
               La bibliothèque QxOrm supporte les 2 façons de procéder :
               <ul>
                  <li><b>Embedded relation</b> : le sous-objet est inclu dans le Document ;</li>
                  <li><b>Referenced relation</b> : créé une jointure comme dans une base de données relationnelle classique.</li>
               </ul>
               <br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; void register_class(QxClass&lt;blog&gt; & t)
{
   t.id(& blog::m_id, <span class="string">"blog_id"</span>);

   t.data(& blog::m_text, <span class="string">"blog_text"</span>);
   t.data(& blog::m_dt_creation, <span class="string">"date_creation"</span>);
   <font style="background-color:yellow">t.data(& blog::m_categoryX, <span class="string">"list_category"</span>); <span class="comment">// Embedded relationship</span></font>

   <font style="background-color:yellow">t.relationManyToOne(& blog::m_author, <span class="string">"author_id"</span>); <span class="comment">// Referenced relationship</span></font>
   <font style="background-color:yellow">t.relationOneToMany(& blog::m_commentX, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>); <span class="comment">// Referenced relationship</span></font>
}}</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_994">Création automatique des index</a></p>
         <div class="manual_div_content">
            La bibliothèque QxOrm fournit une méthode pour générer automatiquement les index (cette fonction peut être appelée en début de programme, par exemple dans le <i>main</i>) :
            <ul>
               <li>les index liés aux relations entre les Collections (pour optimiser les jointures) ;</li>
               <li>les index définis par la méthode <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember::setIndex()</a> (dans la fonction <i>qx::register_class()</i>).</li>
            </ul>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// To optimize queries : create automatically indexes based on relationships and properties marked as 'index'</span>
daoError = qx::dao::mongodb::QxMongoDB_Helper::autoCreateIndexes(true);</pre>
            </td></tr></tbody></table>
            <br/><br/>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_96">Serveur web HTTP/HTTPS (module QxHttpServer)</a></p>
      <div class="manual_div_content_1">
         La bibliothèque QxOrm fournit un serveur web compatible HTTP 1.1 autonome (aucune nécessité d'installer une application tierce comme <a href="https://httpd.apache.org/" target="_blank">Apache</a> ou <a href="https://nginx.org/en/" target="_blank">Nginx</a>), performant (multi-thread) et simple d'utilisation : il s'agit du <b>module QxHttpServer</b> (basé sur le <a href="#manual_80">module QxService</a>).
         <br/><br/>
         Le <b>module QxHttpServer</b> supporte de nombreuses fonctionnalités :
         <ul>
            <li><a href="#manual_9961">Connexions sécurisées SSL/TLS</a></li>
            <li><a href="#manual_997">Routage dynamique des URL (définir les endpoints / dispatcher)</a></li>
            <li><a href="#manual_998">Sessions (stockage par client côté serveur)</a></li>
            <li><a href="#manual_999">Cookies</a></li>
            <li><a href="#manual_851">Gestion des fichiers statiques</a></li>
            <li><a href="#manual_852">Encodage de transfert en bloc (chunked responses)</a></li>
            <li><a href="#manual_853">Requêtes par les API JSON (module QxRestApi)</a></li>
         </ul>
         Combiné avec le <a href="#manual_97">module QxRestApi</a> (qui propose une API JSON pour requêter les données persistantes), le <b>module QxHttpServer</b> est particulièrement adapté pour développer des applications web modernes.
         Par exemple, des applications web de type <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank">SPA (<i>Single-Page Applications</i>)</a> avec les célèbres frameworks Javascript comme <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
         <br/><br/>
         <b>Remarque :</b> pour activer le module <b>QxHttpServer</b>, il faut définir l'option de compilation <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> dans <a href="#manual_220">le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a>.
         Cette option de compilation ajoute une dépendance au binaire <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> fourni avec la bibliothèque Qt.
         <br/><br/>
         <b>Autre remarque :</b> le package QxOrm est livré avec <a href="#manual_972">le projet de test <b><i>qxBlogRestApi</i></b></a>.
         Ce projet de test est une application web avec de nombreux exemples pour requêter les données persistantes depuis une page web (HTML et Javascript).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_995">Hello World !</a></p>
         <div class="manual_div_content">
            Voici le code source d'une application web basée sur le <b>module QxHttpServer</b> (cette application renvoie <i>Hello World !</i> au navigateur web client) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">#include</span> &lt;<span class="string">QtCore/qcoreapplication.h</span>&gt;
<span class="keyword">#include</span> &lt;<span class="string">QxOrm.h</span>&gt;

<span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char *</span> argv[])
{
   <span class="type">QCoreApplication</span> app(argc, argv);

   <span class="comment">// HTTP server settings</span>
   <span class="type">qx::service::QxConnect *</span> serverSettings = qx::service::QxConnect::getSingleton();
   serverSettings-&gt;setPort(<span class="int">9642</span>); <span class="comment">// HTTP server listening port</span>
   serverSettings-&gt;setKeepAlive(<span class="int">5000</span>); <span class="comment">// Keep-alive connection with client during 5s, then socket is disconnected and thread becomes available for other clients</span>
   serverSettings-&gt;setThreadCount(<span class="int">50</span>); <span class="comment">// Number of threads waiting for client's requests,</span>
                                                           <span class="comment">// which means also how many requests can be handled simultaneously (in parallel) by HTTP server</span>

   <span class="comment">// Create a QxOrm HTTP server instance</span>
   <span class="type">qx::QxHttpServer</span> httpServer;

   <span class="comment">// Define all HTTP server routes (dispatcher) to handle requests</span>
   <span class="comment">// Each callback is executed in a dedicated thread, so QxOrm HTTP server can handle several requests in parallel</span>
   httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
      response.data() = <span class="string">"Hello World !"</span>;
   });

   <span class="comment">// Start HTTP server</span>
   httpServer.startServer();

   <span class="comment">// Start event loop</span>
   return app.exec();
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Résultat :</b> ouvrir un navigateur web (Chrome, Firefox, Safari, Internet Explorer, Opera, etc...) et aller à l'adresse <u><b>http://localhost:9642/</b></u>, l'écran suivant doit apparaitre :
            <br/><br/>
            <img alt="QxHttpServer Hello World !" src="./resource/qx_http_server_hello_world_01.png" border="0">
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_996">Paramétrage du serveur web HTTP</a></p>
         <div class="manual_div_content">
            Les paramètres du serveur web HTTP sont accessibles avec la classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> :
            <ul>
               <li><i>setPort()</i> : port d'écoute du serveur web (un serveur web classique écoute sur le port 80 mais vous pouvez définir une autre valeur) ;</li>
               <li><i>setThreadCount()</i> : nombre de threads utilisés par le serveur web pour traiter les requêtes HTTP (nombre de connexions clientes simultanées) ;</li>
               <li><i>setMaxWait()</i> : temps d'attente maximum en milli-secondes (par exemple lecture ou écriture sur la socket), la valeur -1 signifie attendre indéfiniment ;</li>
               <li><i>setCompressData()</i> : si le client HTTP supporte la compression GZIP, alors les réponses de type texte (fichier HTML / Javascript / CSS, flux JSON, etc...) seront compressés au format GZIP ;</li>
               <li><i>setKeepAlive()</i> : la socket avec le client reste connectée pendant le laps de temps défini par cette fonction (en milli-secondes), la valeur -1 signifie ne jamais se déconnecter ;</li>
               <li><i>setSessionTimeOut()</i> : indique le temps d'attente (en milli-secondes) avant de détruire <a href="#manual_998">une session (stockage par client côté serveur)</a> non utilisée.</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9961">Connexions sécurisées SSL/TLS</a></p>
            <div class="manual_div_content">
               La classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> fournit également des paramètres pour gérer les connexions sécurisées HTTPS (SSL et/ou TLS).<br/>
               Voici un exemple de paramétrage de connexions sécurisées avec certificat serveur et autorité de certification (voir <a href="#manual_972">le projet de test <b><i>qxBlogRestApi</i></b></a> pour tester ce code) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Certificates created with this tutorial : https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/</span>
QFile::copy(<span class="string">":/documents/cert_qxorm_ca.pem"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_ca.pem"</span>));
QFile::copy(<span class="string">":/documents/cert_qxorm_server.crt"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_server.crt"</span>));
QFile::copy(<span class="string">":/documents/cert_qxorm_server.key"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_server.key"</span>));

<span class="type">QFile</span> fileCertCA(appPath.filePath(<span class="string">"files/cert_qxorm_ca.pem"</span>));
fileCertCA.open(QIODevice::ReadOnly);
<span class="type">QList&lt;QSslCertificate&gt;</span> certCA; certCA &lt;&lt; QSslCertificate(fileCertCA.readAll());

<span class="type">QFile</span> fileCertServerPublic(appPath.filePath(<span class="string">"files/cert_qxorm_server.crt"</span>));
fileCertServerPublic.open(QIODevice::ReadOnly);
<span class="type">QSslCertificate</span> certServerPublic(fileCertServerPublic.readAll());

<span class="type">QFile</span> fileCertServerPrivate(appPath.filePath(<span class="string">"files/cert_qxorm_server.key"</span>));
fileCertServerPrivate.open(QIODevice::ReadOnly);
<span class="type">QSslKey</span> certServerPrivate(fileCertServerPrivate.readAll(), QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey, "qxorm");

<span class="type">qx::service::QxConnect *</span> serverSettings = qx::service::QxConnect::getSingleton();
serverSettings-&gt;setSSLEnabled(true);
serverSettings-&gt;setSSLCACertificates(certCA);
serverSettings-&gt;setSSLLocalCertificate(certServerPublic);
serverSettings-&gt;setSSLPrivateKey(certServerPrivate);
</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> par défaut, toutes les erreurs SSL sont ignorées (erreurs souvent liées à des problèmes de certificats).
               Pour adapter votre serveur web à vos normes de sécurité, vous pouvez utiliser les fonctions suivantes (classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a>) :
               <ul>
                  <li><i>setSSLIgnoreErrors(QList&lt;QSslError&gt; lst) :</i> liste des erreurs SSL à ignorer (par défaut toutes les erreurs sont ignorées), voir <a href="https://doc.qt.io/Qt-5/qsslerror.html" target="_blank">la classe Qt QSslError</a> ;</li>
                  <li><i>setSSLPeerVerifyName(const QString & s) :</i> voir <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">la classe Qt QSslSocket</a> pour plus de détails ;</li>
                  <li><i>setSSLPeerVerifyMode(QSslSocket::PeerVerifyMode e) :</i> voir <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">la classe Qt QSslSocket</a> pour plus de détails ;</li>
                  <li><i>setSSLPeerVerifyDepth(int i) :</i> voir <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">la classe Qt QSslSocket</a> pour plus de détails ;</li>
                  <li><i>setSSLConfiguration(QSslConfiguration cfg) :</i> voir <a href="https://doc.qt.io/qt-5/qsslconfiguration.html" target="_blank">la classe Qt QSslConfiguration</a> pour plus de détails ;</li>
                  <li><i>setSSLProtocol(QSsl::SslProtocol e) :</i> voir <a href="https://doc.qt.io/qt-5/qssl.html#SslProtocol-enum" target="_blank">la liste des protocoles SSL et TLS dans la documentation Qt</a>.</li>
               </ul>
               <br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_997">Routage des URL (définir les endpoints / dispatcher)</a></p>
         <div class="manual_div_content">
            Le <b>module QxHttpServer</b> fournit un moteur de routage des URL (<i>dispatcher</i>) pour définir les fonctions (ou lambda) à exécuter en fonction des paramètres de la requête HTTP (méthode HTTP <i>GET, POST, DELETE, etc...</i> + URL demandée).<br/>
            Les fonctions (ou lambda) doivent avoir cette signature : <font style="background-color:yellow"><b>void myRequestHandler(qx::QxHttpRequest & request, qx::QxHttpResponse & response);</b></font>
            <br/><br/>
            La classe <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a>) dispose des méthodes suivantes :
            <ul>
               <li><i>setCustomRequestHandler()</i> : défini une fonction (ou lambda) exécutée si aucune autre fonction n'a été trouvée par le dispatcher ;</li>
               <li><i>dispatch()</i> : le 1er paramètre correspond à la méthode HTTP (<i>GET, POST, DELETE, etc...</i>), le 2ème paramètre correspond à l'URL demandée (ou son pattern), le 3ème paramètre correpond à la fonction (ou lambda) à exécuter ;</li>
               <li><i>beforeDispatching()</i> : fonction (ou lambda) exécutée avant de traiter la requête HTTP (peut être utile par exemple pour tracer des logs, ou bien mettre en place un système d'authentification) ;</li>
               <li><i>afterDispatching()</i> : fonction (ou lambda) exécutée après le traitement de la requête HTTP (peut être utile par exemple pour tracer des logs) ;</li>
               <li><i>clearDispatcher()</i> : néttoie toutes les règles de routage (seule la fonction ou lambda définie par <i>setCustomRequestHandler()</i> sera exécutée).</li>
            </ul>
            <b>Remarque :</b> le dispatcher est thread-safe, vous pouvez donc redéfinir les règles de routage des URL même si le serveur web est en cours d'exécution.
            <br/><br/>
            <b>Autre remarque :</b> chaque fonction (ou lambda) est <font style="background-color:yellow"><b>exécutée dans son propre thread</b></font>.
            Le serveur web HTTP fourni par la bibliothèque QxOrm peut donc gérer plusieurs requêtes HTTP simultanément.
            <br/><br/>
            <b>Exemple n°1 :</b> cette règle de routage intercepte toutes les requêtes de type <i>GET</i> dont l'URL commence par <i>/files/</i>, et renvoie comme réponse le contenu d'un fichier statique stocké sur le serveur (<i>QDir::currentPath()</i> indique le répertoire parent du stockage des fichiers statiques, et <i>5000</i> correspond à la taille pour l'envoi des fichiers par bloc / chunked response, ce dernier paramètre étant optionnel) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/files/*"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   qx::QxHttpServer::buildResponseStaticFile(request, response, QDir::currentPath(), <span class="int">5000</span>);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Exemple n°2 :</b> cette règle de routage intercepte toutes les requêtes de type <i>POST</i> dont l'URL est <i>/qx</i>, et utilise le <a href="#manual_97">module QxRestApi</a> (qui propose une API JSON pour requêter les données persistantes).
            Ces 2 exemples (avec l'exemple n°1 qui renvoie des fichiers statiques) sont suffisants pour démarrer une application web de type SPA (<i>Single-Page Applications</i>) avec les célèbres frameworks Javascript comme <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"POST"</span>, <span class="string">"/qx"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   qx::QxHttpServer::buildResponseQxRestApi(request, response);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Exemple n°3 :</b> cette règle de routage intercepte toutes les requêtes de type <i>GET</i> dont l'URL est <i>/test_big_json</i>, et construit une réponse de type JSON contenant un tableau de 10000 éléments :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/test_big_json"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <span class="comment">// To compare with this benchmark : https://blog.binaryspaceship.com/2017/cpp-rest-api-frameworks-benchmark/</span>
   <span class="comment">// This is more a JSON benchmark than HTTP server benchmark (RapidJSON is faster than Qt QJson engine)</span>
   QJsonArray arr; Q_UNUSED(request);
   for (int i = 0; i &lt; 10000; ++i)
   {
      QJsonObject item;
      item.insert(<span class="string">"id"</span>, QString::number(i));
      item.insert(<span class="string">"name"</span>, QString("Hello World"));
      item.insert(<span class="string">"type"</span>, QString("application"));
      arr.append(item);
   }
   QJsonDocument doc(arr);
   response.headers().insert(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>);
   response.data() = doc.toJson(QJsonDocument::Compact);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Remarque :</b> l'ordre dans lequel est appelé les différentes fonctions <i>dispatch()</i> est important.
            Le 1er élément trouvé par le dispatcher correspondant à l'URL demandée est exécuté (et ignore les éléments suivants).
            Il est donc indispensable de définir en 1er les URL les plus spécifiques, jusqu'aux URL les plus génériques (par exemple, le pattern correspondant à toutes les URL est <i>/*</i>).
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9962">Routage dynamique des URL</a></p>
            <div class="manual_div_content">
               Le dispatcher du <b>module QxHttpServer</b> supporte également la notion de routage dynamique des URL.<br/>
               Il est possible de définir des variables au niveau de l'URL à router avec la syntaxe : <font style="background-color:yellow"><i>&lt;var_name:var_type&gt;</i></font> (<i>var_type</i> étant optionnel, et peut prendre comme valeur : <i>int, long, float, double, string</i>).
               <br/><br/>
               Le routage dynamique est particulièrement utile pour mettre en place une API REST.<br/>
               Par exemple, le pattern <i>/blog/&lt;blog_id:int&gt;</i> associé à la méthode HTTP <i>GET</i> peut être utilisé pour récupérer les données d'un blog en fonction de son identifiant de type numérique (<i>fetch_by_id</i>).
               <br/><br/>
               Il faut voir l'URL comme une liste de segments dont le séparateur est le caractère <i>/</i>.<br/>
               Le dispatcher vérifie que chaque segment de l'URL demandée correspond au pattern utilisé afin de valider une fonction (ou lambda) à exécuter.<br/>
               Pour récupérer les valeurs des paramètres de l'URL, il faut utiliser : <font style="background-color:yellow"><i>request.dispatchParams().value("var_name")</i></font> (retourne un <i>QVariant</i>).
               <br/><br/>
               <b>Exemple :</b> la règle de routage suivante intercepte toutes les requêtes de type <i>GET</i> dont l'URL commence <i>/params/</i>, suivi par un segment qui sera associé à la variable <i>var1</i>, suivi par un segment de type numérique associé à la variable <i>var2</i>.
               Elle construit une réponse qui renvoie la valeur des 2 paramètres <i>var1</i> et <i>var2</i>.
               Si le navigateur web appelle l'URL <i>/params/abc/123/</i> alors la fonction (ou lambda) sera exécutée, par contre si le navigateur web appelle l'URL <i>/params/abc/def/</i> alors la fonction (ou lambda) ne sera pas exécutée (car <i>def</i> n'est pas numérique) et cherchera un autre élément du dispatcher :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <font style="background-color:yellow"><span class="string">"/params/&lt;var1&gt;/&lt;var2:int&gt;"</span></font>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   response.data() = <span class="string">"Test URL dispatch parameters :\r\n"</span>;
   response.data() += <span class="string">" - var1 = "</span> + request.dispatchParams().value(<span class="string">"var1"</span>).toByteArray() + <span class="string">"\r\n"</span>;
   response.data() += <span class="string">" - var2 = "</span> + request.dispatchParams().value(<span class="string">"var2"</span>).toByteArray() + <span class="string">"\r\n"</span>;
});</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Remarque :</b> il est également possible de définir une expression régulière pour router les URL avec la syntaxe : <font style="background-color:yellow"><i>&lt;var_name:{my_reg_exp}&gt;</i></font>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_856">Récupérer les paramètres de la requête HTTP</a></p>
         <div class="manual_div_content">
            La classe <a href="../doxygen/html/classqx_1_1_qx_http_request.html" target="_blank"><i>qx::QxHttpRequest</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_request.html" target="_blank"><i>qx_http_request</i></a>) contient tous les paramètres d'appel de la requête HTTP :
            <ul>
               <li><i>QUrl & url() :</i> URL demandée par le navigateur web client ;</li>
               <li><i>QString & command() :</i> méthode HTTP utilisée par le navigateur web client (<i>GET, POST, PUT, DELETE, etc...</i>) ;</li>
               <li><i>QString & version() :</i> version HTTP fournie par le navigateur web client (en général <i>HTTP/1.1</i>) ;</li>
               <li><i>QByteArray & data() :</i> contenu de la requête HTTP ;</li>
               <li><i>QByteArray header(const QByteArray & key) :</i> permet de récupérer la valeur d'un en-tête HTTP fourni par le navigateur web client (par exemple : <i>request.header("Accept-Encoding")</i>) ;</li>
               <li><i>QxHttpCookie cookie(const QByteArray & name) :</i> permet de récupérer la valeur d'un <a href="#manual_999">cookie HTTP</a> fourni par le navigateur web client ;</li>
               <li><i>QString param(const QString & key) :</i> permet de récupérer la valeur d'un paramètre de la requête HTTP (fourni soit dans l'URL, soit dans le contenu si l'en-tête HTTP <i>'content-type'</i> est <i>'application/x-www-form-urlencoded'</i>) ;</li>
               <li><i>QHash&lt;QString, QVariant&gt; & dispatchParams() :</i> liste des paramètres dynamiques de l'URL calculés par <a href="#manual_9962">le routage/dispatcher</a> ;</li>
               <li><i>QString & sourceAddress() :</i> adresse IP du navigateur web client ;</li>
               <li><i>long & sourcePort() :</i> port utilisé par le navigateur web client ;</li>
               <li><i>QString guid() :</i> identifiant unique de la requête HTTP à usage interne uniquement (peut être utilisé pour tracer des logs par exemple).</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_857">Générer la réponse HTTP</a></p>
         <div class="manual_div_content">
            La classe <a href="../doxygen/html/classqx_1_1_qx_http_response.html" target="_blank"><i>qx::QxHttpResponse</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_response.html" target="_blank"><i>qx_http_response</i></a>) permet de générer la réponse HTTP avec les méthodes suivantes :
            <ul>
               <li><i>int & status() :</i> code retour de la réponse HTTP (par défaut 200) ;</li>
               <li><i>QByteArray & data() :</i> contenu de la réponse HTTP ;</li>
               <li><i>QByteArray header(const QByteArray & key) :</i> renseigne un en-tête HTTP à envoyer au navigateur web client (par défaut, les en-têtes suivants sont créés : <i>Server</i>, <i>Date</i>, <i>Content-Type</i> et <i>Connection</i>) ;</li>
               <li><i>QxHttpCookie cookie(const QByteArray & name) :</i> renseigne un <a href="#manual_999">cookie HTTP</a> à envoyer au navigateur web client ;</li>
               <li><i>qx_bool writeChunked(const QByteArray & data) :</i> permet d'envoyer le <a href="#manual_852">contenu de la réponse par bloc (chunked responses)</a>.</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_998">Sessions (stockage par client côté serveur)</a></p>
         <div class="manual_div_content">
            Les sessions HTTP sont un mécanisme côté serveur web permettant de stocker des données spécifiques à un client.
            Ces données sont accessibles pendant un laps de temps pour toutes les requêtes envoyées par le client.
            Lors du 1er accès à une session pour un client, un <a href="#manual_999">cookie HTTP</a> contenant un identifiant unique est généré et associé automatiquement à la réponse HTTP.
            Par la suite, toutes les requêtes HTTP envoyées par le client contiendront automatiquement un <a href="#manual_999">cookie HTTP</a> avec l'identifiant unique calculé précédemment.
            Lorsqu'une session n'est plus utilisée pendant un certain laps de temps, alors elle est détruite automatiquement.
            <br/><br/>
            La classe <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx::QxHttpSession</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx_http_session</i></a>) représente une session HTTP côté serveur.<br/>
            Une session est accessible avec le singleton <a href="../doxygen/html/classqx_1_1_qx_http_session_manager.html" target="_blank">qx::QxHttpSessionManager</a> :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <span class="comment">// If this is the first time to access to session, then a cookie is created automatically and attached to the response</span>
   <span class="comment">// Then each request sent by web browser will contain a cookie with the session id</span>
   <span class="comment">// The session expires on server side after qx::service::QxConnect::setSessionTimeOut() milliseconds</span>
   <font style="background-color:yellow">qx::QxHttpSession_ptr session = qx::QxHttpSessionManager::getSession(request, response);</font>
   if (session) { session-&gt;set(<span class="string">"last_request_per_user"</span>, QDateTime::currentDateTime()); }
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Remarque :</b> la classe <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx::QxHttpSession</i></a> contient une hash-map (<i>QHash&lt;QByteArray, QVariant&gt;</i>) pouvant stocker n'importe quelle valeur.
            <br/><br/>
            <b>Autre remarque :</b> la durée (en milli-secondes) pour supprimer une session non utilisée est paramétrée par la méthode : <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect::setSessionTimeOut()</a>.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_999">Cookies</a></p>
         <div class="manual_div_content">
            Les <a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank">cookies HTTP</a> sont un mécanisme d'échange de données entre client HTTP et serveur HTTP.<br/>
            Les cookies sont utilisés par exemple pour :
            <ul>
               <li><a href="#manual_998">gérer les sessions HTTP</a> ;</li>
               <li>mémoriser l'information sur l'utilisateur d'un site, dans le but de lui montrer un contenu approprié dans le futur. Par exemple, un serveur web peut envoyer un cookie contenant le dernier nom d'utilisateur utilisé pour se connecter à ce site web, afin que ce nom d'utilisateur puisse être pré-rempli lors des prochaines visites ;</li>
               <li><a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank">voir Wikipedia pour d'autres cas d'utilisation</a>.</li>
            </ul>
            <br/>
            Les classes <a href="#manual_856">qx::QxHttpRequest</a> et <a href="#manual_857">qx::QxHttpResponse</a> disposent des méthodes nécessaires pour lire les cookies envoyés par le navigateur web client ou bien générer un cookie dans la réponse HTTP.
            Par exemple :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">qx::QxHttpCookie</span> cookie;
cookie.name = <span class="string">"my_http_cookie"</span>;
cookie.value = <span class="string">"my_value"</span>;
response.cookies().insert(cookie.name, cookie);</pre>
            </td></tr></tbody></table>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_851">Gestion des fichiers statiques</a></p>
         <div class="manual_div_content">
            La classe <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a>) dispose d'une méthode statique permettant d'envoyer au navigateur web client des fichiers stockés sur le serveur (par exemple : fichiers HTML, Javascript, CSS, images PNG, JPEG, vidéos, etc...).
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/files/*"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <font style="background-color:yellow">qx::QxHttpServer::buildResponseStaticFile(request, response, QDir::currentPath(), 5000);</font>
});</pre>
            </td></tr></tbody></table>
            <br/>
            <ul>
               <li>Le 3ème paramètre (dans l'exemple <i>QDir::currentPath()</i>) représente le répertoire parent où sont stockés les fichiers statiques sur le serveur web ;</li>
               <li>Le 4ème paramètre (dans l'exemple <i>5000</i>) est optionnel et correspond à la taille pour <a href="#manual_852">l'envoi des fichiers par bloc (chunked response)</a>. Ce paramètre peut être utile pour envoyer des fichiers volumineux (streaming).</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_852">Encodage de transfert en bloc (chunked responses)</a></p>
         <div class="manual_div_content">
            <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" target="_blank">Définition du site Wikipedia :</a> Chunked transfer encoding (ou Encodage de transfert en bloc) est un mécanisme de transfert de données de la version 1.1 du protocole Hypertext Transfer Protocol (HTTP), qui permet à un serveur ou à un client de commencer à transmettre des données par blocs sans avoir à connaître à l'avance la taille totale des données qui seront transmises.
            Dans le protocole HTTP, l'en-tête "Content-Length" peut remplacer la directive "Chunked transfer encoding" décrite ici.
            La taille en octets de chaque bloc est envoyée, sous forme de texte en hexadecimal, juste avant le bloc lui-même afin que le serveur puisse dire au client quand il a fini de recevoir les données de ce bloc.
            Le transfert total d'un fichier encodé par blocs se termine par un bloc final au contenu nul.
            <br/><br/>
            L'introduction de l'encodage de transfert en bloc du protocole HTTP 1.1 a fourni un certain nombre d'avantages :
            <ul>
               <li>Permettre à un serveur de maintenir une connexion HTTP persistante pour un contenu généré dynamiquement.</li>
               <li>Permettre à l'expéditeur d'envoyer des en-têtes supplémentaires après le corps du message. Sans l'encodage de transfert en bloc, l'expéditeur devrait tamponner le contenu jusqu'à ce qu'il soit complété afin de calculer une valeur et l'envoyer avant le contenu.</li>
            </ul>
            <br/>
            La classe <a href="#manual_857">qx::QxHttpResponse</a> dispose de la méthode <i>qx_bool writeChunked(const QByteArray & data)</i>.
            Cette méthode permet d'envoyer la réponse par bloc.
            Elle est utilisée par exemple pour <a href="#manual_851">envoyer des fichiers statiques volumineux</a> :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">while</span> (! file.atEnd())
{
   <span class="keyword">if</span> (! <font style="background-color:yellow">response.writeChunked(file.read(chunkedSize))</font>) { <span class="keyword">return</span>; }
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Remarque :</b> le 1er appel de la méthode <i>response.writeChunked()</i> déclenche automatiquement l'envoi de tous les en-têtes HTTP de la réponse.
            Il faut donc définir tous les en-têtes de la réponse HTTP avant d'appeler <i>response.writeChunked()</i> pour la 1ère fois.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_853">Requêtes par les API JSON (module QxRestApi)</a></p>
         <div class="manual_div_content">
            Le <a href="#manual_97">module QxRestApi</a> propose une API JSON générique pour requêter les données persistantes (opérations CRUD, requêtes complexes avec plusieurs niveaux de relations, possibilité de définir un format de sortie JSON, appels dynamiques à des fonctions natives C++, validation d'instances, requêtes personnalisées à la base de données).
            <br/><br/>
            Ce manuel utilisateur dispose d'un chapitre entier dédié au <a href="#manual_97">module QxRestApi</a> : il contient notamment de nombreux exemples d'utilisation.
            En combinant le <a href="#manual_97">module QxRestApi</a> et le <b>module QxHttpServer</b> : vous avez tous les outils nécessaires pour développer des applications web modernes.
            Par exemple, des applications web de type <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank">SPA (<i>Single-Page Applications</i>)</a> avec les célèbres frameworks Javascript comme <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
            <br/><br/>
            <b>Remarque :</b> le package QxOrm contient un <a href="#manual_972">projet de test <b><i>qxBlogRestApi</i></b></a>.
            Ce projet présente la création d'un serveur web HTTP avec QxOrm, et également l'écriture de la partie cliente en HTML + Javascript (avec utilisation de <a href="https://jquery.com/" target="_blank">jQuery</a>).
            <br/><br/>
            Par exemple, voici la fonction Javascript utilisée pour envoyer les requêtes JSON (méthode POST) depuis le client (navigateur web) vers le serveur web HTTP QxOrm (toutes les requêtes sont envoyées à la même adresse <i>/qx</i>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">function</span> sendRequest(request) {
   <font style="background-color:yellow">$.post(<span class="string">"/qx"</span>, request</font>, function(data, status, xhr) {
      $(<span class="string">"#txtResponse"</span>).val(JSON.stringify(data, null, 3));
   }, <span class="string">"json"</span>).fail(function(error) {
      alert(<span class="string">"An error occurred sending request to QxOrm HTTP server : "</span> + error);
   });
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Côté serveur, la réception et le traitement de ces requêtes est très simple : la classe <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a>) dispose de la méthode statique <b>qx::QxHttpServer::buildResponseQxRestApi()</b> :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"POST"</span>, <span class="string">"/qx"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <font style="background-color:yellow">qx::QxHttpServer::buildResponseQxRestApi(request, response);</font>
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici un exemple de requête JSON envoyée par le navigateur web, elle récupère la liste des tous les blogs de la base de données (<i>fetch_all</i>) :
            <br/><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "2b393e4c-a00c-45dc-a279-e9d76f1c55cf",
   "action": "fetch_all",
   "entity": "blog"
}</pre>
            </div>
            <br/><br/>
            Voici la réponse JSON renvoyée par le serveur web HTTP contenant la liste de blogs :
            <br/><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "2b393e4c-a00c-45dc-a279-e9d76f1c55cf"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_854">WebSocket</a></p>
         <div class="manual_div_content">
            <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">Définition du site Wikipedia :</a> le protocole WebSocket vise à développer un canal de communication full-duplex sur un socket TCP pour les navigateurs et les serveurs web et permet :
            <ul>
               <li>la notification au client d'un changement d'état du serveur ;</li>
               <li>l'envoi de données en mode « pousser » (méthode Push) du serveur vers le client (sans que ce dernier ait à effectuer une requête).</li>
            </ul>
            <br/>
            La bibliothèque QxOrm est basée sur le framework Qt qui dispose déjà d'une <a href="https://doc.qt.io/qt-5/qtwebsockets-index.html" target="_blank">implémentation WebSocket</a>.<br/>
            La mise en place d'un serveur web avec les WebSockets Qt est très simple : <a href="https://doc.qt.io/qt-5/echoserver.html" target="_blank">il y a plusieurs exemples dans la documentation Qt</a>.
            <br/><br/>
            Il est donc tout à fait possible d'implémenter un serveur web avec :
            <ul>
               <li>un port d'écoute dédié à toutes les connexions HTTP (utilisant le module <b>QxHttpServer</b>) ;</li>
               <li>un autre port d'écoute dédié à toutes les connexions WebSockets (utilisant le module <a href="https://doc.qt.io/qt-5/qtwebsockets-index.html" target="_blank">QtWebSockets</a> fourni par Qt).</li>
            </ul>
            <br/>
            <b>Remarque :</b> une connexion WebSocket étant généralement créée par le code Javascript du navigateur web client, le fait d'avoir 2 ports ouverts sur le serveur web n'est pas un problème.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_855">Performance (testé avec Apache Benchmark)</a></p>
         <div class="manual_div_content">
            Voici les résultats d'un test de performance réalisé avec les paramètres suivants :
            <ul>
               <li>Système d'exploitation : <i>Windows 2010 64bits</i> ;</li>
               <li>Processeur : <i>Intel Core i7-6820HQ @ 2.70GHz</i> (laptop) ;</li>
               <li>Version Qt : <i>5.1.1</i> (en mode release) ;</li>
               <li>Version QxOrm : <i>1.4.6</i> (compilé en mode release avec Visual Studio 2012, avec les paramètres par défaut, aucune optimisation particulière) ;</li>
               <li>Serveur web HTTP : <a href="#manual_972">projet de test <i>qxBlogRestApi</i></a> ;</li>
               <li>Outil de test : <a href="https://httpd.apache.org/docs/2.4/programs/ab.html" target="_blank">Apache Benchmark</a> ;</li>
               <li>Simulation de 20000 requêtes avec 50 clients connectés simultanément : <i><b>ab -n 20000 -c 50 -k http://localhost:9642/params/abc/123</b></i></li>
            </ul>
            <br/>
            Le résultat indique que le serveur web HTTP QxOrm peut gérer <font style="background-color:yellow">plus de 12000 requêtes par seconde</font> :
            <br/><br/>
            <img alt="QxHttpServer performance" src="./resource/qx_http_server_apache_bench_test_01.png" border="0">
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_8550">Améliorer les performances avec epoll dispatcher sous Linux</a></p>
            <div class="manual_div_content">
               Sous Linux, il est possible d'ameliorer significativement les performances du serveur web HTTP en utilisant <a href="https://en.wikipedia.org/wiki/Epoll" target="_blank">le mécanisme epoll pour gérer les socket</a>.
               Par défaut, le framework Qt utilise un autre mécanisme (<i>select</i>) plus lent, mais donne la possibilité de définir une autre gestion d'évènements.
               Plusieurs bibliothèques existent, par exemple :
               <ul>
                  <li><a href="https://github.com/sjinks/qt_eventdispatcher_epoll" target="_blank">qt_eventdispatcher_epoll</a></li>
                  <li><a href="https://github.com/connectedtable/qeventdispatcher_epoll" target="_blank">qeventdispatcher_epoll</a></li>
               </ul>
               <br/>
               La classe <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> (ou son alias <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a>) dispose de la méthode suivante pour définir des évènements basés sur epoll (à appeler avant le démarrage du serveur web) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   httpServer.setEventDispatcher(new QEventDispatcherEpoll());   </pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_97">API REST JSON (module QxRestApi)</a></p>
      <div class="manual_div_content_1">
         Le <b>module QxRestApi</b> est une API JSON pour gérer (de façon générique) la couche de données persistantes (base de données) ou <a href="#manual_961">appeler des fonctions natives C++</a> (enregistrées dans le contexte QxOrm).
         Le <b>module QxRestApi</b> est basé sur un mécanisme requête/réponse : envoi d'une requête au format JSON et réception d'une réponse au format JSON.
         Le <b>module QxRestApi</b> est particulièrement adapté pour développer des <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">services REST</a>.
         <br/><br/>
         Le <b>module QxRestApi</b> supporte les fonctionnalités suivantes :
         <ul>
            <li>opérations CRUD ;</li>
            <li>requêtes complexes avec plusieurs niveaux de relations ;</li>
            <li>possibilité de définir un format de sortie JSON ;</li>
            <li>appels dynamiques à des fonctions natives C++ ;</li>
            <li>validation d'instances ;</li>
            <li>requêtes personnalisées à la base de données ou procédures stockées.</li>
         </ul>
         <br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_971">Principe de fonctionnement</a></p>
         <div class="manual_div_content">
            Le <b>module QxRestApi</b> est très simple d'utilisation : la classe <a href="../doxygen/html/classqx_1_1_qx_rest_api.html" target="_blank"><i>qx::QxRestApi</i></a> permet d'utiliser les API JSON avec une seule méthode : <i><b>processRequest()</b></i>.<br/>
            <b>Prérequis :</b> pour pouvoir utiliser le <b>module QxRestApi</b>, les classes enregistrées dans le contexte QxOrm doivent <font style="background-color:yellow"><a href="#manual_450">implémenter l'interface <b>qx::IxPersistable</b></a></font>.
            <br/><br/>
            La structure d'une requête JSON est générique et contient les éléments suivants :
            <br/><br/>
            <div style="width: 1000px; max-height: 300px; overflow: auto; background-color: white;">
<pre>{
   <span class="string">"request_id"</span> : <span class="comment">// [optional] unique identifier generated by client to associate response to request (if provided by caller, then the response will contain the same unique identifier)</span>
   <span class="string">"action"</span> : <span class="comment">// [required] what is the action to execute on the server</span>
   <span class="string">"entity"</span> : <span class="comment">// [optional or required depending on action] C++ class registered in QxOrm context</span>
   <span class="string">"data"</span> : <span class="comment">// [optional or required depending on action] data in JSON format needed to execute action</span>
   <span class="string">"columns"</span> : <span class="comment">// [optional] list of columns to fetch or update (if empty, means all columns)</span>
   <span class="string">"relations"</span> : <span class="comment">// [optional] list of relationships to fetch or save</span>
   <span class="string">"query"</span> : <span class="comment">// [optional or required depending on action] query to execute on database</span>
   <span class="string">"output_format"</span> : <span class="comment">// [optional] output fields for the response (filter), if empty then response will contain all fields</span>
   <span class="string">"fct"</span> : <span class="comment">// [required only with action 'call_entity_function'] used to call C++ native functions</span>
   <span class="string">"save_mode"</span> : <span class="comment">// [optional] used only with action 'save' to define insert or update or check both insert/update</span>
}</pre>
            </div>
            <br/><br/>
            La réponse JSON contient les éléments suivants :
            <br/><br/>
            <div style="width: 1000px; max-height: 300px; overflow: auto; background-color: white;">
<pre>{
   <span class="string">"request_id"</span> : <span class="comment">// unique identifier generated by client's request (if any)</span>
   <span class="string">"data"</span> : <span class="comment">// contain the response data</span>
   <span class="string">"error"</span> : <span class="comment">// if an error occured, then contain a code and description of the error</span>
}</pre>
            </div>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9710">Cas d'utilisation</a></p>
            <div class="manual_div_content">
               Plusieurs langages de programmation supporte le JSON nativement (Javascript, PHP, Python, etc...).
               Le <b>module QxRestApi</b> permet ainsi une interopérabilité entre la bibliothèque QxOrm et d'autres applications utilisant d'autres technologies (autre que C++/Qt par exemple).
               <br/><br/>
               Le <b>module QxRestApi</b> peut être utilisé :
               <ul>
                  <li>Développement d'un serveur web HTTP (avec le <a href="#manual_96">module QxHttpServer</a> par exemple) ;</li>
                  <li>Publication de <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">web-services REST</a> ;</li>
                  <li>Accès aux données persistantes depuis une application QML (voir le <a href="#manual_972">projet de test qxBlogRestApi</a>) ;</li>
                  <li>Possibilité de scripter l'application C++ (avec un langage comme Python par exemple).</li>
               </ul>
               <br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_972">Projet de test qxBlogRestApi (QML et serveur web HTTP)</a></p>
         <div class="manual_div_content">
            Le package QxOrm est livré avec un projet de test nommé <b>qxBlogRestApi</b> (dans le dossier <i>./test/qxBlogRestApi/</i>).<br/>
            Ce projet de test montre 2 cas d'utilisation du <b>module QxRestApi</b> :
            <ul>
               <li>La 1ère fenêtre correspond à <font style="background-color:yellow">une application QML</font> qui utilise le moteur JS intégré à QML pour requêter les données persistantes ou appeler des fonctions natives C++ :
               <br/><br/><img alt="QxHttpServer performance" src="./resource/qx_blog_rest_api_qml_01.png" border="0"><br/><br/><br/></li>
               <li>La 2ème fenêtre démarre <font style="background-color:yellow">un serveur web HTTP</font> basé sur le <a href="#manual_96">module QxHttpServer</a>, puis ouvre le navigateur web par défaut à l'adresse correspondante (HTML + Javascript avec <a href="https://jquery.com/" target="_blank">jQuery</a>) :
               <br/><br/><img alt="QxHttpServer performance" src="./resource/qx_blog_rest_api_http_01.png" border="0"><br/></li>
            </ul>
            <br/>
            Ces 2 fenêtres sont développées avec 2 technologies différentes (QML versus HTML + Javascript), mais proposent exactement les mêmes fonctionnalités :
            <ul>
               <li>En haut à gauche de l'écran : zone permettant d'écrire la requête JSON à envoyer au <b>module QxRestApi</b> ;</li>
               <li>Juste en dessous de la requête JSON : un bouton permettant d'envoyer la requête JSON au <b>module QxRestApi</b> ;</li>
               <li>En bas à gauche de l'écran : une liste d'exemples de requêtes JSON prêtes à être exécutées (un click dans cette liste alimente automatiquement la requête JSON à envoyer au <b>module QxRestApi</b>) ;</li>
               <li>A droite de l'écran : la réponse JSON fournie par le <b>module QxRestApi</b> après traitement de la requête.</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_973">Récupération de données (fetch/count/exist)</a></p>
         <div class="manual_div_content">
            Ce chapitre détaille les différentes méthodes pour récupérer les données issues de la base de données :
            <ul>
               <li>Récupérer tous les éléments d'une table et éventuellement <a href="#manual_3840">les relations associées</a> (<a href="#manual_9731">fetch_all</a>) ;</li>
               <li>Récupérer les données d'un élément d'une table en fonction de son identifiant unique (<a href="#manual_9732">fetch_by_id</a>) ;</li>
               <li>Récupérer les éléments d'une table <a href="#manual_360">filtrés par une requête</a> (<a href="#manual_9733">fetch_by_query</a>) ;</li>
               <li>Compter les éléments d'une table avec ou sans requête (<a href="#manual_9734">count</a>) ;</li>
               <li>Tester l'existence d'un ou plusieurs éléments d'une table en fonction de l'identifiant (<a href="#manual_9735">exist</a>).</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9731">fetch_all</a></p>
            <div class="manual_div_content">
               L'action <b><i>fetch_all</i></b> permet de récupérer tous les éléments d'une table de la base de données (et éventuellement <a href="#manual_3840">les relations associées sur plusieurs niveaux</a>).
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> récupérer tous les blogs (sous forme de liste) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "5e988bac-c812-4cb1-b0d8-6a2c9dc4478b",
   "action": "fetch_all",
   "entity": "blog"
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "5e988bac-c812-4cb1-b0d8-6a2c9dc4478b"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> récupérer tous les blogs (sous forme de collection type <i>hash-map</i> avec clé/valeur) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "ad400135-19fd-40e0-8034-201be6a2ff7a",
   "action": "fetch_all",
   "entity": "blog",
   "data": [
      {
         "key": "",
         "value": ""
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "key": 1,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 1,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 2,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 2,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 3,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 3,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 4,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 4,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      }
   ],
   "request_id": "ad400135-19fd-40e0-8034-201be6a2ff7a"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> récupérer tous les blogs et <a href="#manual_3840">toutes les relations associées sur 2 niveaux</a> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "cf9ea2a8-3e41-438f-9a48-bbc8593d2b99",
   "action": "fetch_all",
   "entity": "blog",
   "relations": [
      "*-&gt;*"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 1,
               "value": {
                  "category_id": 1,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 1,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 1,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 3,
               "value": {
                  "category_id": 3,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 1,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 1,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": [
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 1,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 3,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 5,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 7,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 2,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 4,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 6,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 8,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 4,
               "value": {
                  "category_id": 4,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 2,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 2,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 5,
               "value": {
                  "category_id": 5,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 2,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 2,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 6,
               "value": {
                  "category_id": 6,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 3,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 3,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 7,
               "value": {
                  "category_id": 7,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 3,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 3,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 8,
               "value": {
                  "category_id": 8,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 4,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 4,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 9,
               "value": {
                  "category_id": 9,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 4,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 4,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      }
   ],
   "request_id": "cf9ea2a8-3e41-438f-9a48-bbc8593d2b99"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°4 --</b></font> récupérer tous les blogs et <a href="#manual_3840">plusieurs relations associées</a> en définissant un format de sortie (toutes les propriétés ne feront pas partie de la réponse JSON) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "4c45fdf9-8001-4509-bb4b-ce27a4a8708a",
   "action": "fetch_all",
   "entity": "blog",
   "relations": [
      "&lt;blog_alias&gt; { blog_text }",
      "author_id &lt;author_alias&gt; { name, birthdate }",
      "list_comment &lt;list_comment_alias&gt; { comment_text } -&gt; blog_id &lt;blog_alias_2&gt; -&gt; * &lt;..._my_alias_suffix&gt;"
   ],
   "output_format": [
      "{ blog_text }",
      "author_id { name, birthdate }",
      "list_comment { comment_text } -&gt; blog_id -&gt; *"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": [
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 1,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 3,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 5,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 7,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 2,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 4,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 6,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 8,
               "comment_text": "comment_2 text"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      }
   ],
   "request_id": "4c45fdf9-8001-4509-bb4b-ce27a4a8708a"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9732">fetch_by_id</a></p>
            <div class="manual_div_content">
               L'action <b><i>fetch_by_id</i></b> permet de récupérer les données d'un élément d'une table en fonction de son identifiant unique.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> récupérer les données du blog qui a pour identifiant unique 1 :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "4d6fbb9e-e088-482a-abfa-4e7ddee80569",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 1
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "author_id": {
         "author_id": "author_id_2",
         "birthdate": null,
         "list_blog": [],
         "name": "",
         "sex": 2
      },
      "blog_id": 1,
      "blog_text": "blog property 'text' modified => blog is dirty !!!",
      "date_creation": "2019-04-01T16:18:54",
      "list_category": [],
      "list_comment": []
   },
   "request_id": "4d6fbb9e-e088-482a-abfa-4e7ddee80569"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> récupère uniquement quelques données du blog qui a pour identifiant unique 1 (les autres données font partie du JSON mais avec une valeur vide ou null) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "72c9b362-d194-410e-98ed-23797a34318e",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 1
   },
   "columns": [
      "blog_text",
      "date_creation"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "author_id": null,
      "blog_id": 1,
      "blog_text": "blog property 'text' modified => blog is dirty !!!",
      "date_creation": "2019-04-01T16:18:54",
      "list_category": [],
      "list_comment": []
   },
   "request_id": "72c9b362-d194-410e-98ed-23797a34318e"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> récupère une liste de blogs en fonction de leur identifiant :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "59c37f70-26ee-42e5-9177-b32c331adce1",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 2
      },
      {
         "blog_id": 3
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "59c37f70-26ee-42e5-9177-b32c331adce1"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°4 --</b></font> récupère une liste de blogs (avec quelques relations associées) en fonction de leur identifiant, et défini un format de sortie (toutes les propriétés ne feront pas partie de la réponse JSON) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "325d64f4-29ac-47ab-9846-d6a71a9e9d73",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 2
      }
   ],
   "relations": [
      "{ blog_text }",
      "author_id &lt;author_alias&gt; { name, birthdate }",
      "list_comment &lt;list_comment_alias&gt; { comment_text }"
   ],
   "output_format": [
      "{ blog_text }",
      "author_id { name, birthdate }",
      "list_comment { comment_text }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": [
            {
               "comment_id": 1,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 2,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 3,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 4,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 5,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 6,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 7,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 8,
               "comment_text": "comment_2 text"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      }
   ],
   "request_id": "325d64f4-29ac-47ab-9846-d6a71a9e9d73"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9733">fetch_by_query</a></p>
            <div class="manual_div_content">
               L'action <b><i>fetch_by_query</i></b> permet de récupérer les éléments d'une table <a href="#manual_360">filtrés par une requête</a>.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> récupère uniquement les éléments de la table <i>author</i> dont le sexe est de type <i>female</i> (<i>female</i> == enum dont la valeur est 1) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "c178194c-a76f-4a77-af12-2b97fc7078e4",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [],
         "name": "author name modified at index 1 => container is dirty !!!",
         "sex": 1
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3",
         "sex": 1
      }
   ],
   "request_id": "c178194c-a76f-4a77-af12-2b97fc7078e4"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> récupère uniquement les éléments de la table <i>author</i> (et toutes ses <a href="#manual_3840">relations associées</a>) dont le sexe est de type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "84e2e13a-0bf9-4d78-b655-970568a97e4c",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1,
            "type": "in"
         }
      ]
   },
   "relations": [
      "*"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 1,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 2,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 3,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 4,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            }
         ],
         "name": "author name modified at index 1 => container is dirty !!!",
         "sex": 1
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3",
         "sex": 1
      }
   ],
   "request_id": "84e2e13a-0bf9-4d78-b655-970568a97e4c"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> récupère uniquement les éléments de la table <i>author</i> (et toutes ses <a href="#manual_3840">relations associées</a>) dont le sexe est de type <i>female</i>, et défini un format de sortie (toutes les propriétés ne feront pas partie de la réponse JSON) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "c18b59e7-54f9-4a4f-843d-f0797f4fb676",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1,
            "type": "in"
         }
      ]
   },
   "relations": [
      "*"
   ],
   "output_format": [
      "{ birthdate, name }",
      "list_blog { blog_text, date_creation }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [
            {
               "blog_id": 1,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 2,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 3,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 4,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            }
         ],
         "name": "author name modified at index 1 => container is dirty !!!"
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3"
      }
   ],
   "request_id": "c18b59e7-54f9-4a4f-843d-f0797f4fb676"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9734">count</a></p>
            <div class="manual_div_content">
               L'action <b><i>count</i></b> permet de compter les éléments d'une table avec ou sans requête (et avec ou sans relation).
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> compter le nombre de blogs dans la base de données :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "1ef62fd7-d847-4d67-9fd0-0207af463aa4",
   "action": "count",
   "entity": "blog"
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 4
   },
   "request_id": "1ef62fd7-d847-4d67-9fd0-0207af463aa4"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> compter tous les <i>author</i> dont le sexe est de type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "a80646d1-5a42-46fb-9306-3b91c7f594c8",
   "action": "count",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 2
   },
   "request_id": "a80646d1-5a42-46fb-9306-3b91c7f594c8"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> compter tous les blogs dont l'<i>author</i> est de type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "6ef252f7-385c-465e-8304-b9afa9fea490",
   "action": "count",
   "entity": "blog",
   "query": {
      "sql": "WHERE author_alias.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   },
   "relations": [
      "author_id &lt;author_alias&gt; { sex }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 4
   },
   "request_id": "6ef252f7-385c-465e-8304-b9afa9fea490"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9735">exist</a></p>
            <div class="manual_div_content">
               L'action <b><i>exist</i></b> permet de tester l'existence d'un ou plusieurs éléments d'une table en fonction de l'identifiant.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> tester l'existence d'un blog dont l'identifiant unique a pour valeur 1 :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "e8db33db-b249-4349-93fe-ad12e208520e",
   "action": "exist",
   "entity": "blog",
   "data": {
      "blog_id": 1
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": true
   },
   "request_id": "e8db33db-b249-4349-93fe-ad12e208520e"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> tester l'existence de plusieurs blogs :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "f2d6ca3f-36de-4920-8f4c-c04842603467",
   "action": "exist",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 999
      },
      {
         "blog_id": 3
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": false
   },
   "request_id": "f2d6ca3f-36de-4920-8f4c-c04842603467"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> tester l'existence d'un <i>author</i> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "2c7df172-8010-4816-b8e1-3edbb0b0b90e",
   "action": "exist",
   "entity": "author",
   "data": {
      "author_id": "author_id_2"
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": true
   },
   "request_id": "2c7df172-8010-4816-b8e1-3edbb0b0b90e"
}</pre>
               </div>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_974">Ajout de données (insert)</a></p>
         <div class="manual_div_content">
            L'action <b><i>insert</i></b> permet d'insérer un ou plusieurs éléments dans la base de données.
            Les identifiants uniques générés par la base de données (par exemple identifiant auto-incrémenté) sont fournis dans la réponse JSON.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> insérer un blog dans la base de données :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "573e4940-607a-4037-8a09-11ec52deb21c",
   "action": "insert",
   "entity": "blog",
   "data": {
      "blog_text": "this is a new blog from QxOrm REST API !",
      "date_creation": "2018-01-30T12:42:01",
      "author_id": "author_id_2"
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 5
   },
   "request_id": "573e4940-607a-4037-8a09-11ec52deb21c"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> insérer une liste de blogs dans la base de données :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "6ade2d01-086c-45d6-971b-b65e8836475f",
   "action": "insert",
   "entity": "blog",
   "data": [
      {
         "blog_text": "new blog from QxOrm REST API !",
         "date_creation": "2018-01-30T12:42:01",
         "author_id": "author_id_2"
      },
      {
         "blog_text": "another blog from QxOrm REST API !",
         "date_creation": "2016-06-12T08:33:12",
         "author_id": "author_id_1"
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 6
      },
      {
         "blog_id": 7
      }
   ],
   "request_id": "6ade2d01-086c-45d6-971b-b65e8836475f"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> insérer un <i>author</i> dans la base de données :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57",
   "action": "insert",
   "entity": "author",
   "data": {
      "author_id": "author_id_from_rest_api",
      "birthdate": "1978-05-11",
      "name": "new author created by QxOrm REST API",
      "sex": 1
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "author_id": "author_id_from_rest_api"
   },
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57"
}</pre>
            </div>
            <br/>
            <b>Remarque :</b> l'identifiant unique de la table <i>author</i> doit être fourni par l'appelant (non auto-incrémenté).
            Si on rejoue une 2ème fois la même requête, on obtient l'erreur suivante :
            <br/>
            <div class="json_pretty">
<pre>{
   "error": {
      "code": 19,
      "desc": "Unable to fetch row\ncolumn author_id is not unique"
   },
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_975">Mise à jour de données (update)</a></p>
         <div class="manual_div_content">
            L'action <b><i>update</i></b> permet une mise à jour de un ou plusieurs éléments dans la base de données.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> mise à jour du blog avec pour identifiant unique la valeur 1 :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "4fa24a7f-a3d8-4bbf-85c1-c86df83dec0b",
   "action": "update",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": "author_id_1"
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "4fa24a7f-a3d8-4bbf-85c1-c86df83dec0b"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> mise à jour uniquement de certaines colonnes d'un blog :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "d0704db1-5c3a-48ad-b27e-14aa54ac0efb",
   "action": "update",
   "entity": "blog",
   "data": {
      "blog_id": 2,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33"
   },
   "columns": [
      "blog_text",
      "date_creation"
   ]
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 2
   },
   "request_id": "d0704db1-5c3a-48ad-b27e-14aa54ac0efb"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> mise à jour de plusieurs <i>author</i> :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "26ec3a7b-cf2d-47f7-bab7-db303f15ee51",
   "action": "update",
   "entity": "author",
   "data": [
      {
         "author_id": "author_id_from_rest_api",
         "birthdate": "1992-11-03",
         "name": "modify author from QxOrm REST API",
         "sex": 0
      },
      {
         "author_id": "author_id_1",
         "birthdate": "1978-12-25",
         "name": "modify another author from QxOrm REST API",
         "sex": 2
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_from_rest_api"
      },
      {
         "author_id": "author_id_1"
      }
   ],
   "request_id": "26ec3a7b-cf2d-47f7-bab7-db303f15ee51"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_976">Sauvegarde de données (save)</a></p>
         <div class="manual_div_content">
            L'action <b><i>save</i></b> permet d'insérer ou mettre à jour (<i>insert</i> ou <i>update</i>) un ou plusieurs éléments dans la base de données.
            En cas d'insertion, les identifiants uniques générés par la base de données (par exemple identifiant auto-incrémenté) sont fournis dans la réponse JSON.
            <br/><br/>
            La requête JSON dispose d'un paramètre optionnel nommé <i>save_mode</i> qui peut prendre les valeurs suivantes :
            <ul>
               <li><i>check_insert_or_update :</i> sauvegarde l'instance et les relations de façon récursive (sur plusieurs niveaux) en vérifiant pour chaque relation s'il faut faire un <i>insert</i> ou <i>update</i> (méthode pouvant être lente si beaucoup de relations à traiter) ;</li>
               <li><i>insert_only :</i> insère de façon récursive (sur plusieurs niveaux) l'instance et toutes les relations associées ;</li>
               <li><i>update_only :</i> met à jour de façon récursive (sur plusieurs niveaux) l'instance et toutes les relations associées.</li>
            </ul>
            <br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> sauvegarde (insère ou met à jour suivant l'identifant unique) un blog dans la base de données :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ec3c71eb-5014-4b36-85a0-aeb7ae48a5e9",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": "author_id_1"
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "ec3c71eb-5014-4b36-85a0-aeb7ae48a5e9"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> sauvegarde (insère ou met à jour suivant l'identifant unique) une liste de blogs dans la base de données :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "dc7c804e-f95a-4a9b-a4e3-547adcacf090",
   "action": "save",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1,
         "blog_text": "save blog from QxOrm REST API !",
         "date_creation": "2018-01-30T12:42:01",
         "author_id": "author_id_2"
      },
      {
         "blog_text": "save another blog from QxOrm REST API !",
         "date_creation": "2016-06-12T08:33:12",
         "author_id": "author_id_1"
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 5
      }
   ],
   "request_id": "dc7c804e-f95a-4a9b-a4e3-547adcacf090"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°3 --</b></font> sauvegarde (insère ou met à jour suivant l'identifant unique) un blog et toutes ses relations sur plusieurs niveaux (de façon récursive) :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "5b78e468-2fa3-4aeb-82ce-4d85408f5fa7",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "save recursive blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": {
         "author_id": "author_id_1",
         "birthdate": "1965-07-21",
         "name": "save recursive author from QxOrm REST API",
         "sex": 0
      }
   },
   "save_mode": "check_insert_or_update"
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "5b78e468-2fa3-4aeb-82ce-4d85408f5fa7"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°4 --</b></font> insère (<i>save_mode</i> = <i>insert_only</i>) un blog et toutes ses relations sur plusieurs niveaux (de façon récursive) :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ef147c62-74e0-4be2-a294-ffeb020d5304",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_text": "save recursive - new blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": {
         "author_id": "author_id_save_recursive",
         "birthdate": "1965-07-21",
         "name": "save recursive (insert only) author from QxOrm REST API",
         "sex": 0
      }
   },
   "save_mode": "insert_only"
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 7
   },
   "request_id": "ef147c62-74e0-4be2-a294-ffeb020d5304"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_977">Suppression de données (delete)</a></p>
         <div class="manual_div_content">
            Ce chapitre détaille les différentes méthodes pour supprimer des éléments de la base de données :
            <ul>
               <li>Supprimer tous les éléments d'une table (<a href="#manual_9771">delete_all / destroy_all</a>) ;</li>
               <li>Supprimer les éléments d'une table en fonction d'une requête (<a href="#manual_9772">delete_by_query / destroy_by_query</a>) ;</li>
               <li>Supprimer les éléments d'une table en fonction de leur identifiant unique (<a href="#manual_9773">delete_by_id / destroy_by_id</a>).</li>
            </ul>
            <br/>
            <b>Remarque :</b> la différence entre <i>delete</i> et <i>destroy</i> est liée à la <a href="#manual_3400">suppression logique (soft delete)</a> d'un élément.
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9771">delete_all / destroy_all</a></p>
            <div class="manual_div_content">
               Les actions <b><i>delete_all</i></b> et <b><i>destroy_all</i></b> permettent de supprimer tous les éléments d'une table.
               La différence entre <i>delete</i> et <i>destroy</i> est liée à la <a href="#manual_3400">suppression logique (soft delete)</a> d'un élément.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> supprime tous les éléments de la table <i>comment</i> :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "7b06b5c0-409f-4e0d-bfc4-acafbfe7e796",
   "action": "delete_all",
   "entity": "comment"
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "deleted": true
   },
   "request_id": "7b06b5c0-409f-4e0d-bfc4-acafbfe7e796"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9772">delete_by_query / destroy_by_query</a></p>
            <div class="manual_div_content">
               Les actions <b><i>delete_by_query</i></b> et <b><i>destroy_by_query</i></b> permettent de supprimer les éléments d'une table en fonction d'une requête.
               La différence entre <i>delete</i> et <i>destroy</i> est liée à la <a href="#manual_3400">suppression logique (soft delete)</a> d'un élément.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> supprime les éléments de la table <i>author</i> qui ont un sexe de type <i>female</i> (<i>female</i> = enum de valeur 1) :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "169ff0be-6e49-457b-a99c-22bd7141dc02",
   "action": "delete_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "deleted": true
   },
   "request_id": "169ff0be-6e49-457b-a99c-22bd7141dc02"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9773">delete_by_id / destroy_by_id</a></p>
            <div class="manual_div_content">
               Les actions <b><i>delete_by_id</i></b> et <b><i>destroy_by_id</i></b> permettent de supprimer les éléments d'une table en fonction de leur identifiant unique.
               La différence entre <i>delete</i> et <i>destroy</i> est liée à la <a href="#manual_3400">suppression logique (soft delete)</a> d'un élément.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> supprime de la base de données le blog qui a pour identifiant unique la valeur 4 :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "80bff383-8ebd-4bde-bb42-37b6f67bc39f",
   "action": "delete_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 4
   }
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 4
   },
   "request_id": "80bff383-8ebd-4bde-bb42-37b6f67bc39f"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> supprime de la base de données les blogs qui ont pour identifiant unique les valeurs 2 et 3 :
               <br/><br/>
               <font style="color:blue"><i>Requête JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "38020cb7-d725-4c0e-80a0-63db7569155e",
   "action": "delete_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 3
      },
      {
         "blog_id": 2
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>Réponse JSON :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 3
      },
      {
         "blog_id": 2
      }
   ],
   "request_id": "38020cb7-d725-4c0e-80a0-63db7569155e"
}</pre>
               </div>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_978">Validation de données (validate)</a></p>
         <div class="manual_div_content">
            L'action <b><i>validate</i></b> permet de valider les propriétés d'une instance (sans déclencher d'action sur la base de données).
            L'action <b><i>validate</i></b> appelle <a href="#manual_420">le module QxValidator</a> de la bibliothèque QxOrm.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> un <i>blog</i> doit contenir du texte (propriété <i>blog_text</i>) pour pouvoir être sauvegardé dans la base de données.
            La requête JSON suivante permet d'indiquer que l'instance est non valide avec un message explicite :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba",
   "action": "validate",
   "entity": "blog",
   "data": {
      "blog_id": 9999,
      "blog_text": ""
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "invalid_values": [
         "blog",
         [
            {
               "message": "'blog_text' property cannot be empty",
               "path": "blog"
            }
         ]
      ]
   },
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°2 --</b></font> en ajoutant une valeur à la propriété <i>blog_text</i>, alors le <i>blog</i> devient valide (la réponse JSON dispose d'un champ <i>invalid_values</i> qui vaut <i>null</i>) :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba",
   "action": "validate",
   "entity": "blog",
   "data": {
      "blog_id": 9999,
      "blog_text": "my blog text !!!"
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "invalid_values": null
   },
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_979">Appel RAW SQL ou procédure stockée</a></p>
         <div class="manual_div_content">
            L'action <b><i>call_custom_query</i></b> permet d'appeler une requête SQL personnalisée ou une procédure stockée.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> insère dans la base de données un nouveau <i>author</i> avec une requête SQL personnalisée :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ff2a2256-041d-4c5f-bd86-3745ce46ead8",
   "action": "call_custom_query",
   "query": {
      "sql": "INSERT INTO author (author_id, name, birthdate, sex) VALUES (:author_id, :name, :birthdate, :sex)",
      "params": [
         {
            "key": ":author_id",
            "value": "author_id_custom_query"
         },
         {
            "key": ":name",
            "value": "new author inserted by custom query"
         },
         {
            "key": ":birthdate",
            "value": "20190215"
         },
         {
            "key": ":sex",
            "value": 2
         }
      ]
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "query_output": {
         "distinct": false,
         "list_values": {
            ":author_id": [
               "author_id_custom_query",
               1
            ],
            ":birthdate": [
               "20190215",
               1
            ],
            ":name": [
               "new author inserted by custom query",
               1
            ],
            ":sex": [
               2,
               1
            ]
         },
         "parenthesis_count": 0,
         "query": [
            "INSERT INTO author (author_id, name, birthdate, sex) VALUES (:author_id, :name, :birthdate, :sex)"
         ],
         "response": "",
         "result_position_by_key": {},
         "result_values": [],
         "sql_element_index": 0,
         "sql_element_list": [],
         "sql_element_temp_type": 0,
         "type": ""
      }
   },
   "request_id": "ff2a2256-041d-4c5f-bd86-3745ce46ead8"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_961">Appel fonctions natives C++</a></p>
         <div class="manual_div_content">
            L'action <b><i>call_entity_function</i></b> permet d'appeler des fonctions natives C++ enregistrées dans le contexte QxOrm.<br/>
            <b>Prérequis :</b> la fonction native C++ doit être une fonction <i>static</i> avec pour signature : <b><i><font style="background-color:yellow">static QJsonValue myNativeCppFct(const QJsonValue & request);</font></i></b>
            <br/><br/>
            Voici un exemple d'enregistrement de fonction native C++ pouvant être appelée par les API JSON de la bibliothèque QxOrm :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> register_class(QxClass&lt;blog&gt; & t)
{
   <span class="comment">// Register 'helloWorld()' static function in QxOrm context (can be called by QxRestApi JSON API module)</span>
   t.fctStatic_1&lt;<span class="type">QJsonValue</span>, const <span class="type">QJsonValue</span> & &gt;(& blog::helloWorld, <span class="string">"helloWorld"</span>);
}}

<span class="comment">// 'helloWorld()' static function implementation</span>
<span class="type">QJsonValue</span> blog::helloWorld(const <span class="type">QJsonValue</span> & request)
{
   <span class="type">QJsonObject</span> response;
   response.insert(<span class="string">"request"</span>, request);
   response.insert(<span class="string">"response"</span>, QString(<span class="string">"Hello World !"</span>));
   return response;
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Voici comment appeler cette fonction <i>helloWorld</i> avec les API JSON en utilisant l'action <b><i>call_entity_function</i></b> :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ab1ba7d3-9f98-4b18-a310-a9c34498d043",
   "action": "call_entity_function",
   "entity": "blog",
   "fct": "helloWorld",
   "data": {
      "param1": "test",
      "param2": "static fct call"
   }
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "request": {
         "param1": "test",
         "param2": "static fct call"
      },
      "response": "Hello World !"
   },
   "request_id": "ab1ba7d3-9f98-4b18-a310-a9c34498d043"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_962">Meta-data (structure des classes C++ enregistrées dans le contexte QxOrm)</a></p>
         <div class="manual_div_content">
            L'action <b><i>get_meta_data</i></b> permet de récupérer les méta-données d'une ou de toutes les entités enregistrées dans le contexte QxOrm (structure des classes avec liste des propriétés et relations).
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> récupère toutes les méta-données du <a href="#manual_972">projet d'exemple <i>qxBlogRestApi</i></a> :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "842ed7b5-9b94-455f-86dc-32992866b3d5",
   "action": "get_meta_data",
   "entity": "*"
}</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "entities": [
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "author_id",
               "type": "QString"
            },
            "key": "author",
            "name": "author",
            "properties": [
               {
                  "description": "",
                  "key": "name",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "birthdate",
                  "type": "QDate"
               },
               {
                  "description": "",
                  "key": "sex",
                  "type": "enum author::enum_sex *"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "list_blog",
                  "target": "blog",
                  "type": "std::vector&lt;std::shared_ptr&lt;blog&gt;&gt;",
                  "type_relation": "relation one-to-many"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "blog_id",
               "type": "long"
            },
            "key": "blog",
            "name": "blog",
            "properties": [
               {
                  "description": "",
                  "key": "blog_text",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "date_creation",
                  "type": "QDateTime"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "author_id",
                  "target": "author",
                  "type": "std::shared_ptr&lt;author&gt;",
                  "type_relation": "relation many-to-one"
               },
               {
                  "description": "",
                  "key": "list_comment",
                  "target": "comment",
                  "type": "QList&lt;std::shared_ptr&lt;comment&gt;&gt;",
                  "type_relation": "relation one-to-many"
               },
               {
                  "description": "",
                  "key": "list_category",
                  "target": "category",
                  "type": "qx::QxCollection&lt;long, QSharedPointer&lt;category&gt;&gt;",
                  "type_relation": "relation many-to-many"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "comment_id",
               "type": "long"
            },
            "key": "comment",
            "name": "comment",
            "properties": [
               {
                  "description": "",
                  "key": "comment_text",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "date_creation",
                  "type": "QDateTime"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "blog_id",
                  "target": "blog",
                  "type": "std::shared_ptr&lt;blog&gt;",
                  "type_relation": "relation many-to-one"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "category_id",
               "type": "long"
            },
            "key": "category",
            "name": "category",
            "properties": [
               {
                  "description": "",
                  "key": "name",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "description",
                  "type": "QString"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "list_blog",
                  "target": "blog",
                  "type": "qx::QxCollection&lt;long, std::shared_ptr&lt;blog&gt;&gt;",
                  "type_relation": "relation many-to-many"
               }
            ],
            "version": 0
         }
      ]
   },
   "request_id": "842ed7b5-9b94-455f-86dc-32992866b3d5"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_963">Envoyer une liste de requêtes JSON</a></p>
         <div class="manual_div_content">
            Afin de limiter le nombre de transactions entre le client et le serveur, il est possible d'envoyer une liste de requêtes JSON au <b>module QxRestApi</b>.
            Chaque requête JSON de la liste peut disposer de son propre identifiant <i>request_id</i> (afin d'associer une réponse JSON à la requête correspondante).
            Lorsqu'une liste de requêtes JSON est envoyée au <b>module QxRestApi</b>, alors <a href="#manual_370">une transaction (commit/rollback)</a> est automatiquement créée (ainsi en cas d'erreur, tous les traitements sur la base de données sont annulés).
            <br/><br/>
            <font style="background-color:yellow"><b>-- Exemple n°1 --</b></font> envoi 4 requêtes JSON au <b>module QxRestApi</b> (1 requête pour <a href="#manual_962">récupérer les méta-données du projet</a> + 3 requêtes <a href="#manual_9731"><i>fetch_all</i> avec différent niveau de récupération des relations</a>) :
            <br/><br/>
            <font style="color:blue"><i>Requête JSON :</i></font><br/>
            <div class="json_pretty">
<pre>[
   {
      "request_id": "53c96a23-2566-4b3d-ae6c-bff634600e79",
      "action": "get_meta_data",
      "entity": "*"
   },
   {
      "request_id": "56e3ca99-5c12-4aca-aa6c-7d0e43c1e636",
      "action": "fetch_all",
      "entity": "blog"
   },
   {
      "request_id": "692968e4-8885-41ad-b918-6ce2791b3bb8",
      "action": "fetch_all",
      "entity": "blog",
      "data": [
         {
            "key": "",
            "value": ""
         }
      ]
   },
   {
      "request_id": "4ffe38a6-d642-44b0-8be1-198e84256321",
      "action": "fetch_all",
      "entity": "blog",
      "relations": [
         "*->*"
      ]
   }
]</pre>
            </div>
            <font style="color:blue"><i>Réponse JSON :</i></font><br/>
            <div class="json_pretty">
<pre>[
   {
      "data": {
         "entities": [
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "author_id",
                  "type": "QString"
               },
               "key": "author",
               "name": "author",
               "properties": [
                  {
                     "description": "",
                     "key": "name",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "birthdate",
                     "type": "QDate"
                  },
                  {
                     "description": "",
                     "key": "sex",
                     "type": "enum author::enum_sex *"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "list_blog",
                     "target": "blog",
                     "type": "std::vector&lt;std::shared_ptr&lt;blog&gt;&gt;",
                     "type_relation": "relation one-to-many"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "blog_id",
                  "type": "long"
               },
               "key": "blog",
               "name": "blog",
               "properties": [
                  {
                     "description": "",
                     "key": "blog_text",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "date_creation",
                     "type": "QDateTime"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "author_id",
                     "target": "author",
                     "type": "std::shared_ptr&lt;author&gt;",
                     "type_relation": "relation many-to-one"
                  },
                  {
                     "description": "",
                     "key": "list_comment",
                     "target": "comment",
                     "type": "QList&lt;std::shared_ptr&lt;comment&gt;&gt;",
                     "type_relation": "relation one-to-many"
                  },
                  {
                     "description": "",
                     "key": "list_category",
                     "target": "category",
                     "type": "qx::QxCollection&lt;long, QSharedPointer&lt;category&gt;&gt;",
                     "type_relation": "relation many-to-many"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "comment_id",
                  "type": "long"
               },
               "key": "comment",
               "name": "comment",
               "properties": [
                  {
                     "description": "",
                     "key": "comment_text",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "date_creation",
                     "type": "QDateTime"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "blog_id",
                     "target": "blog",
                     "type": "std::shared_ptr&lt;blog&gt;",
                     "type_relation": "relation many-to-one"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "category_id",
                  "type": "long"
               },
               "key": "category",
               "name": "category",
               "properties": [
                  {
                     "description": "",
                     "key": "name",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "description",
                     "type": "QString"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "list_blog",
                     "target": "blog",
                     "type": "qx::QxCollection&lt;long, std::shared_ptr&lt;blog&gt;&gt;",
                     "type_relation": "relation many-to-many"
                  }
               ],
               "version": 0
            }
         ]
      },
      "request_id": "53c96a23-2566-4b3d-ae6c-bff634600e79"
   },
   {
      "data": [
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 1,
            "blog_text": "save recursive blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 5,
            "blog_text": "save another blog from QxOrm REST API !",
            "date_creation": "2016-06-12T08:33:12",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 6,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 7,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         }
      ],
      "request_id": "56e3ca99-5c12-4aca-aa6c-7d0e43c1e636"
   },
   {
      "data": [
         {
            "key": 1,
            "value": {
               "author_id": {
                  "author_id": "author_id_1",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 1,
               "blog_text": "save recursive blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 5,
            "value": {
               "author_id": {
                  "author_id": "author_id_1",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 5,
               "blog_text": "save another blog from QxOrm REST API !",
               "date_creation": "2016-06-12T08:33:12",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 6,
            "value": {
               "author_id": {
                  "author_id": "author_id_save_recursive",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 6,
               "blog_text": "save recursive - new blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 7,
            "value": {
               "author_id": {
                  "author_id": "author_id_save_recursive",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 7,
               "blog_text": "save recursive - new blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         }
      ],
      "request_id": "692968e4-8885-41ad-b918-6ce2791b3bb8"
   },
   {
      "data": [
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": "2019-04-02",
               "list_blog": [
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 5,
                     "blog_text": "save another blog from QxOrm REST API !",
                     "date_creation": "2016-06-12T08:33:12",
                     "list_category": [],
                     "list_comment": []
                  },
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 1,
                     "blog_text": "save recursive blog from QxOrm REST API",
                     "date_creation": "2013-11-25T09:56:33",
                     "list_category": [],
                     "list_comment": []
                  }
               ],
               "name": "author_1",
               "sex": 0
            },
            "blog_id": 1,
            "blog_text": "save recursive blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": "2019-04-02",
               "list_blog": [
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 5,
                     "blog_text": "save another blog from QxOrm REST API !",
                     "date_creation": "2016-06-12T08:33:12",
                     "list_category": [],
                     "list_comment": []
                  },
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 1,
                     "blog_text": "save recursive blog from QxOrm REST API",
                     "date_creation": "2013-11-25T09:56:33",
                     "list_category": [],
                     "list_comment": []
                  }
               ],
               "name": "author_1",
               "sex": 0
            },
            "blog_id": 5,
            "blog_text": "save another blog from QxOrm REST API !",
            "date_creation": "2016-06-12T08:33:12",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 6,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 7,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         }
      ],
      "request_id": "4ffe38a6-d642-44b0-8be1-198e84256321"
   }
]</pre>
            </div>
            <br/><br/>
         </div>
      </div>

      </div>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2021 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
