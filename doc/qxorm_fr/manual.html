<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Accueil</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Téléchargement</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Exemple rapide</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutoriel (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manuel (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">Manuel QxOrm</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">Manuel QxEntityEditor</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Nos clients</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Manuel d'utilisation de la bibliothèque QxOrm</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Version courante :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.4.3 - <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.1</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/manual.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/manual.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
      <script>$(function() { initQxOrmManualWebPage(); });</script>
      <table border="0" cellpadding="4">
       <col><col>
       <tbody>
         <tr>
           <td><font class="txt_with_shadow" color="#0B0B61" size="4"><i>Sélection du manuel : </i></font></td>
           <td align="left">
             <a href="./manual.html" class="btn_tuto_selected">Manuel QxOrm</a>
             <a href="./manual_qxee.html" class="btn_tuto">Manuel QxEntityEditor</a>
           </td>
         </tr>
       </tbody>
      </table>
      <hr style="width: 100%" align="center" size="1" color="#100D5A">
      <br>
      <table border="0" style="width: 100%" align="center">
      <col><col>
         <tbody>
            <tr>
               <td>
                  <h3 class="txt_slogan"><b>Manuel d'utilisation de la bibliothèque QxOrm - Table des matières</b></h3>
                  <div id="manual_table_of_contents">
                  <ol class="manual_manual_ol_title_1" type="I">
                     <li class="manual_li_title_1">
                        <a href="#manual_10">Introduction</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_100">Bibliothèque QxOrm</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_110">Aperçu rapide de l'application QxEntityEditor</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_120">Convention d'écriture C++ utilisée par la bibliothèque QxOrm</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_20">Installation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_200">Dépendance à Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_210">Dépendance à boost (seuls les fichiers d'en-tête *.hpp sont nécessaires)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_220">Fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_230">Compiler la bibliothèque QxOrm (avec qmake ou CMake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_240">Pilotes SQL fournis par Qt (drivers)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_30">Persistance - Object Relational Mapping (ORM)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_300">Définir une classe dans le contexte QxOrm (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3000">Clé primaire autre que le type par défaut "long"</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3010">Clé primaire sur plusieurs colonnes (composite key)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3020">Données membres public/protected/private</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3030">Espace de nom (namespace)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3040">Types C++ supportés par QxOrm</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3050">Définir une donnée membre <i>transient</i></a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_310">Connexion à la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_320">Sauvegarder une instance C++ en base de données (insert/update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_340">Supprimer une instance C++ de la base de données (delete)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3400">Suppression logique (soft delete)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_350">Récupérer une instance C++ de la base de données (fetch)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_360">Requêtes SQL</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3610">Appel de procédure stockée ou requête SQL personnalisée</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_370">Transactions (commit, rollback, session)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_380">Moteur de relations</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3800">one-to-many (1-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3810">many-to-one (n-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3820">many-to-many (n-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3830">one-to-one (1-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3840">Requête SQL avec relations</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3850">Sélectionner les colonnes des relations à récupérer</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_390">Collections supportées par QxOrm</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3900">Collections de Qt</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3910">Collections de boost</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3920">Collections fournies par l'espace de nom standard std</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3930">qx::QxCollection</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4000">Pointeurs intelligents de Qt</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4010">Pointeurs intelligents de boost</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4020">Pointeurs intelligents fournis par l'espace de nom standard std</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4030">qx::dao::ptr</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_410">Déclencheurs (triggers)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_420">Validation d'une instance C++ (validators)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_430">Gérer la valeur NULL de la base de données</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4300">boost::optional</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4310">QVariant</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_440">Héritage et polymorphisme</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_450">Interface qx::IxPersistable (classe abstraite)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_460">Persister des types personnalisés</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_470">Générer le schéma DDL SQL de la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_475">Associer un type SQL à une classe C++</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_480">Effectuer des requêtes asynchrones à la base de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_490">Gestion du cache pour sauvegarder des instances C++ (module QxCache)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_500">Travailler avec plusieurs bases de données</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_510">Déclarer une classe abstraite dans le contexte QxOrm</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_520">Déclarer automatiquement les méta-propriétés de Qt (macro <i>Q_PROPERTY</i>)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_60">Sérialisation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_605">N° version pour assurer une compatibilité ascendante</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_600">Moteur QDataStream de Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_606">Moteur JSON de Qt</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_610">Moteur XML de boost::serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_620">Moteur binaire de boost::serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_630">Autres types de sérialisation proposés par boost</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_640">Cloner une instance C++</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_650">Afficher le détail d'une instance C++ (dump au format XML ou JSON)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_70">Introspection - Réflexion</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_710">Obtenir dynamiquement la valeur d'une donnée membre</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_720">Valoriser dynamiquement une donnée membre</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_730">Appeler dynamiquement une fonction</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_740">Créer une instance C++ dynamiquement</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_750">Parcourir la liste des classes/propriétés enregistrées dans le contexte QxOrm</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_80">Services : transférer la couche de données persistante sur le réseau (module QxService)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_810">Paramètres d'entrée/sortie d'un service (requête/réponse)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_820">Définir les fonctions publiées par un service</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_825">Liste des options disponibles côté serveur</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_826">Paramétrage de la connexion côté client</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_830">Gestion de l'authentification dans un service</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_840">Requêtes client/serveur asynchrones</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_90">Moteur modèle/vue (module QxModelView)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_910">Définir un modèle "simple" (sans relation)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_920">Modèles avec relations (notion de modèles imbriqués)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_940">Intéraction avec les vues QML</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_950">Intéraction avec les vues QtWidget</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_960">Connexion d'un modèle au module QxService</a>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  </div>
               </td>
               <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                  <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
               </td>
            </tr>
         </tbody>
      </table>
      <br>
      <hr width="90%">
      <div id="manual_content">

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_10">Introduction</a></p>
      <div class="manual_div_content_1">
         L'objectif de ce manuel utilisateur est de présenter de manière structurée l'ensemble des fonctionnalités proposées par la bibliothèque <b>QxOrm</b>.
         Ce manuel est destiné aux développeurs et architectes logiciel qui souhaitent gérer une couche de données persistante en C++/Qt.
         Des compétences techniques en C++ et base de données sont requises pour la bonne compréhension de ce document.
         <br><br>
         <b>Remarque :</b> la plupart des fonctionnalités présentées dans ce manuel peuvent être définies rapidement et facilement avec l'application <b>QxEntityEditor</b> (l'éditeur graphique de la bibliothèque <b>QxOrm</b>).
         <a href="./manual_qxee.html">Une documentation dédiée à l'application <b>QxEntityEditor</b> est également disponible.</a>
         <br><br>
         <b>Autre remarque :</b> ce manuel est basé en grande partie sur <a href="./faq.html">l'ancienne FAQ du site QxOrm, toujours accessible en cliquant ici</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_100">Bibliothèque QxOrm</a></p>
         <div class="manual_div_content">
           <b>QxOrm est une bibliothèque C++ open source de gestion de données (Object Relational Mapping, ORM).</b><br>
           <b>QxOrm</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
           <br>
           À partir d'une simple <i>fonction de paramétrage</i> (que l'on peut comparer avec un fichier de mapping XML <a href="http://hibernate.org/" target="_blank"><i>Hibernate</i></a>), vous aurez accès aux fonctionnalités suivantes :
           <ul>
             <li><font style="background-color:yellow"><b><a href="./manual.html#manual_30">persistance</a></b></font> : communication avec de nombreuses bases de données (avec support des relations <i>1-1</i>, <i>1-n</i>, <i>n-1</i> et <i>n-n</i>) ;
             </li><li><font style="background-color:yellow"><b><a href="./manual.html#manual_60">sérialisation</a></b></font> des données (flux binaire, XML et JSON) ;
             </li><li>moteur de <font style="background-color:yellow"><b><a href="./manual.html#manual_70">réflexion</a></b></font> (ou <font style="background-color:yellow"><b><a href="./manual.html#manual_70">introspection</a></b></font>) pour accéder dynamiquement aux classes, attributs et invoquer des méthodes.
             </li>
           </ul>
           <b>QxOrm</b> est dépendant des excellentes bibliothèques <a href="http://www.qt.io/" target="_blank"><b>Qt</b></a> (compatible à partir de la version 4.5.0) et <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (compatible à partir de la version 1.38, par défaut seuls les fichiers d'en-tête <i>*.hpp</i> sont nécessaires).<br>
           La bibliothèque <b>QxOrm</b> a été retenue pour faire partie du programme <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank"><b>Qt Ambassador</b></a>.
           <br><br>
           Si vous trouvez un bug ou si vous avez une question concernant le fonctionnement de la bibliothèque <b>QxOrm</b>, 
           vous pouvez envoyer un mail à : <u><i>support@qxorm.com</i></u>.<br>
           Un forum (en anglais) dédié à <b>QxOrm</b> est disponible <a href="http://www.qxorm.com/forum/phpbb/" target="_blank">en cliquant ici</a>.<br>
           Vous pouvez également retrouver la communauté française de <b>QxOrm</b> sur <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/bases-donnees/qxorm/" target="_blank">le forum de Developpez.com</a>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_110">Aperçu rapide de l'application QxEntityEditor</a></p>
         <div class="manual_div_content">
           <b>QxEntityEditor</b> est un éditeur graphique pour la bibliothèque <b>QxOrm</b> : <b>QxEntityEditor</b> permet de gérer graphiquement le modèle d'entités.<br>
           <b>QxEntityEditor</b> est multi-plateforme (disponible pour Windows, Linux et Mac OS X) et génère du code natif pour tous les environnements : bureau (Windows, Linux, Mac OS X), embarqué et mobile (Android, iOS, Windows Phone, Raspberry Pi, etc.).<br>
           <a href="./tutorial_4.html">Une vidéo de présentation de l'application <b>QxEntityEditor</b> est disponible</a>.<br>
           <br>
           <b>QxEntityEditor</b> est basé sur un système de plugins et propose diverses fonctionnalités pour importer/exporter le modèle de données :
           <ul>
             <li>génération automatique du code C++ (classes persistantes enregistrées dans le contexte QxOrm) ;</li>
             <li>génération automatique des scripts SQL DDL (schéma de base de données) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
             <li>supporte l'évolution du schéma de base de données pour chaque version d'un projet (<i>ALTER TABLE</i>, <i>ADD COLUMN</i>, <i>DROP INDEX</i>, etc.) ;</li>
             <li>génération automatique des classes C++ de services pour transférer le modèle de données sur le réseau, en utilisant le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>, pour créer rapidement des applications client/serveur ;</li>
             <li>importation automatique des structures de bases de données existantes (par connexion ODBC) pour les bases SQLite, MySQL, PostgreSQL, Oracle et MS SQL Server ;</li>
             <li>parce que chaque projet est différent, QxEntityEditor propose plusieurs outils pour personnaliser les fichiers générés (notamment un moteur javascript et un débogueur intégré).</li>
           </ul>
           <a href="../qxentityeditor/resource/qxee_sample.png" target="_blank"><img alt="QxEntityEditor" src="../qxentityeditor/resource/qxee_sample_small.png" border="0" class="img_with_shadow"></a>
           <br><br>
           <b>QxEntityEditor</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
           <a href="./manual_qxee.html">Un manuel utilisateur dédié à l'application <b>QxEntityEditor</b> est disponible.</a><br>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_120">Convention d'écriture C++ utilisée par la bibliothèque QxOrm</a></p>
         <div class="manual_div_content">
           La bibliothèque <b>QxOrm</b> utilise les <b>conventions d'écriture de code C++</b> suivantes :
           <ul>
              <li>toutes les classes, fonctions, variables, etc... sont définies dans <a href="./resource/qxorm.namespace.qx.jpg"><i>l'espace de nom (namespace) qx</i></a> ;
              </li><li>les macro de QxOrm sont écrites sous la forme <i>QX_...</i> ;
              </li><li>les classes abstraites (ou interfaces) ont le préfixe <i>Ix</i> (par exemple : <i>IxFactory</i> est une interface pour la création d'instances) ;
              </li><li>les autres classes ont le préfixe <i>Qx</i> (par exemple : <i>QxDataMember</i>) ;
              </li><li>les collections d'objets ont pour suffixe <i>X</i> (par exemple : <i>QxDataMemberX</i> est une collection de <i>QxDataMember</i>) ;
              </li><li>les fonctions pour communiquer avec les bases de données se trouvent sous le <a href="./resource/qxorm.namespace.qx.dao.jpg"><i>namespace qx::dao</i></a> (par exemple : <i>qx::dao::fetch_by_id()</i>) ;
              </li><li>les fonctions pour la <i>serialization</i> des données se trouvent sous le <a href="./resource/qxorm.namespace.qx.serialization.jpg"><i>namespace qx::serialization</i></a> (par exemple : <i>qx::serialization::xml::to_file()</i>) ;
              </li><li>le moteur de <i>reflection</i> (ou <i>introspection</i>) est accessible depuis la classe <b><i>qx::QxClassX</i></b> (par exemple <i>qx::QxClassX::invoke()</i> pour invoquer une méthode de classe) ;
              </li><li>les classes de traits se trouvent sous le <a href="./resource/qxorm.namespace.qx.trait.jpg"><i>namespace qx::trait</i></a> (par exemple : <i>qx::trait::is_smart_ptr&lt;T&gt;</i>).
              </li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_20">Installation</a></p>
      <div class="manual_div_content_1">
         La bibliothèque QxOrm est multi-plateforme et peut être installée sur tous types d'environnement : Windows, Linux (Unix), Mac OS X, Android, iOS, Windows Phone, etc...<br>
         <a href="./tutorial_3.html">Un tutoriel complet (avec captures d'écran) pour installer un environnement de développement avec QxOrm sous Windows est disponible en cliquant ici.</a>
         <br><br>
         L'objectif de ce chapitre est de présenter rapidement les différentes étapes à suivre pour installer QxOrm sur tous types d'environnement :
         <ul>
            <li><a href="#manual_200">Téléchargement et installation du framework Qt ;</a></li>
            <li><a href="#manual_210">Téléchargement et installation de la bibliothèque boost (par défaut, seuls les fichiers d'en-tête <i>*.hpp</i> sont nécessaires) ;</a></li>
            <li><a href="#manual_220">Paramétrage du fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) ;</a></li>
            <li><a href="#manual_230">Compilation de la bibliothèque QxOrm (avec qmake ou CMake) ;</a></li>
            <li><a href="#manual_240">Vérification des pilotes SQL fournis par Qt (drivers).</a></li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_200">Dépendance à Qt</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.qt.io/" target="_blank"><img alt="Qt"
                   src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : bibliothèque complète : IHM
                   (<i>QtGui</i>), réseau (<i>QtNetwork</i>), XML (<i>QtXml</i>), base de données
                   (<i>QtSql</i>), etc.<br>
                   La documentation est excellente et le code C++ écrit à partir
                   de cette bibliothèque est à la fois performant et simple de
                   compréhension.<br>
                   Depuis le rachat par Nokia puis Digia et sa nouvelle licence LGPL, Qt est
                   sans contexte la bibliothèque phare du moment.<br>
                   QxOrm est compatible avec les principaux objets définis par Qt
                   : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash,
                   QSharedPointer, QScopedPointer, etc.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de Qt disponible à l'adresse suivante : <a
                   href="http://www.qt.io/"
                   target="_blank">http://www.qt.io/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Remarque :</b> par défaut, la bibliothèque QxOrm dépend uniquement des modules <a href="http://doc.qt.io/qt-5/qtcore-index.html" target="_blank">QtCore</a> et <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql</a>.
           Il est possible d'activer des fonctionnalités supplémentaires grâce au <a href="#manual_220">fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a> : ces nouvelles fonctionnalités peuvent alors ajouter des dépendances à QxOrm.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_210">Dépendance à boost (seuls les fichiers d'en-tête *.hpp sont nécessaires)</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.boost.org/" target="_blank"><img alt="boost"
                   src="./resource/logo_boost.jpg" width="161"
                 height="50" border="0"></a></td>
              <td align="justify"><b>boost</b> : de nombreux modules de la
                bibliothèque boost font partie de la nouvelle norme C++.<br>
                C'est une bibliothèque reconnue pour sa qualité, son code 'C++
                moderne', sa documentation, sa portabilité, etc...<br>
                QxOrm utilise les fonctionnalités suivantes de boost :
                <i>smart_pointer, type_traits,
                multi_index_container, unordered_container, any, tuple,
                foreach, function.</i> Toutes ces fonctionnalités sont <i>header only</i>, la dépendance au module <i>serialization</i> est optionnelle.<br>
                Il est conseillé d'installer et d'utiliser la dernière version
                de boost disponible à l'adresse suivante : <a href="http://www.boost.org/" target="_blank">http://www.boost.org/</a> </td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Remarque importante :</b> par défaut, la bibliothèque QxOrm dépend uniquement des fichiers d'en-tête <i>*.hpp</i> de boost (utilisation des bibliothèques <i>header only</i> uniquement).
           L'installation de boost est donc très simple puisqu'il suffit de dézipper le package boost (pour disposer des fichiers d'en-tête <i>*.hpp</i>).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_220">Fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a></p>
         <div class="manual_div_content">
            Le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) est divisé en plusieurs sections (chacune étant commentée) et regroupe les différents paramétrages et options de compilation disponibles.
            Il est fortement recommandé de lire attentivement le fichier de configuration <i>QxOrm.pri</i> avant de compiler la bibliothèque QxOrm.
            Il est possible de conserver le paramétrage par défaut, seule la variable <b>QX_BOOST_INCLUDE_PATH</b> est nécessaire pour pouvoir compiler la bibliothèque QxOrm : cette variable indique où trouver les fichiers d'en-tête <i>*.hpp</i> de la bibliothèque boost :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>isEmpty(QX_BOOST_INCLUDE_PATH) { QX_BOOST_INCLUDE_PATH = $$quote(<font style="background-color:yellow">D:/Dvlp/_Libs/Boost/1_57/include</font>) }</i>   </pre>
            </td></tr></tbody></table>
            <br>
            Si vous ne souhaitez pas modifier le fichier de configuration <i>QxOrm.pri</i>, il est possible de définir une variable d'environnement nommée <b>BOOST_INCLUDE</b> : cette variable d'environnement sera alors utilisée automatiquement pour valoriser <b>QX_BOOST_INCLUDE_PATH</b> (lire le fichier <i>QxOrm.pri</i> pour plus d'informations).
            <br><br>
            Voici une liste non exhaustive des différentes options de compilation disponibles (lire le fichier de configuration <i>QxOrm.pri</i> pour plus de détails), aucune n'étant activée par défaut :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION :</b> active <a href="#manual_610">les fonctionnalités de sérialisation avec le module boost::serialization</a>. Cette option nécessite la compilation du binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> et ajoute donc une dépendance à QxOrm ;</li>
               <br>
               <li><b>_QX_CPP_11_SMART_PTR :</b> support des pointeurs intelligents C++11 : <i>std::unique_ptr, std::shared_ptr, std::weak_ptr</i> ;</li>
               <li><b>_QX_CPP_11_CONTAINER :</b> support des collections C++11 : <i>std::unordered_map, std::unordered_set, std::unordered_multimap, std::unordered_multiset</i> ;</li>
               <li><b>_QX_CPP_11_TUPLE :</b> support du type C++11 <i>std::tuple</i> ;</li>
               <br>
               <li><b>_QX_ENABLE_QT_GUI :</b> support de la sérialisation des types du module <a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a> : <i>QBrush, QColor, QFont, QImage, QMatrix, QPicture, QPixmap, QRegion</i>. Cette option ajoute une dépendance à QxOrm (<a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a>) ;</li>
               <li><b>_QX_ENABLE_QT_NETWORK :</b> active <a href="#manual_80">le module QxService</a> pour transférer la couche de données persistante sur le réseau (application client/serveur). Cette option ajoute une dépendance à QxOrm (<a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a>) ;</li>
               <li><b>_QX_NO_PRECOMPILED_HEADER :</b> désactive l'utilisation d'un en-tête précompilé (permet de réduire les temps de compilation d'un projet) : cette option est nécessaire pour <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56926" target="_blank">contourner un bug des versions récentes de MinGW</a>, pour tous les autres compilateurs il est recommandé de travailler avec un <i>precompiled header</i> ;</li>
               <li><b>_QX_NO_RTTI :</b> permet de compiler QxOrm et les projets dépendants sans <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">les informations de type C++ RTTI</a> ;</li>
               <li><b>_QX_STATIC_BUILD :</b> permet de compiler la bibliothèque QxOrm en mode statique ;</li>
               <li><b>_QX_UNITY_BUILD :</b> réduit les temps de compilation de la bibliothèque QxOrm en utilisant le concept <i>unity build</i> : un seul fichier source <i>all.cpp</i> à compiler. Il est recommandé d'activer cette option avec <a href="https://cmake.org/" target="_blank">CMake</a> (car ne supporte pas nativement les en-têtes précompilés).</li>
            </ul>
            <br>
            <b>Remarque :</b> le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) devra être inclus dans tous les projets dépendants de la bibliothèque QxOrm en ajoutant la ligne suivante dans le fichier <i>*.pro</i> du projet :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   include(<i>my_path_to_QxOrm_library</i>/QxOrm.pri)   </pre>
            </td></tr></tbody></table>
            <br>
            <b>Autre remarque :</b> à la place de <i>qmake</i>, il est possible d'utiliser <a href="https://cmake.org/" target="_blank">l'outil de compilation CMake</a> pour configurer et construire la bibliothèque QxOrm.
            CMake propose un outil graphique afin de visualiser et paramétrer les différentes options disponibles :
            <br><br>
            <img alt="QxOrm and CMake" src="./resource/qxorm_cmake.png" />
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_230">Compiler la bibliothèque QxOrm (avec qmake ou CMake)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> utilise le processus <i>qmake</i> de la bibliothèque <b>Qt</b> pour générer les <i>makefile</i> et compiler le projet (il est également possible d'utiliser <a href="https://cmake.org/" target="_blank">l'outil de compilation CMake</a>, un fichier <i>CMakeLists.txt</i> étant fourni avec la bibliothèque QxOrm).<br>
           <i>qmake</i> est multi-plateforme et fonctionne parfaitement sous Windows, Linux (Unix) et Mac OS X.<br>
           Pour compiler <b>QxOrm</b>, il suffit d'exécuter les commandes suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>qmake</i>
   <i>make debug</i>
   <i>make release</i>   </pre>
           </td></tr></tbody></table>
           <br>
           Sous <b>Windows</b>, des fichiers <i>*.vcproj</i> et <i>*.sln</i> sont disponibles pour les éditeurs <b>Visual C++ 2008</b>, <b>Visual C++ 2010</b> et <b>Visual C++ 2012</b>.<br>
           Les fichiers <i>*.pro</i> sont lisibles par l'éditeur <b>Qt Creator</b>, et des plugins existent permettant de s'interfacer avec de nombreux éditeurs C++.<br>
           Les fichiers <i>mingw_build_all_debug.bat</i> et <i>mingw_build_all_release.bat</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec le compilateur <b>MinGW</b> sous Windows.<br>
           Les fichiers <i>gcc_build_all_debug.sh</i> et <i>gcc_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec <b>GCC</b> sous <b>Linux</b>.<br>
           Enfin, les fichiers <i>osx_build_all_debug.sh</i> et <i>osx_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests sous <b>Mac OS X</b> (merci à Dominique Billet pour l'écriture des scripts).<br>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_240">Pilotes SQL fournis par Qt (drivers)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> utilise le moteur <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> de <b>Qt</b> basé sur un système de plugin.<br>
           <a href="http://doc.qt.io/qt-5/sql-driver.html" target="_blank">Une liste détaillée des bases de données supportées est disponible sur le site de Qt</a>.<br>
           Le plugin <i>ODBC</i> (<i>QODBC</i>) assure une compatibilité avec de nombreuses bases de données.<br>
           Pour des performances optimales, il est conseillé d'utiliser un plugin spécifique à une base de données :
           <ul>
              <li><i>QMYSQL</i> : MySQL ;</li>
              <li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;</li>
              <li><i>QOCI</i> : Oracle Call Interface Driver ;</li>
              <li><i>QSQLITE</i> : SQLite version 3 ;</li>
              <li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;</li>
              <li><i>QIBASE</i> : Borland InterBase ;</li>
              <li><i>QTDS</i> : Sybase Adaptive Server.</li>
           </ul>
           <b>Remarque :</b> pour se connecter à une base de données <i>Microsoft SQL Server</i>, il est nécessaire d'utiliser le pilote <i>ODBC</i> (plugin <i>QODBC</i>).
           <br><br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_30">Persistance - Object Relational Mapping (ORM)</a></p>
      <div class="manual_div_content_1">
         La bibliothèque QxOrm fournit un moteur de persistance des données basé sur le module <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> de Qt.
         Ce moteur de persistance utilise la technique de programmation : <b>Object Relational Mapping (ORM)</b>.
         <br><br>
         <a href="https://fr.wikipedia.org/wiki/Mapping_objet-relationnel" target="_blank">Définition du site Wikipedia :</a> un mapping objet-relationnel (en anglais <i>object-relational mapping</i> ou <i>ORM</i>) est une technique de programmation informatique qui crée l'illusion d'une base de données orientée objet à partir d'une base de données relationnelle en définissant des correspondances entre cette base de données et les objets du langage utilisé. On pourrait le désigner par « correspondance entre monde objet et monde relationnel ».
         Le mapping objet-relationnel consiste à associer une ou plusieurs classes avec une table, et chaque attribut de la classe avec un champ de la table.
         Les frameworks de mapping objet-relationnel permettent d'éliminer la duplication de code dans les opérations <i>CRUD</i>.
         <br><br>
         Pour effectuer cette correspondance entre le monde objet et le monde relationnel, ainsi pour que proposer l'ensemble de ses fonctionnalités, la bibliothèque QxOrm impose l'enregistrement de classes C++ dans le contexte QxOrm.
         Nous allons donc débuter ce chapitre de la façon suivante : <b>comment enregistrer une classe C++ dans le contexte QxOrm ?</b>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_300">Définir une classe dans le contexte QxOrm (mapping)</a></p>
         <div class="manual_div_content">
            Toutes les classes C++ peuvent être enregistrées dans le contexte QxOrm : il n'y a pas besoin de dériver d'un super objet, et vous pouvez écrire vos méthodes de classes et accesseurs sans aucune contrainte.
            Enregistrer une classe C++ dans le contexte QxOrm signifie :
            <ul>
               <li>dans le fichier en-tête <i>*.h</i> contenant la définition de la classe : utilisation de la macro <b>QX_REGISTER_HPP(class_name, base_class, class_version)</b> ;</li>
               <li>dans le fichier source <i>*.cpp</i> contenant l'implémentation de la classe : utilisation de la macro <b>QX_REGISTER_CPP(class_name)</b> ;</li>
               <li>dans le fichier source <i>*.cpp</i> contenant l'implémentation de la classe : spécialisation de la fonction template : <b>void qx::register_class&lt;T&gt;(qx::QxClass&lt;T&gt; & t)</b>.</li>
            </ul>
            Par exemple, voici comment déclarer une classe <i>person</i> avec 4 propriétés enregistrées dans le contexte QxOrm : <i>id</i>, <i>firstName</i>, <i>lastName</i>, <i>birthDate</i> :<br>
            <br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span></font><span class="comment">

/* This macro is necessary to register 'person' class in QxOrm context */
/* param 1 : the current class to register =&gt; 'person' */
/* param 2 : the base class, if no base class, use the qx trait =&gt; 'qx::trait::no_base_class_defined' */
/* param 3 : the class version used by serialization engine to provide 'ascendant compatibility' */</span><span class="pre">

#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="pre">#include <span class="string">"precompiled.h"</span>   <span class="comment">// Precompiled-header with '#include &lt;QxOrm.h&gt;' and '#include "export.h"'</span>
#include <span class="string">"person.h"</span>          <span class="comment">// Class definition 'person'</span>
#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>     <span class="comment">// Automatic memory leak detection and boost serialization export macro</span>
</span>
<font style="background-color:yellow">QX_REGISTER_CPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">)</span></font><span class="comment">   // This macro is necessary to register 'person' class in QxOrm context
</span><span class="keyword">
namespace</span> qx<span class="operator"> {</span><font style="background-color:yellow"><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
  t<span class="operator">.</span>setName<span class="operator">(</span><span class="string">"t_person"</span><span class="operator">)</span>;<span class="comment">               // 'person' C++ class is mapped to 't_person' database table</span>

  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span><span class="comment">               // Register 'person::id' &lt;=&gt; primary key in your database
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span><span class="comment">      // Register 'person::firstName' property mapped to 'first_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span><span class="comment">  // Register 'person::lastName' property mapped to 'last_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span><span class="comment">  // Register 'person::birthDate' property mapped to 'birth_date' database column name
</span><span class="operator">}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> les méthodes <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::id()</a> et <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> retournent une instance de type : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> (classe de base pour l'enregistrement des données membre).
            Grâce à cette instance, il est possible de personnaliser le comportement par défaut proposé par la classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a>, comme par exemple dans le chapitre : <a href="#manual_3050">Définir une donnée membre <i>transient</i></a>.
            <br><br>
            <b>Autre remarque :</b> il est également possible d'enregistrer des méthodes de classe dans le contexte QxOrm (gestion des méthodes <i>static</i> et <i>non static</i>) avec les méthodes <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a>, <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a>, etc...
            Cette fonctionnalité fait partie du <a href="#manual_70">moteur d'introspection</a> de la bibliothèque QxOrm, plus de détails dans le chapitre : <a href="#manual_730">Appeler dynamiquement une fonction</a>.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3000">Clé primaire autre que le type par défaut "long"</a></p>
            <div class="manual_div_content">
               Par défaut, lorsqu'un mapping d'une classe C++ est écrit avec la méthode <i>void qx::register_class&lt;T&gt;</i>, l'identifiant associé à la classe est de type <i>long</i> (clé primaire avec auto-incrémentation dans la base de données).<br>
               <br>
               Il est possible de définir un identifiant d'un autre type en utilisant la macro <b>QX_REGISTER_PRIMARY_KEY</b>.<br>
               Cette macro spécialise le template <i>qx::trait::get_primary_key&lt;T&gt;</i> pour associer un type d'identifiant à une classe C++.<br>
               <br>
               Par exemple, pour définir un identifiant unique de type <i>QString</i> pour la classe C++ <i>myClass</i> (mappée vers une table de la BDD avec une colonne de type <i>VARCHAR</i> pour clé primaire), il suffit d'écrire :
               <i><b>QX_REGISTER_PRIMARY_KEY(myClass, QString)</b></i><br>
               <br>
               Voici un exemple d'utilisation de la macro <b>QX_REGISTER_PRIMARY_KEY</b> avec une classe <i>author</i> possédant un identifiant de type <i>QString</i> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword"> 
class</span> author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- propriétés
</span>   QString  m_id<span class="operator">;</span>
   QString  m_name<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_</span></pre>
               </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3010">Clé primaire sur plusieurs colonnes (composite key)</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> supporte la notion de '<i>multi-columns primary key</i>'.<br>
              L'identifiant de la classe doit être du type suivant :
              <ul>
              <li><i>QPair</i> ou <i>std::pair</i> pour définir deux colonnes ;
              </li><li><i>boost::tuple</i> (ou <i>std::tuple</i>) pour définir de deux à neuf colonnes.
              </li></ul>
              Il est nécessaire d'utiliser la macro <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> pour spécialiser le template et ainsi définir le type d'identifiant sur plusieurs colonnes.<br>
              La liste des noms des colonnes doit être de la forme suivante : '<i>column1|column2|column3|etc.</i>'.<br>
              <br>
              <b>Exemple d'utilisation</b> avec la classe '<i>author</i>' du projet '<i>qxBlogCompositeKey</i>', cette classe possède un identifiant sur trois colonnes :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- clé composée (clé primaire définie sur plusieurs colonnes dans la base de données)
</span>   <font style="background-color:yellow"><span class="keyword">typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="keyword">static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span></font><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- propriétés
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- méthodes d'accès à la clé composée
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- méthodes de modification de la clé composée
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
              </td></tr></tbody></table>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span></font>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3020">Données membres public/protected/private</a></p>
            <div class="manual_div_content">
              Pour enregistrer des membres <i>private</i> ou <i>protected</i> dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>), il faut déclarer les <i>friend class</i> nécessaires.<br>
              Pour simplifier l'écriture avec les <i>template</i> C++, la bibliothèque QxOrm fournit la macro suivante : <b>QX_REGISTER_FRIEND_CLASS(myClass)</b>.<br>
              Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll1/</i> du package QxOrm avec la classe <i>CPerson</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> test<span class="operator"> {</span><span class="keyword">

class</span> QX_DLL1_EXPORT CPerson<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>qx<span class="operator">::</span>test<span class="operator">::</span>CPerson<span class="operator">)</span></font><span class="comment">

   // etc...
</span><span class="operator">
};

}</span><span class="comment"> // namespace test
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3030">Espace de nom (namespace)</a></p>
            <div class="manual_div_content">
              Si une classe est définie dans un espace de nom (<i>namespace</i>), alors une erreur de compilation se produit avec l'utilisation des macros : <b>QX_REGISTER_HPP</b> et <b>QX_REGISTER_CPP</b>.
              Pour éviter ces erreurs de compilation, il est nécessaire d'utiliser les macros suivantes : <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> et <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b>.<br>
              <br>
              Vous trouverez un exemple d'utilisation dans le dossier <i>./test/qxDllSample/dll1/</i> de la distribution de QxOrm avec la classe <i>CPerson</i> définie dans l'espace de nom <i>qx::test</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)   </pre>
              </td></tr></tbody></table>
              <br>
              Les macros <b>QX_REGISTER_COMPLEX_CLASS_NAME...</b> nécessitent un paramètre supplémentaire (dans l'exemple ci-dessus il s'agit du paramètre <i>qx_test_CPerson</i>) afin de créer une variable globale.<br>
              Celle-ci est appelée dès le lancement de l'application.<br>
              La construction de cette instance globale déclare la classe dans <a href="#manual_740">le module <i>QxFactory</i> (modèle de conception fabrique ou design pattern factory)</a>.<br>
              Un objet C++ ne pouvant pas se nommer avec des caractères "<i>::</i>", le paramètre supplémentaire de la macro permet de remplacer tous les "<i>::</i>" par des "<i>_</i>".
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3040">Types C++ supportés par QxOrm</a></p>
            <div class="manual_div_content">
               La bibliothèque QxOrm supporte la plupart des types primitifs du standard C++ et du framework Qt (numériques, booléens, chaines de caractères, date/heure, collections, pointeurs et pointeurs intelligents, etc...).
               Voici un exemple présentant une liste (non exhaustive) de types C++ supportés ainsi que l'association par défaut du type de base de données (format <i>SQLite</i>) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Remarque :</b> il est également possible de persister un type non géré par défaut par la bibliothèque QxOrm. Rendez-vous au chapitre <a href="#manual_460"><b><i>Persister des types personnalisés</i></b></a> pour plus de détails sur cette fonctionnalité.
               <br><br>
               <b>Autre remarque :</b> concernant l'association d'un type C++ avec le type de base de données associé, rendez-vous au chapitre <a href="#manual_475"><b><i>Associer un type SQL à une classe C++</i></b></a> pour plus de détails.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3050">Définir une donnée membre <i>transient</i></a></p>
            <div class="manual_div_content">
               Une donnée membre <i>transient</i> n'est pas associée à une colonne d'une table de la base de données.
               Le <a href="../doxygen/html/group___qx_dao.html" target="_blank">module QxDao</a> ignore donc cette propriété pour toutes les requêtes à la base de données.
               <br><br>
               A quoi sert l'enregistrement d'une donnée membre <i>transient</i> dans le contexte QxOrm ?<br>
               Enregistrer une donnée membre <i>transient</i> dans le contexte QxOrm permet de disposer des autres fonctionnalités de la bibliothèque QxOrm sur cette propriété, comme par exemple : <a href="./manual.html#manual_60">sérialisation</a>, <a href="./manual.html#manual_70">introspection</a>, etc...
               <br><br>
               La méthode <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> dispose d'un paramètre optionnel nommé : <i>bool bDao</i> (par défaut, valeur à <i>true</i>).
               Par exemple, ajoutons une propriété <i>transient</i> nommée <i>age</i> à la classe <i>person</i> (cette propriété n'a pas besoin d'être stockée en base de données puisque nous disposons déjà de la propriété <i>birthDate</i>) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> <font style="background-color:yellow">false</font></span><span class="operator">);
}}</span></pre>
               </td></tr></tbody></table>
               <br>
               Voici une autre façon de définir une propriété <i>transient</i> en récupérant l'instance de type <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setDao<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_310">Connexion à la base de données</a></p>
         <div class="manual_div_content">
            La connexion à la base de données peut être paramétrée avec la classe singleton : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>.<br>
            Voici un exemple de paramétrage à une base de données SQLite nommée <i>test_qxorm.db</i> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlDatabase">
<pre>   <span class="comment">// Init parameters to connect to database</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDriverName<span class="operator">(</span><span class="string">"QSQLITE"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDatabaseName<span class="operator">(</span><span class="string">"./test_qxorm.db"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setHostName<span class="operator">(</span><span class="string">"localhost"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setUserName<span class="operator">(</span><span class="string">"root"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setPassword<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
</pre>
            </td></tr></tbody></table>
            <br>
            Une fois les paramètres de connexion renseignés dans la classe singleton <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>, toutes les opérations avec la base de données effectuées par la bibliothèque QxOrm utiliserons ces paramètres.
            Pour plus d'informations sur les paramètres de connexion à renseigner, il est recommandé de lire <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">la documentation de la classe QSqlDatabase du framework Qt</a>.
            <br><br>
            <b>Remarque :</b> la classe <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> gère automatiquement les appels à la base de données dans différents threads (<i>multi-threading</i>).
            <br><br>
            <b>Autre remarque :</b> il est possible de gérer son propre pool de connexions à la base de données, et de travailler également avec plusieurs bases de données distinctes : rendez-vous dans le chapitre <a href="#manual_500"><b><i>Travailler avec plusieurs bases de données</i></b></a> pour plus d'informations sur cette fonctionnalité.
            <br><br>
            <b>Autre remarque :</b> suivant le pilote SQL renseigné dans les paramètres de connexion, la bibliothèque QxOrm associe automatiquement un générateur SQL.
            Ce générateur SQL permet de gérer les spécificités propres à chaque type de base de données.
            Tous les générateurs SQL héritent de la classe de base : <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a> :
            <ul>
               <li>pilote <i>QMYSQL</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_MySQL</a> ;</li>
               <li>pilote <i>QPSQL</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_PostgreSQL</a> ;</li>
               <li>pilote <i>QSQLITE</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html" target="_blank">qx::dao::detail::QxSqlGenerator_SQLite</a> ;</li>
               <li>pilote <i>QOCI</i> : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html" target="_blank">qx::dao::detail::QxSqlGenerator_Oracle</a> ;</li>
               <li>pour tous les autres pilotes : générateur SQL <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html" target="_blank">qx::dao::detail::QxSqlGenerator_Standard</a> (il est possible de créer son propre générateur SQL en écrivant une classe héritant de <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a>) ;</li>
               <li>pour se connecter à une base de données <i>Microsoft SQL Server</i>, on utilise le pilote <i>QODBC</i> : il est alors nécessaire de préciser le générateur SQL à utiliser en appelant la fonction : </li>
            </ul>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="SQL generator">
<pre>   qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxSqlGenerator_ptr pSqlGenerator<span class="operator">;</span>
   pSqlGenerator<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxSqlGenerator_MSSQLServer<span class="operator">());</span>   
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setSqlGenerator<span class="operator">(</span>pSqlGenerator<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_320">Sauvegarder une instance C++ en base de données (insert/update)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour sauvegarder une instance C++ (ou une liste d'instances C++) en base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert</i></a> : insère une instance (ou une liste d'instances) en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_relation</i></a> : insère une instance (ou une liste d'instances) + ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_all_relation</i></a> : insère une instance (ou une liste d'instances) + toutes ses relations en base de données ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update</i></a> : met à jour une instance (ou une liste d'instances) en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_relation</i></a> : met à jour une instance (ou une liste d'instances) + ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_all_relation</i></a> : met à jour une instance (ou une liste d'instances) + toutes ses relations en base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query</i></a> : met à jour une instance (ou une liste d'instances) en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_relation</i></a> : met à jour une instance (ou une liste d'instances) + ses relations en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_all_relation</i></a> : met à jour une instance (ou une liste d'instances) + toutes ses relations en base de données en filtrant avec une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized</i></a> : met à jour uniquement les champs modifiés d'une instance (ou d'une liste d'instances) en base de données en utilisant le pattern <i>is dirty</i> et les fonctionnalités de la classe <a href="#manual_4030">qx::dao::ptr</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized_by_query</i></a> : met à jour uniquement les champs modifiés d'une instance (ou d'une liste d'instances) en base de données en utilisant le pattern <i>is dirty</i> et les fonctionnalités de la classe <a href="#manual_4030">qx::dao::ptr</a> et en filtrant avec une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + ses relations ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_all_relation</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + toutes ses relations ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation_recursive</i></a> : insère (si l'élément n'existe pas en base de données) ou met à jour (si l'élément existe déjà en base de données) + toutes les relations sur tous les niveaux : utile pour sauvegarder en 1 commande une structure en arbre par exemple.</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="insert/update">
<pre>   <span class="comment">// Create 3 drugs instances
   // It is possible to use 'boost' and 'Qt' smart pointer : 'boost::shared_ptr', 'QSharedPointer', etc...
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span>
   drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
   drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
   drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span>

   <span class="comment">// Insert some drugs into a container
   // It is possible to use many containers from 'std', 'boost', 'Qt' and 'qx::QxCollection&lt;Key, Value&gt;'
</span><span class="keyword">   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>drug_ptr<span class="operator">&gt;</span> type_lst_drug<span class="operator">;</span>
   type_lst_drug lst_drug<span class="operator">;</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d1<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d2<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d3<span class="operator">);</span><span class="comment">

   // Insert drugs from container to database
   // 'id' property of 'd1', 'd2' and 'd3' are auto-updated
</span>   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>lst_drug<span class="operator">);</span></font><span class="comment">

   // Modify and update the second drug into database
</span>   d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2 modified"</span><span class="operator">;</span>
   d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2 modified"</span><span class="operator">;</span>
   daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>d2<span class="operator">);</span></font>
</pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> toutes les fonctions de <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a> sont flexibles au niveau des paramètres, elles peuvent accepter : une instance, une liste d'instances, un pointeur, un pointeur intelligent, une liste de pointeurs, une liste de pointeurs intelligents, etc... Par exemple :
            <ul>
               <li><i>my_entity t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>my_entity * t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>std::shared_ptr&lt;my_entity&gt; t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>QList&lt;my_entity&gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
               <li><i>QList&lt;std::shared_ptr&lt;my_entity&gt; &gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
            </ul>
            Pour connaitre la liste des collections supportées, rendez-vous dans le chapitre : <a href="#manual_390">Collections supportées par QxOrm</a>.<br>
            Pour connaitre la liste des pointeurs intelligents supportés, rendez-vous dans le chapitre : <a href="#manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a>.<br>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_340">Supprimer une instance C++ de la base de données (delete)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour supprimer une instance C++ (ou une liste d'instances C++) en base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_id</i></a> : supprime de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_all</i></a> : supprime toutes les entrées d'une table de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_query</i></a> : supprime les entrées d'une table de la base de données en fonction d'une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_id</i></a> : supprime de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_all</i></a> : supprime toutes les entrées d'une table de la base de données avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_query</i></a> : supprime les entrées d'une table de la base de données en fonction d'une requête SQL avec prise en compte de <a href="#manual_3400">la fonctionnalité de suppression logique</a> ;</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="delete">
<pre>   <span class="comment">// Create a drug instance with id '18'
   </span>drug d<span class="operator">;</span> d<span class="operator">.</span>setId<span class="operator">(</span><span class="int">18</span><span class="operator">);</span><span class="comment">

   // Delete the drug with id '18' from database
   </span>QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>d<span class="operator">);</span></font><span class="comment">

   // Delete all drugs from database
   </span>daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>drug<span class="operator">&gt;();</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3400">Suppression logique (soft delete)</a></p>
            <div class="manual_div_content">
              Une suppression logique permet de ne pas effacer de ligne dans une table d'une base de données (contrairement à une suppression physique) : une colonne supplémentaire est ajoutée à la définition de la table pour indiquer que la ligne est supprimée ou non.<br>
              Cette colonne peut contenir soit un booléen (1 signifie ligne supprimée, 0 ou vide signifie ligne non supprimée), soit la date-heure de suppression de la ligne (si vide, la ligne est considérée comme non supprimée).<br>
              Il est donc à tout moment possible de réactiver une ligne supprimée en réinitialisant la valeur à vide dans la table de la base de données.<br>
              <br>
              Pour activer le mécanisme de suppression logique avec la bibliothèque QxOrm, il faut utiliser la classe <a href="../doxygen/html/classqx_1_1_qx_soft_delete.html" target="_blank"><b>qx::QxSoftDelete</b></a> dans la fonction de mapping <i>qx::register_class&lt;T&gt;</i>.<br>
              Voici un exemple d'utilisation avec une classe <i>Bar</i> contenant deux propriétés <i>m_id</i> et <i>m_desc</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span></font>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
              </td></tr></tbody></table>
              <br>
              Les requêtes SQL générées automatiquement par la bibliothèque QxOrm vont prendre en compte ce paramètre de suppression logique pour ajouter les conditions nécessaires (ne pas récupérer les éléments supprimés, ne pas supprimer physiquement une ligne, etc.).<br>
              Par exemple, si vous exécutez les lignes suivantes avec la classe <i>Bar</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
              </td></tr></tbody></table>
              <br>
              Vous obtiendrez les traces suivantes :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id 
                                         AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
              </td></tr></tbody></table>
              <br>
              <b>Remarque :</b> pour supprimer physiquement une ligne de la base de données, il faut utiliser les fonctions : <i>qx::dao::destroy_by_id()</i> et <i>qx::dao::destroy_all()</i>.<br>
              <br>
              <b>Autre remarque :</b> il peut être intéressant de définir au niveau du SGBD un index sur la colonne <i>deleted_at</i> (ou peu importe le nom que vous donnez) afin d'accélérer l'exécution des requêtes SQL.<br>
              <br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_350">Récupérer une instance C++ de la base de données (fetch)</a></p>
         <div class="manual_div_content">
            Toutes les fonctions liées à la base de données sont disponibles dans <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.<br>
            <br>
            Pour valoriser automatiquement les propriétés d'une instance C++ (ou d'une liste d'instances C++) en fonction des données d'une table (ou plusieurs tables si des relations sont définies) de la base de données, la bibliothèque QxOrm fournit les fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) associé à l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_relation</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) + ses relations en fonction de l'id passé en paramètre ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_all_relation</i></a> : récupère de la base de données l'élément (ou une liste d'éléments) + toutes ses relations en fonction de l'id passé en paramètre ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all</i></a> : récupère toutes les entrées d'une table de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_relation</i></a> : récupère toutes les entrées d'une table + ses relations de la base de données ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_all_relation</i></a> : récupère toutes les entrées d'une table + toutes ses relations de la base de données ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query</i></a> : récupère toutes les entrées d'une table de la base de données en fonction d'une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_relation</i></a> : récupère toutes les entrées d'une table de la base de données + ses relations en fonction d'une requête SQL ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_all_relation</i></a> : récupère toutes les entrées d'une table de la base de données + toutes ses relations en fonction d'une requête SQL ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::exist</i></a> : teste l'existence d'un élément (ou d'une liste d'éléments) en base de données en fonction de son identifiant (<i>primary key</i>).</li>
            </ul>
            <br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="fetch">
<pre><span class="comment">   // Fetch drug with id '3' into a new variable
</span>   drug_ptr d<span class="operator">;</span> d<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_360">Requêtes SQL</a></p>
         <div class="manual_div_content">
            La bibliothèque QxOrm fournit plusieurs outils pour effectuer des requêtes à la base de données :
            <ul>
               <li>la classe <a href="#manual_3600">qx::QxSqlQuery (ou son alias qx_query)</a> ;</li>
               <li>la fonction <a href="#manual_3610">qx::dao::execute_query<T>()</a> ;</li>
               <li>la fonction <a href="#manual_3610">qx::dao::call_query()</a>.</li>
            </ul>
            <b>Remarque :</b> QxOrm étant basé sur le module <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> de Qt, il est toujours possible de requêter la base de données en utilisant la classe <a href="http://doc.qt.io/qt-5/qsqlquery.html" target="_blank">QSqlQuery</a> de Qt si les fonctionnalités proposées par QxOrm ne sont pas suffisantes.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a></p>
            <div class="manual_div_content">
              La classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou bien son alias <i>qx_query</i>) permet d'interroger la base de données (trier, filtrer, etc.) de deux manières différentes :
              <ul>
                <li>en écrivant directement la requête SQL ;</li>
                <li>en utilisant des méthodes C++ avec une syntaxe proche du SQL (similaire à ce que propose <a href="http://subsonicproject.com/docs/Simple_Query_Tool" target="_blank">l'excellente bibliothèque SubSonic pour .Net</a>).</li>
              </ul>
              Le principal avantage de la première méthode (écriture manuelle des requêtes SQL) est de pouvoir utiliser certaines optimisations spécifiques à chaque base de données.<br>
              La deuxième méthode (utilisation du code C++ pour générer la requête SQL) permet de mapper automatiquement les paramètres SQL sans utiliser la fonction <i>qx::QxSqlQuery::bind()</i>.<br>
              <br>
              Voici un exemple d'utilisation de la classe <i>qx::QxSqlQuery</i> avec écriture manuelle d'une requête SQL :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx<span class="operator">::</span>QxSqlQuery query<span class="operator">(</span><span class="string">"WHERE author.sex = :sex"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":sex"</span><span class="operator">,</span> author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              La bibliothèque QxOrm supporte trois syntaxes pour l'écriture des paramètres SQL.<br>
              Le type de syntaxe peut être modifié de façon globale à un projet en utilisant la méthode suivante : <i>qx::QxSqlDatabase::getSingleton()->setSqlPlaceHolderStyle()</i>.<br>
              Les trois paramètres possibles pour cette méthode sont :
              <ul>
                <li><i>ph_style_2_point_name</i> : "WHERE author.sex = :sex" (syntaxe par défaut) ;</li>
                <li><i>ph_style_at_name</i> : "WHERE author.sex = @sex" ;</li>
                <li><i>ph_style_question_mark</i> : "WHERE author.sex = ?".</li>
              </ul>
              Voici le même exemple en utilisant les méthodes C++ de la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) pour générer la requête automatiquement :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Construit une requête pour récupérer uniquement les 'author' de type 'female'
</span>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"author.sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* traitement avec la collection issue de la base de données */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              Cette utilisation de la classe <i>qx::QxSqlQuery</i> présente l'avantage de ne pas avoir à mapper les paramètres de la requête, tout en restant très proche de l'écriture manuelle d'une requête SQL.<br>
              Les paramètres seront automatiquement injectés en utilisant la syntaxe définie de manière globale par la méthode : <i>qx::QxSqlDatabase::getSingleton()->getSqlPlaceHolderStyle()</i>.<br>
              <br>
              Voici un exemple présentant différentes méthodes disponibles avec la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"age"</span><span class="operator">).</span>isGreaterThan<span class="operator">(</span><span class="int">38</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">).</span>isNotEqualTo<span class="operator">(</span><span class="string">"Dupont"</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"first_name"</span><span class="operator">).</span>like<span class="operator">(</span><span class="string">"Alfred"</span><span class="operator">)
     .</span>and_OpenParenthesis<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>isLessThanOrEqualTo<span class="operator">(</span><span class="int">999</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"birth_date"</span><span class="operator">).</span>isBetween<span class="operator">(</span>date1<span class="operator">,</span> date2<span class="operator">)
     .</span>closeParenthesis<span class="operator">()
     .</span>or_<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>in<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 999</span><span class="operator">,</span><span class="int"> 11</span><span class="operator">,</span><span class="int"> 23</span><span class="operator">,</span><span class="int"> 78945</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"is_deleted"</span><span class="operator">).</span>isNotNull<span class="operator">()
     .</span>orderAsc<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="string"> "sex"</span><span class="operator">)
     .</span>limit<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 150</span><span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui produira le code SQL suivant pour les bases de données <i>MySQL</i>, <i>PostgreSQL</i> et <i>SQLite</i> (pour <i>Oracle</i> et <i>SQLServer</i>, le traitement de la méthode <i>limit()</i> est différent) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>WHERE sex<span class="operator"> = :</span>sex_1_0 
AND age<span class="operator"> &gt; :</span>age_3_0 
OR last_name<span class="operator"> &lt;&gt; :</span>last_name_5_0 
OR first_name LIKE<span class="operator"> :</span>first_name_7_0 
AND<span class="operator"> (</span> id<span class="operator"> &lt;= :</span>id_10_0 AND birth_date BETWEEN<span class="operator"> :</span>birth_date_12_0_1 AND<span class="operator"> :</span>birth_date_12_0_2<span class="operator"> )</span> 
OR id IN<span class="operator"> (:</span>id_15_0_0<span class="operator">, :</span>id_15_0_1<span class="operator">, :</span>id_15_0_2<span class="operator">, :</span>id_15_0_3<span class="operator">, :</span>id_15_0_4<span class="operator">)</span> 
AND is_deleted IS NOT NULL 
ORDER BY last_name ASC<span class="operator">,</span> first_name ASC<span class="operator">,</span> sex ASC 
LIMIT<span class="operator"> :</span>limit_rows_count_19_0 OFFSET<span class="operator"> :</span>offset_start_row_19_0</pre>
              </td></tr></tbody></table>
              <br>
              Voici la liste des fonctions et méthodes disponibles pour utiliser la classe <i>qx::QxSqlQuery</i> (ou bien son alias <i>qx_query</i>) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// avec les fonctions du namespace qx::dao
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxSession
</span>qx<span class="operator">::</span>QxSession<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>fetchByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>update<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>deleteByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>destroyByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// avec la classe qx::QxRepository&lt;T&gt;
</span>qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>count<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fetchByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>update<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>deleteByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>destroyByQuery<span class="operator">()</span></pre>
              </td></tr></tbody></table>
              <br>
              <b>Remarque :</b> certaines de ces fonctions ont également deux autres paramètres optionnels :
              <ul>
                <li><i>const QStringList & columns</i> : pour indiquer la liste des colonnes à récupérer (par défaut, toutes les colonnes sont récupérées) ;</li>
                <li><i>const QStringList & relation</i> : pour indiquer les jointures (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i> définies dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>) entre les tables de la base de données (par défaut, aucune relation).</li>
              </ul>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3610">Appel de procédure stockée ou requête SQL personnalisée</a></p>
            <div class="manual_div_content">
              La bibliothèque QxOrm fournit deux fonctions pour appeler une procédure stockée ou une requête SQL personnalisée :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a></li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a></li>
              </ul>
              Le premier paramètre de ces deux fonctions, de type <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou son alias <i>qx_query</i>), correspond à la procédure stockée ou à la requête SQL personnalisée.<br>
              Pour plus d'informations sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i>, rendez-vous sur ce chapitre du manuel utilisateur : <a href="#manual_3600">Utilisation de la classe qx::QxSqlQuery (ou son alias qx_query)</a>.<br>
              <br>
              La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a> est une fonction <i>template</i> : le type T doit être enregistré dans le contexte QxOrm (fonction <i>qx::register_class&lt;T&gt;</i>).<br>
              Toutes les données renvoyées par la procédure stockée ou la requête SQL personnalisée qui pourront être associées aux membres des classes C++ (de type T) seront valorisées automatiquement.<br>
              Une recherche automatique est effectuée sur le nom des champs associés aux données.<br>
              Voici un exemple d'utilisation (disponible dans le projet qxBlog du package QxOrm) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom SQL query or a stored procedure and fetch automatically properties (with a collection of items)
</span>qx_query testStoredProcBis<span class="operator">(</span><span class="string">"SELECT * FROM author"</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>execute_query<span class="operator">(</span>testStoredProcBis<span class="operator">,</span> authorX<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span> qAssert<span class="operator">(</span>authorX<span class="operator">.</span>count<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>authorX<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
              La fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> n'est pas une fonction <i>template</i> : les résultats de la requête doivent être parcourus manuellement sur la classe <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> (ou <i>qx_query</i>).<br>
              Pour récupérer un paramètre de sortie (qui doit être passé à la requête en tant que <i>QSql::Out</i> ou <i>QSql::InOut</i>), il suffit d'utiliser la méthode : <i>QVariant qx::QxSqlQuery::boundValue(const QString & sKey) const;</i>.<br>
              <br>
              Pour parcourir la liste des résultats de la requête, il faut utiliser les méthodes suivantes :
              <ul>
                <li><i>long qx::QxSqlQuery::getSqlResultRowCount() const;</i></li>
                <li><i>long qx::QxSqlQuery::getSqlResultColumnCount() const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, long column) const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, const QString & column) const;</i></li>
                <li><i>QVector qx::QxSqlQuery::getSqlResultAllColumns() const;</i></li>
                <li><i>void qx::QxSqlQuery::dumpSqlResult();</i></li>
              </ul>
              Voici un exemple d'utilisation avec la fonction <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">(</span><span class="string">"CALL MyStoredProc(:param1, :param2)"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param1"</span><span class="operator">,</span><span class="string"> "myValue1"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param2"</span><span class="operator">,</span><span class="int"> 5024</span><span class="operator">,</span> QSql<span class="operator">::</span>InOut<span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>call_query<span class="operator">(</span>query<span class="operator">);</span>
QVariant vNewValue<span class="operator"> =</span> query<span class="operator">.</span>boundValue<span class="operator">(</span><span class="string">":param2"</span><span class="operator">);</span>
query<span class="operator">.</span>dumpSqlResult<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_370">Transactions (commit, rollback, session)</a></p>
         <div class="manual_div_content">
            Une <a href="http://knol.google.com/k/les-transactions-base-de-données" target="_blank"><b>transaction</b></a> est une suite d'opérations effectuées comme une seule unité logique de travail.<br>
            Une fois terminée, la transaction est :
            <ul>
            <li>soit validée (<b>commit</b>), alors toutes les modifications sont faites dans la base de données ;</li>
            <li>soit annulée (<b>rollback</b>), alors toutes les modifications ne sont pas enregistrée.</li>
            </ul>
            La classe <b><a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a></b> de la bibliothèque QxOrm permet de gérer automatiquement les transactions (validation, annulation) en utilisant le mécanisme <a href="http://fr.wikipedia.org/wiki/RAII" target="_blank">C++ RAII</a> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connection valide à la BDD est assignée à la session et une transaction est démarrée
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD (en utilisant l'opérateur += de la classe qx::QxSession et la connection de la session)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> une session peut déclencher une exception de type <a href="../doxygen/html/classqx_1_1dao_1_1sql__error.html" target="_blank"><i>qx::dao::sql_error</i></a> lorsqu'une erreur se produit (par défaut, aucune exception n'est déclenchée). Il est possible de paramétrer ce comportement en utilisant :
            <ul>
            <li>soit le constructeur de la classe <i>qx::QxSession</i> (pour une session en particulier) ;</li>
            <li>soit le paramètre du singleton <i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> (pour toutes les sessions).</li>
            </ul>
            <b>Autre remarque :</b> il est important de ne pas oublier de passer la connection à la base de données de la session à chaque fonction <i>qx::dao::xxx</i> (en utilisant la méthode <i>session.database()</i>).<br>
            De plus, il est possible d'initialiser une session avec sa propre connection (provenant d'un pool de connections par exemple) en utilisant le constructeur de la classe <i>qx::QxSession</i>.<br>
            <br>
            La classe <i>qx::QxSession</i> propose également des méthodes de persistance (CRUD), ce qui peut simplifier l'écriture du code C++ suivant les habitudes de programmation.<br>
            Voici le même exemple en utilisant les méthodes de la classe <i>qx::QxSession</i> à la place des fonctions du <i>namespace</i> <i>qx::dao</i> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connection valide à la BDD est assignée à la session et une transaction est démarrée
</span>  qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD
</span>  session<span class="operator">.</span>insert<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>update<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>fetchById<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>deleteById<span class="operator">(</span>my_object<span class="operator">);</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
</span><span class="flow">  if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_380">Moteur de relations</a></p>
         <div class="manual_div_content">
            La bibliothèque QxOrm fournit un puissant moteur de relations permettant de définir facilement :
            <ul>
               <li>des relations <a href="#manual_3800">one-to-many (1-n)</a> ;</li>
               <li>des relations <a href="#manual_3810">many-to-one (n-1)</a> ;</li>
               <li>des relations <a href="#manual_3820">many-to-many (n-n)</a> ;</li>
               <li>des relations <a href="#manual_3830">one-to-one (1-1)</a> ;</li>
            </ul>
            <b>Remarque :</b> <a href="./tutorial.html">un tutoriel complet sur les relations basé sur le projet de test <i>qxBlog</i></a> (dont les sources sont présentes dans le package QxOrm) est disponible.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3800">one-to-many (1-n)</a></p>
            <div class="manual_div_content">
              Une relation <i>one-to-many (1-n)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToMany()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 3 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation ;</li>
                <li><i>const QString & sForeignKey</i> : clé étrangère définie dans la classe/table liée.</li>
              </ul>
              <br>
              <b>Par exemple : </b> prenons l'exemple d'un <i>author</i> (une personne) qui peut rédiger plusieurs <i>blog</i>
              : nous allons ainsi montrer comment définir une relation de type
              <b><i>one-to-many</i></b>. <br>
              Au niveau base de données, voici les deux tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.author" src="./resource/qxBlog.table.author.jpg"
              width="318" height="118"><br>
              <br>
              Fichier <i>author.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- propriétés
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
               </td></tr></tbody></table>
               <br>
               Fichier <i>author.cpp</i> :<br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span></font>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3810">many-to-one (n-1)</a></p>
            <div class="manual_div_content">
              Une relation <i>many-to-one (n-1)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToOne()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 2 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation (correspond à une colonne de la table dans la base de données).</li>
              </ul>
              <br>
              <b>Par exemple : </b> un <i>comment</i> est associé à un <i>blog</i> et un <i>blog</i> peut
              contenir plusieurs <i>comment</i> : nous allons ainsi montrer comment
              définir une relation de type <b><i>many-to-one</i></b>. <br>
              Au niveau base de données, voici les deux tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.comment"
              src="./resource/qxBlog.table.comment.jpg" width="335" height="116"><br>
              <br>
              Fichier <i>comment.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.h">
<pre><span class="pre">#ifndef _QX_BLOG_COMMENT_H_
#define _QX_BLOG_COMMENT_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT comment<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="comment">
// -- propriétés
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_text<span class="operator">;</span>
   QDateTime   m_dt_create<span class="operator">;</span>
   <font style="background-color:yellow">blog_ptr    m_blog<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   comment<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>comment<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>comment<span class="operator">&gt;</span> comment_ptr<span class="operator">;</span><span class="keyword">
typedef</span> QList<span class="operator">&lt;</span>comment_ptr<span class="operator">&gt;</span> list_comment<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_COMMENT_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              Fichier <i>comment.cpp</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>comment<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "comment_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_text<span class="operator">,</span><span class="string"> "comment_text"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_dt_create<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToOne<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_blog<span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3820">many-to-many (n-n)</a></p>
            <div class="manual_div_content">
              Une relation <i>many-to-many (n-n)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToMany()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 5 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation ;</li>
                <li><i>const QString & sExtraTable</i> : nom de la table supplémentaire permettant de stocker les <i>id</i> de chaque côté des relations ;</li>
                <li><i>const QString & sForeignKeyOwner</i> : clé étrangère définie dans la table supplémentaire pour représenter la classe/table courante ;</li>
                <li><i>const QString & sForeignKeyDataType</i> : clé étrangère définie dans la table supplémentaire pour représenter la classe/table associée à la relation.</li>
              </ul>
              <br>
              <b>Par exemple : </b> une <i>category</i> référence plusieurs <i>blog</i> et un <i>blog</i> peut
              appartenir à plusieurs <i>category</i> : nous allons ainsi montrer
              comment définir une relation de type <b><i>many-to-many</i></b>.
              Ce type de relation implique une table supplémentaire dans la base de
              données pour stocker la liste des <i>id</i> de chaque côté des
              relations. <br>
              Au niveau base de données, voici les trois tables qui correspondent : <br>
              <br>
              <img alt="qxBlog.table.category"
              src="./resource/qxBlog.table.category.jpg" width="464" height="115"><br>
              <br>
              Fichier <i>category.h</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.h">
<pre><span class="pre">#ifndef _QX_BLOG_CATEGORY_H_
#define _QX_BLOG_CATEGORY_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT category<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- propriétés
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructeur, destructeur virtuel
</span>   category<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>category<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>category<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> QSharedPointer<span class="operator">&lt;</span>category<span class="operator">&gt;</span> category_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> category_ptr<span class="operator">&gt;</span> list_category<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_CATEGORY_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              Fichier <i>category.cpp</i> :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/category.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>category<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>category<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> category<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "description"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToMany<span class="operator">(&amp;</span> category<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "category_blog"</span><span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3830">one-to-one (1-1)</a></p>
            <div class="manual_div_content">
              Une relation <i>one-to-one (1-1)</i> permet de représenter 2 entités distinctes qui partagent le même identifiant en base de données.
              Une relation <i>one-to-one (1-1)</i> est définie par la méthode : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToOne()</a>.
              Cette méthode renvoie une instance de la classe <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> (classe de base pour toutes les relations) et nécessite 2 paramètres :
              <ul>
                <li><i>V U::* pData</i> : référence vers la donnée membre de la classe ;</li>
                <li><i>const QString & sKey</i> : clé unique associée à la relation.</li>
              </ul>
              <br>
              <b>Par exemple :</b> prenons l'exemple d'une table <i>person</i> et d'une autre table <i>author</i> : un <i>author</i> est également une <i>person</i>, les 2 tables pourraient partager le même identifiant en base de données.
              Au niveau base de données, voici les 2 tables qui correspondent (<i>person_id == author_id</i>) :<br>
              <br>
              <img alt="qxBlog.table.person" src="resource/qxBlog.table.person.jpg" width="279" height="118">
              <br><br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3840">Requête SQL avec relations</a></p>
            <div class="manual_div_content">
              La bibliothèque QxOrm supporte quatre types de relations pour lier les classes C++ enregistrées dans le contexte QxOrm : <i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>.<br>
              Pour plus de détails sur la définition de ces relations, il est conseillé de lire <a href="./tutorial.html" target="_blank">le tutoriel qxBlog</a>.<br>
              Nous allons détailler dans cette Q&R les différentes méthodes de récupération des données (module <a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao</a>, fonctions du namespace <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a>) :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query</a> : récupère les données en requêtant une seule table de la base de données (on parle alors de mode <i>lazy fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_all_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_all_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_all_relation</a> : récupère les données en requêtant une table + toutes ses tables liées (soit une requête sur plusieurs tables de la base de données, on parle alors de mode <i>eager fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> : équivalent aux fonctions ci-dessus (mode <i>eager fetch</i>) avec possibilité de préciser les relations à récupérer sur plusieurs niveaux.</li>
              </ul>
              Le premier paramètre des fonctions <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> et <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> correspond à la liste des relations à requêter.<br>
              Cette liste de relations peut contenir les éléments suivants :
              <ul>
              <li>identifiant d'une relation : chaque relation possède une clé définie au niveau de la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> ;</li>
              <li>le mot-clé "<i>*</i>" signifie "<i>récupérer toutes les relations définies dans la fonction de paramétrage <i>qx::register_class&lt;T&gt;</i> sur un niveau</i>" ;</li>
              <li>le mot-clé "<i>-></i>" signifie jointure de type "<i>LEFT OUTER JOIN</i>" (jointure par défaut de la bibliothèque QxOrm) ;</li>
              <li>le mot-clé "<i>>></i>" signifie jointure de type "<i>INNER JOIN</i>" entre deux tables.</li>
              </ul>
              <b>Remarque :</b> en utilisant le mot-clé "*" pour indiquer "<i>toutes les relations sur un niveau</i>", les appels suivants sont équivalents :
              <ul>
              <li><i>qx::dao::fetch_by_id_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_id_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_by_query_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_query_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_all_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_all_with_all_relation(...)</i>.</li>
              </ul>
              <br>
              <b>Exemple :</b> à partir du tutoriel qxBlog, il est possible de récupérer les données suivantes avec une seule requête :<br>
              <br>
              <b>1-</b> récupérer un <i>blog</i> et son <i>author</i> ;<br>
              <b>2-</b> pour l'<i>author</i> valorisé, récupérer tous les <i>blog</i> qu'il a écrit ;<br>
              <b>3-</b> pour chaque <i>blog</i> que l'<i>author</i> a écrit, récupérer tous les <i>comment</i> associés.<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:180px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Autre exemple :</b> il est également possible de créer une liste de relations à récupérer, comme ceci par exemple :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QStringList relation<span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_category"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_category"</span><span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>relation<span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:270px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, 
       category_7.category_id AS category_7_category_id_0, category_7.name AS category_7_name_0, category_7.description AS category_7_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN category_blog category_blog_7 ON blog.blog_id = category_blog_7.blog_id 
LEFT OUTER JOIN category category_7 ON category_blog_7.category_id = category_7.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Autre exemple :</b> pour récupérer toutes les relations pour un niveau donné, il faut utiliser le mot-clé "*".<br>
              Pour récupérer toutes les données de toutes les relations sur trois niveaux, il faut écrire :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"*-&gt;*-&gt;*"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              Ce qui génère la requête SQL suivante :
              <div style="width:900px; height:620px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, blog_2.author_id AS blog_2_author_id_0_2, 
       author_3.author_id AS author_3_author_id_0, author_3.name AS author_3_name_0, author_3.birthdate AS author_3_birthdate_0, author_3.sex AS author_3_sex_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, comment_6.blog_id AS comment_6_blog_id_0_6, 
       blog_7.blog_id AS blog_7_blog_id_0, blog_7.blog_text AS blog_7_blog_text_0, blog_7.date_creation AS blog_7_date_creation_0, blog_7.author_id AS blog_7_author_id_0_7, 
       author_8.author_id AS author_8_author_id_0, author_8.name AS author_8_name_0, author_8.birthdate AS author_8_birthdate_0, author_8.sex AS author_8_sex_0, 
       comment_9.comment_id AS comment_9_comment_id_0, comment_9.blog_id AS comment_9_blog_id_0, comment_9.comment_text AS comment_9_comment_text_0, comment_9.date_creation AS comment_9_date_creation_0, 
       category_10.category_id AS category_10_category_id_0, category_10.name AS category_10_name_0, category_10.description AS category_10_description_0, 
       category_11.category_id AS category_11_category_id_0, category_11.name AS category_11_name_0, category_11.description AS category_11_description_0, 
       blog_12.blog_id AS blog_12_blog_id_0, blog_12.blog_text AS blog_12_blog_text_0, blog_12.date_creation AS blog_12_date_creation_0, blog_12.author_id AS blog_12_author_id_0_12, 
       author_13.author_id AS author_13_author_id_0, author_13.name AS author_13_name_0, author_13.birthdate AS author_13_birthdate_0, author_13.sex AS author_13_sex_0, 
       comment_14.comment_id AS comment_14_comment_id_0, comment_14.blog_id AS comment_14_blog_id_0, comment_14.comment_text AS comment_14_comment_text_0, comment_14.date_creation AS comment_14_date_creation_0, 
       category_15.category_id AS category_15_category_id_0, category_15.name AS category_15_name_0, category_15.description AS category_15_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN author author_3 ON author_3.author_id = blog_2.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN blog blog_7 ON blog_7.blog_id = comment_6.blog_id 
LEFT OUTER JOIN author author_8 ON author_8.author_id = blog_7.author_id 
LEFT OUTER JOIN comment comment_9 ON comment_9.blog_id = blog_7.blog_id 
LEFT OUTER JOIN category_blog category_blog_10 ON blog_7.blog_id = category_blog_10.blog_id 
LEFT OUTER JOIN category category_10 ON category_blog_10.category_id = category_10.category_id 
LEFT OUTER JOIN category_blog category_blog_11 ON blog.blog_id = category_blog_11.blog_id 
LEFT OUTER JOIN category category_11 ON category_blog_11.category_id = category_11.category_id 
LEFT OUTER JOIN category_blog category_blog_12 ON category_11.category_id = category_blog_12.category_id 
LEFT OUTER JOIN blog blog_12 ON category_blog_12.blog_id = blog_12.blog_id 
LEFT OUTER JOIN author author_13 ON author_13.author_id = blog_12.author_id 
LEFT OUTER JOIN comment comment_14 ON comment_14.blog_id = blog_12.blog_id 
LEFT OUTER JOIN category_blog category_blog_15 ON blog_12.blog_id = category_blog_15.blog_id 
LEFT OUTER JOIN category category_15 ON category_blog_15.category_id = category_15.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3850">Sélectionner les colonnes des relations à récupérer</a></p>
            <div class="manual_div_content">
               Il est parfois nécessaire de ne pas requêter toutes les colonnes d'une table par soucis d'optimisation : en effet, sélectionner les colonnes réellement utilisées par un traitement permet de limiter les flux réseau entre la base de données et l'application C++, ce qui améliore les performances.<br>
               <br>
               Concernant les relations, la bibliothèque QxOrm fournit une syntaxe spécifique pour sélectionner les colonnes à récupérer, sous la forme : <b>my_relation { col_1, col_2, etc... }</b>.
               Si cette syntaxe n'est pas utilisée, par défaut, QxOrm récupère toutes les colonnes.<br>
               <br>
               <b>Par exemple</b> : imaginons la requête suivante qui permet de récupérer :
               <ul>
                  <li>uniquement la colonne <i>blog_text</i> de la table <i>blog</i> ;</li>
                  <li>uniquement les colonnes <i>name</i> et <i>birthdate</i> de la table <i>author</i> ;</li>
                  <li>uniquement la colonne <i>comment_text</i> de la table <i>comment</i>.</li>
               </ul>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre><span class="comment">   // Fetch relations defining columns to fetch with syntax { col_1, col_2, etc... }
</span>   list_blog lstBlogComplexRelation<span class="operator">;</span>
   <font style="background-color:yellow">QStringList relations<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "{ blog_text }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "author_id { name, birthdate }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "list_comment { comment_text }"</span><span class="operator">;</span></font>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all_with_relation<span class="operator">(</span>relations<span class="operator">,</span> lstBlogComplexRelation<span class="operator">);</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lstBlogComplexRelation<span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_creation<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_sex<span class="operator"> ==</span> author<span class="operator">::</span>unknown<span class="operator">);</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_name<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_create<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Remarque :</b> une autre syntaxe est disponible afin de renseigner les colonnes à ne pas récupérer : <b>my_relation -{ col_1, col_2, etc... }</b>.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_390">Collections supportées par QxOrm</a></p>
         <div class="manual_div_content">
            QxOrm supporte de nombreux conteneurs livrés avec <a href="#manual_3900">Qt</a>, <a href="#manual_3910">boost</a> ou la <a href="#manual_3920">bibliothèque standard std</a>.
            La bibliothèque QxOrm fournit également son propre conteneur, nommé <a href="#manual_3930">qx::QxCollection</a>, particulièrement adapté pour stocker les données issues d'une base de données.
            Le développeur a donc à sa disposition un large choix : QxOrm n'impose aucune contrainte sur l'utilisation des collections.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3900">Collections de Qt</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt collections">
<pre>
  QList&lt;T&gt;  
  QVector&lt;T&gt;  
  QSet&lt;T&gt;  
  QLinkedList&lt;T&gt;  
  QHash&lt;Key, Value&gt;  
  QMap&lt;Key, Value&gt;  
  QMultiHash&lt;Key, Value&gt;  
  QMultiMap&lt;Key, Value&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3910">Collections de boost</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost collections">
<pre>
  boost::unordered_map&lt;Key, Value&gt;  
  boost::unordered_set&lt;T&gt;  
  boost::unordered_multimap&lt;Key, Value&gt;  
  boost::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3920">Collections fournies par l'espace de nom standard std</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std collections">
<pre>
  std::list&lt;T&gt;  
  std::vector&lt;T&gt;  
  std::set&lt;T&gt;  
  std::map&lt;Key, Value&gt;  

  <span class="comment">// With _QX_CPP_11_CONTAINER compilation option defined</span>  
  std::unordered_map&lt;Key, Value&gt;  
  std::unordered_set&lt;T&gt;  
  std::unordered_multimap&lt;Key, Value&gt;  
  std::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3930">qx::QxCollection</a></p>
            <div class="manual_div_content">
              Il existe de nombreux <i>container</i> dans les bibliothèques <b>stl</b>, <b>boost</b> et <b>Qt</b>.<br>
              Il est donc légitime de se poser cette question : à quoi sert <i>qx::QxCollection&lt;Key, Value&gt;</i> ?<br>
              <i><a href="../doxygen/html/classqx_1_1_qx_collection.html" target="_blank">qx::QxCollection&lt;Key, Value&gt;</a></i> est un nouveau <i>container</i> (basé sur l'excellente bibliothèque <a href="http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a>) qui possède les fonctionnalités suivantes :
              <ul><li>conserve l'ordre d'insertion des éléments dans la liste ;
              </li><li>accès rapide à un élément par son index : équivaut à <i>std::vector&lt;T&gt;</i> ou <i>QList&lt;T&gt;</i> par exemple ;
              </li><li>accès rapide à un élément par une clé (<i>hash-map</i>) : équivaut à <i>QHash&lt;Key, Value&gt;</i> ou <i>boost::unordered_map&lt;Key, Value&gt;</i> par exemple ;
              </li><li>fonctions de tri sur le type <i>Key</i> et sur le type <i>Value</i>.
              </li></ul>
              <b>Remarque :</b>
              <i>qx::QxCollection&lt;Key, Value&gt;</i> est compatible avec la macro <i>foreach</i> fournie par la bibliothèque <b>Qt</b> ainsi que par la macro <a href="http://www.boost.org/doc/libs/release/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> fournie par la bibliothèque <b>boost</b>.<br>
              Cependant, chaque élément renvoyé par ces deux macros correspond à un objet de type <i>std::pair&lt;Key, Value&gt;</i>.<br>
              Pour obtenir un résultat 'plus naturel' et plus lisible, il est conseillé d'utiliser la macro <i>_foreach</i> : cette macro utilise <i>BOOST_FOREACH</i> pour tous les <i>container</i> sauf pour <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              Dans ce cas, l'élément renvoyé correspond au type <i>Value</i> (voir par la suite l'exemple d'utilisation).<br>
              La macro <i>_foreach</i> est donc compatible avec tous les <i>container</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>, etc.) puisqu'elle utilise la macro <i>BOOST_FOREACH</i>.<br><br>
              <b>Autre Remarque :</b>
              <i>qx::QxCollection&lt;Key, Value&gt;</i> est particulièrement adapté pour recevoir des données issues d'une base de données.<br>
              En effet, ces données peuvent être triées (en utilisant <i>ORDER BY</i> dans une requête SQL par exemple), il est donc important de conserver l'ordre d'insertion des éléments dans la liste.<br>
              De plus, chaque donnée issue d'une base de données possède un identifiant unique. Il est donc intéressant de pouvoir accéder à un élément en fonction de cet identifiant unique de manière extrèmement rapide (<i>hash-map</i>).<br><br>
              <b>Exemple d'utilisation de la collection <i>qx::QxCollection&lt;Key, Value&gt;</i> :</b><br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* définition d'une classe drug avec 3 propriétés : 'code', 'name', 'description' */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* pointeur intelligent associé à la classe drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection de drugs (accès rapide à un élément de la collection par la propriété 'code') */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* création de 3 nouveaux drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insertion des 3 drugs dans la collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* parcours la collection en utilisant le mot-clé '_foreach' */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* parcours la collection en utilisant une boucle 'for' */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* parcours la collection en utilisant le style Java avec 'QxCollectionIterator' */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* effectue un tri croissant par clé (propriété 'code') et décroissant par valeur */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son 'code' */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son index (position) dans la collection */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* teste si un drug existe dans la collection et si la liste est vide */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* supprime de la collection le 2ème élément */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* supprime de la collection l'élément avec le code 'code3' */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* efface tous les éléments de la collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_400">Pointeurs intelligents supportés par QxOrm (smart-pointers)</a></p>
         <div class="manual_div_content">
            QxOrm supporte de nombreux pointeurs intelligents livrés avec <a href="#manual_4000">Qt</a>, <a href="#manual_4010">boost</a> ou la <a href="#manual_4020">bibliothèque standard std</a>.
            La bibliothèque QxOrm fournit également son propre pointeur intelligent, nommé <a href="#manual_4030">qx::dao::ptr</a>, apportant de nouvelles fonctionnalités lorsqu'il est utilisé avec les fonctions de <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">l'espace de nom qx::dao</a>.
            Le développeur a donc à sa disposition un large choix : QxOrm n'impose aucune contrainte sur l'utilisation des pointeurs intelligents.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4000">Pointeurs intelligents de Qt</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt smart pointers">
<pre>
  QSharedPointer&lt;T&gt;  
  QScopedPointer&lt;T&gt;  
  QWeakPointer&lt;T&gt;  
  QSharedDataPointer&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4010">Pointeurs intelligents de boost</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost smart pointers">
<pre>
  boost::shared_ptr&lt;T&gt;  
  boost::intrusive_ptr&lt;T&gt;  
  boost::scoped_ptr&lt;T&gt;  
  boost::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4020">Pointeurs intelligents fournis par l'espace de nom standard std</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std smart pointers">
<pre>
  <span class="comment">// With _QX_CPP_11_SMART_PTR compilation option defined</span>  
  std::shared_ptr&lt;T&gt;  
  std::unique_ptr&lt;T&gt;  
  std::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4030">qx::dao::ptr</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> est compatible avec les pointeurs intelligents des bibliothèques <b>boost</b> et <b>Qt</b>.<br>
              Le pointeur intelligent développé par <b>QxOrm</b> est basé sur <i>QSharedPointer</i> et apporte de nouvelles fonctionnalités s'il est utilisé avec les fonctions '<i>qx::dao::...</i>'.<br>
              <i><a href="../doxygen/html/classqx_1_1dao_1_1ptr.html" target="_blank">qx::dao::ptr&lt;T&gt;</a></i> conserve automatiquement les valeurs issues de la base de données.<br>
              Il est ainsi possible de vérifier à tout moment si une instance d'objet a subi des modifications grâce à la méthode '<i>isDirty()</i>' : cette méthode peut renvoyer la liste de toutes les propriétés ayant été modifiées.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> peut également être utilisé par la fonction '<i>qx::dao::update_optimized()</i>' pour mettre à jour en base de données uniquement les champs modifiés.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> peut être utilisé avec un objet simple ou bien avec la plupart des containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> et <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              <br>
              <b>Exemple d'utilisation du pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> :</b><br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// exemple d'utilisation de la méthode 'isDirty()'
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour uniquement la propriété 'm_text' de l'instance 'blog_isdirty'
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

// exemple d'utilisation de la méthode 'isDirty()' avec une liste d'objets
</span><span class="keyword">typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour la propriété 'm_name' en position 1, la propriété 'm_birthdate' en position 2 et ne change rien en position 0
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

// récupère uniquement la propriété 'm_dt_creation' du blog
</span>QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
{</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_410">Déclencheurs (triggers)</a></p>
         <div class="manual_div_content">
           Les <i>Trigger</i> de <b>QxOrm</b> permettent d'effectuer divers traitements avant et/ou après une insertion, une mise à jour ou bien une suppression dans la base de données.<br>
           Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.<br>
           Cette classe contient cinq propriétés : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> et <i>m_userModification</i>.<br>
           Ces propriétés se mettront à jour automatiquement pour chaque classe héritant de <i>BaseClassTrigger</i> (cf. les classes <i>Foo</i> et <i>Bar</i> du même projet).<br>
           Il est nécessaire de spécialiser le template '<i>qx::dao::detail::QxDao_Trigger&lt;T&gt;</i>' pour profiter de cette fonctionnalité.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span>

   <font style="background-color:yellow"><span class="type">void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>
   <font style="background-color:yellow"><span class="type">void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span>
<font style="background-color:yellow"><span class="keyword">struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;</span></font>
<span class="operator">{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }
   static inline</span><span class="type"> void</span> onAfterFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_420">Validation d'une instance C++ (validators)</a></p>
         <div class="manual_div_content">
            Le module <b><a href="../doxygen/html/group___qx_validator.html" target="_blank">QxValidator</a></b> de la bibliothèque <b>QxOrm</b> permet d'ajouter des contraintes sur les propriétés enregistrées dans le contexte QxOrm.<br>
            Ces contraintes sont définies dans la méthode de mapping : <i>void qx::register_class&lt;T&gt;</i>.<br>
            Si pour une instance de classe donnée, au moins une contrainte n'est pas respectée, alors l'instance est considérée comme invalide : l'objet ne peut alors pas être sauvegardé en base de données (<i>INSERT</i> ou <i>UPDATE</i>).<br>
            <br>
            Il est également possible d'utiliser le module <b>QxValidator</b> pour valider les données au niveau de la couche présentation de l'application : si les données saisies par un utilisateur ne sont pas valides, un message d'erreur peut être signalé, il n'est alors pas nécessaire d'essayer d'enregistrer l'instance courante en base de données.<br>
            Les règles de validation n'ont pas besoin d'être dupliquées : elles peuvent être utilisées aussi bien par la couche présentation que par la couche d'accès aux données de l'application.<br>
            <br>
            Voici la description de quelques classes du module <b>QxValidator</b> :
            <ul>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator.html" target="_blank">qx::IxValidator</a> : chaque contrainte définie dans la fonction de mapping <i>void qx::register_class&lt;T&gt;</i> est associée à une interface de type <i>qx::IxValidator</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator_x.html" target="_blank">qx::IxValidatorX</a> : pour une classe donnée, la liste des contraintes est associée à une interface de type <i>qx::IxValidatorX</i>. Cette collection peut être parcourue à l'exécution du programme : ça peut être intéressant par exemple pour générer le schéma DDL SQL et prendre en compte les contraintes au niveau de la base de données (voir le chapitre suivant du manuel utilisateur : <a href="#manual_470">Générer le schéma DDL SQL de la base de données</a>) ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value_x.html" target="_blank">qx::QxInvalidValueX</a> : au moment du processus de validation, lorsqu'une instance n'est pas valide, la liste des contraintes non respectées est représentée par une collection de type <i>qx::QxInvalidValueX</i> ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value.html" target="_blank">qx::QxInvalidValue</a> : chaque élément de cette collection est de type <i>qx::QxInvalidValue</i> et contient un message d'erreur (description expliquant pourquoi l'instance est invalide).</li>
            </ul>
            Le module <b>QxValidator</b> gère automatiquement la notion d'héritage de classe : si des contraintes sont définies au niveau de la classe de base, alors elles seront automatiquement vérifiées pour chaque validation d'une classe dérivée.<br>
            <br>
            Voici un exemple d'utilisation du module <b>QxValidator</b> avec une classe '<i>person</i>' :<br>
            <br>
            * fichier '<i>person.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _CLASS_PERSON_H_
#define _CLASS_PERSON_H_
</span><span class="keyword"> 
class</span> person<span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span><span class="keyword">

   enum</span> sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="type">

   long</span>        _id<span class="operator">;</span>
   QString     _firstName<span class="operator">;</span>
   QString     _lastName<span class="operator">;</span>
   QDateTime   _birthDate<span class="operator">;</span>
   sex         _sex<span class="operator">;</span>

   person<span class="operator">() :</span> _id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span>
   person<span class="operator">(</span><span class="type">long</span> id<span class="operator">) :</span> _id<span class="operator">(</span>id<span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span>

   <font style="background-color:yellow"><span class="type">void</span> isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _CLASS_PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>person.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/person.h"
#include "../include/global_validator.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_MY_EXE<span class="operator">(</span>person<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_firstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_lastName<span class="operator">,</span><span class="string"> "lastName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_birthDate<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">QxValidatorX<span class="operator">&lt;</span>person<span class="operator">&gt; *</span> pAllValidator<span class="operator"> =</span> t<span class="operator">.</span>getAllValidator<span class="operator">();</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"lastName"</span><span class="operator">,</span><span class="string"> "a person must have a lastname"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator<span class="operator">(&amp;</span> person<span class="operator">::</span>isValid<span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_QVariant<span class="operator">(&amp;</span> validateFirstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_DataType<span class="operator">&lt;</span>QDateTime<span class="operator">&gt;(&amp;</span> validateDateTime<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span></font>
<span class="operator">}}</span>

<font style="background-color:yellow"><span class="type">void</span> person<span class="operator">::</span>isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)</span></font>
<span class="operator">{</span><span class="comment">
   // Cette méthode est appelée automatiquement par le module 'QxValidator' :
   // - avant d'insérer ou mettre à jour une instance de type 'person' par les fonctions du namespace 'qx::dao' ;
   // - en utilisant la fonction 'qx::validate()' avec pour paramètre une instance de type 'person'.

   // L'enregistrement de la méthode 'person::isValid()' est effectué dans la fonction de mapping :
   // pAllValidator-&gt;add_CustomValidator(&amp; person::isValid);

   // Dans cette méthode, il est possible de vérifier n'importe quelle valeur de l'instance courante
   // Si une propriété est non valide, il suffit d'insérer un élément dans la collection 'invalidValues'

   // Remarque : cette méthode est déclarée 'private' pour forcer l'utilisateur à utiliser la fonction 'qx::validate()'
   // Mais ce n'est pas une obligation : cette méthode peut être déclarée 'public' ou 'protected'

   // Par exemple, si on souhaite vérifier la propriété '_sex' d'une personne :
</span><span class="flow">   if</span><span class="operator"> ((</span>_sex<span class="operator"> !=</span> male<span class="operator">) &amp;&amp; (</span>_sex<span class="operator"> !=</span> female<span class="operator">))
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"le sexe de la personne doit être défini : masculin ou féminin"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>global_validator.h</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Les fonctions suivantes ('validateFirstName()' et 'validateDateTime()') sont globales (non liées à une classe)
// Elles peuvent ainsi être utilisées par plusieurs classes pour valider une propriété (par exemple : valider la saisie d'une adresse IP).
// Ces fonctions seront appelées automatiquement par le module 'QxValidator' :
// - avant d'insérer ou mettre à jour une instance de classe par les fonctions du namespace 'qx::dao' ;
// - en utilisant la fonction 'qx::validate()'.
</span><span class="type"> 
void</span> validateFirstName<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (convertie en type QVariant)
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la valeur ne doit jamais être égale à "admin" :
</span><span class="flow">   if</span><span class="operator"> (</span>value<span class="operator">.</span>toString<span class="operator">() ==</span><span class="string"> "admin"</span><span class="operator">)
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la valeur ne peut pas être égale à 'admin'"</span><span class="operator">); }
}</span><span class="type">

void</span> validateDateTime<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Ici, on peut tester la valeur d'une propriété (en conservant son vrai type, ici il s'agit de tester une date-heure de type 'QDateTime')
   // Si la valeur est invalide, il suffit d'insérer un message à la collection 'invalidValues'

   // Par exemple, si la date-heure doit forcément être renseignée :
</span><span class="flow">   if</span><span class="operator"> (!</span> value<span class="operator">.</span>isValid<span class="operator">())
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"la date-heure doit être renseignée et doit être valide"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * fichier '<i>main.cpp</i>' :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>person personValidate<span class="operator">;</span>
personValidate<span class="operator">.</span>_lastName<span class="operator"> =</span><span class="string"> "admin"</span><span class="operator">;</span>
qx<span class="operator">::</span>QxInvalidValueX invalidValues<span class="operator"> =</span> qx<span class="operator">::</span>validate<span class="operator">(</span>personValidate<span class="operator">);</span>
QString sInvalidValues<span class="operator"> =</span> invalidValues<span class="operator">.</span>text<span class="operator">();</span>
qDebug<span class="operator">(</span><span class="string">"[QxOrm] test 'QxValidator' module :\n%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sInvalidValues<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            A l'exécution de ce bout de code, l'instance '<i>personValidate</i>' est non valide : la collection '<i>invalidValues</i>' contient quatre éléments :<br>
            - "<i>la valeur de la propriété 'firstName' ne peut pas être vide</i>" ;<br>
            - "<i>le sexe de la personne doit être défini : masculin ou féminin</i>" ;<br>
            - "<i>la valeur ne peut pas être égale à 'admin'</i>" ;<br>
            - "<i>la date-heure doit être renseignée et doit être valide</i>".<br>
            <br>
            Le module <b>QxValidator</b> fournit plusieurs validateurs pour effectuer des vérifications basiques :
            <ul>
                <li><i>add_NotNull()</i> : vérifie que la valeur n'est pas nulle ;</li>
                <li><i>add_NotEmpty()</i> : vérifie que la chaîne de caractères n'est pas vide ;</li>
                <li><i>add_MinValue()</i> : vérifie que la valeur numérique n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxValue()</i> : vérifie que la valeur numérique n'est pas supérieure au paramètre ;</li>
                <li><i>add_Range()</i> : vérifie que la valeur numérique est comprise entre les deux paramètres ;</li>
                <li><i>add_MinDecimal()</i> : vérifie que la valeur décimale n'est pas inférieure au paramètre ;</li>
                <li><i>add_MaxDecimal()</i> : vérifie que la valeur décimale n'est pas supérieure au paramètre ;</li>
                <li><i>add_RangeDecimal()</i> : vérifie que la valeur décimale est comprise entre les deux paramètres ;</li>
                <li><i>add_MinLength()</i> : vérifie que la chaîne de caractères a une taille minimale ;</li>
                <li><i>add_MaxLength()</i> : vérifie que la chaîne de caractères ne dépasse pas un certain nombre de caractères ;</li>
                <li><i>add_Size()</i> : vérifie que la taille de la chaîne de caractères est comprise entre les deux paramètres ;</li>
                <li><i>add_DatePast()</i> : vérifie que la date-heure est dans le passé ;</li>
                <li><i>add_DateFuture()</i> : vérifie que la date-heure est dans le futur ;</li>
                <li><i>add_RegExp()</i> : vérifie que la chaîne de caractères est compatible avec l'expression régulière passée en paramètre ;</li>
                <li><i>add_EMail()</i> : vérifie que la chaîne de caractères correspond à un e-mail.</li>
            </ul>
            Comme dans l'exemple de la classe '<i>person</i>', il est possible de définir également des validateurs personnalisés : ce sont des fonctions ou méthodes de classe qui seront appelées automatiquement par le module <b>QxValidator</b> pour valider une propriété ou une instance de classe.<br>
            Il existe trois types de validateurs personnalisés :
            <ul>
                <li><i>add_CustomValidator()</i> : méthode de classe, la signature de la méthode doit être "<i>void my_class::my_method(qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_QVariant()</i> : fonction globale avec type <i>QVariant</i> (propriété convertie en <i>QVariant</i>), la signature de la fonction doit être "<i>void my_validator(const QVariant &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_DataType()</i> : fonction globale avec le type réel de la propriété, la signature de la fonction doit être "<i>void my_validator(const T &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
            </ul>
            <b>Remarque :</b> à chaque validateur peut être associé un groupe (paramètre optionnel pour chaque méthode <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>).<br>
            Il est ainsi possible de créer des groupes de validation suivant le contexte d'exécution : par exemple, valider la saisie d'une personne sur une IHM A ne nécessite peut-être pas les mêmes vérifications que valider une personne sur une IHM B.<br>
            Pour exécuter la validation d'une instance pour un groupe donné (par exemple "<i>myGroup</i>"), il faut appeler la fonction suivante : "<i>qx::QxInvalidValueX invalidValues = qx::validate(personValidate, "myGroup");</i>".<br>
            <br>
            <b>Autre remarque :</b> le module <b>QxValidator</b> définit des messages par défaut lorsqu'une contrainte n'est pas vérifiée.<br>
            Il est possible de redéfinir ces messages par défaut en modifiant la collection suivante : "<i>QHash<QString, QString> * lstMessage = QxClassX::getAllValidatorMessage();</i>".<br>
            Par exemple : "<i>lstMessage->insert("min_value", "la valeur '%NAME%' doit être inférieure ou égale à '%CONSTRAINT%'");</i>".<br>
            Les champs <i>%NAME%</i> et <i>%CONSTRAINT%</i> seront automatiquement remplacés par les valeurs correspondantes.<br>
            Pour modifier le message pour un validateur donné (et non de manière globale), il faut utiliser le paramètre optionnel disponible pour les méthodes <i>add_XXX()</i> de la classe <i>qx::IxValidatorX</i>.<br>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_430">Gérer la valeur NULL de la base de données</a></p>
         <div class="manual_div_content">
            Les bases de données possèdent la notion de valeur NULL : pour plus de détails sur la valeur NULL, <a href="https://en.wikipedia.org/wiki/Null_%28SQL%29" target="_blank">rendez-vous sur la page Wikipedia</a>.<br>
            La bibliothèque QxOrm permet de gérer la valeur NULL de plusieurs façons différentes :
            <ul>
               <li>utilisation de la classe <a href="#manual_4300">boost::optional</a> fournie par boost ;</li>
               <li>utilisation de la classe <a href="#manual_4310">QVariant</a> fournie par Qt ;</li>
               <li>utilisation de pointeurs ou pointeurs intelligents : un pointeur NULL est associé à la valeur NULL en base de données.</li>
            </ul>
            <br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4300">boost::optional</a></p>
            <div class="manual_div_content">
               La classe <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> fournie par boost est particulièrement adaptée pour gérer la notion de valeur NULL en base de données.<br>
               Voici un exemple de classe dont toutes les propriétés (sauf la clé primaire) peuvent être NULL en utilisant <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional</a> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QDateTime&gt; birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               La classe <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> se manipule facilement : rendez-vous sur <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">la documentation fournie par boost</a> pour plus de détails.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4310">QVariant</a></p>
            <div class="manual_div_content">
               La classe <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> fournie par Qt permet également de gérer la notion de valeur NULL en base de données.<br>
               Voici un exemple de classe dont toutes les propriétés (sauf la clé primaire) peuvent être NULL en utilisant <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">QVariant firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }  
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               Cette solution a pour désavantage de perdre le type de donnée comparé à <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a>.<br>
               Il est donc recommandé d'utiliser <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> pour gérer la valeur NULL avec la bibliothèque QxOrm.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_440">Héritage et polymorphisme</a></p>
         <div class="manual_div_content">
           On retrouve généralement dans les différents outils de type <i>ORM</i> trois différentes stratégies pour gérer la notion d'héritage avec la base de données :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> (une seule table regroupant toutes les propriétés d'une hiérarchie d'héritage de classes) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> (à chaque classe d'une hiérarchie d'héritage est associée une table dans la base de données) ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i> (une table par classe concrète dans la hiérarchie d'héritage).
           </li></ul>
           <b>QxOrm</b> utilise par défaut la stratégie <i>Concrete Table Inheritance</i> (les autres stratégies ne sont pas fonctionnelles à l'heure actuelle).<br>
           De nombreux tutoriaux et forums sont disponibles sur internet pour plus de détails sur cette notion d'héritage.<br>
           Un exemple d'utilisation avec une classe de base se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_450">Interface qx::IxPersistable (classe abstraite)</a></p>
         <div class="manual_div_content">
           L'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> (ou classe abstraite) dispose uniquement de méthodes virtuelles pures.<br>
           Elle permet d'avoir une classe de base commune pour appeler les fonctions de persistance sans connaître le type réel de l'instance courante (notion de polymorphisme).<br>
           La bibliothèque QxOrm n'impose pas de travailler avec une classe de base pour enregistrer un type persistant dans le contexte QxOrm, cependant il est parfois utile de disposer d'une interface afin d'écrire des algorithmes génériques.<br>
           <br>
           La classe <i>qx::IxPersistable</i> met à disposition les méthodes virtuelles suivantes (pour plus d'informations sur ces méthodes, rendez-vous sur la <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a>) :<br>
           <br>
           <div style="width:900px; height:290px; overflow:auto; background-color:white">
<pre><span class="keyword">virtual</span><span class="type"> long</span> qxCount<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchAll<span class="operator">(</span>qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxInsert<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxUpdate<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxSave<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx_bool qxExist<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>QxInvalidValueX qxValidate<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> groups<span class="operator"> =</span> QStringList<span class="operator">());</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxCollection_ptr qxNewPersistableCollection<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxClass<span class="operator"> *</span> qxClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></pre>
           </div>
           <br>
           Par exemple, à partir d'une liste de pointeurs de type <i>qx::IxPersistable</i>, il est possible d'enregistrer les éléments dans plusieurs tables différentes de la base de données de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QList<span class="operator">&lt;</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *&gt;</span> lst<span class="operator"> = ...;</span>
foreach<span class="operator">(</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *</span> p<span class="operator">,</span> lst<span class="operator">)
{</span>
   QSqlError daoError<span class="operator"> =</span> p<span class="operator">-&gt;</span>qxSave<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>daoError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="comment"> /* an error occured */</span><span class="operator"> }</span><span class="comment">
   // etc...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour implémenter l'interface <i>qx::IxPersistable</i>, il faut :
           <ul>
           <li>faire hériter la classe persistante du type <i>qx::IxPersistable</i> ;</li>
           <li>dans la définition de la classe (<i>myClass.h</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_HPP(myClass)</i> ;</li>
           <li>dans l'implémentation de la classe (<i>myClass.cpp</i> par exemple), ajouter la macro <i>QX_PERSISTABLE_CPP(myClass)</i>.</li>
           </ul>
           Par exemple, implémenter l'interface <i>qx::IxPersistable</i> pour la classe <a href="./tutorial.html#tuto_6"><i>author</i></a> du tutoriel <i>qxBlog</i> revient à écrire (les modifications par rapport au code du tutoriel apparaissent en gras) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author : <font style="background-color:yellow"><b>public qx::IxPersistable</b></font><span class="operator">
{</span>
   <font style="background-color:yellow"><b>QX_PERSISTABLE_HPP(author)</b></font>
<span class="keyword">public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- propriétés
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   list_blog   m_blogX<span class="operator">;</span><span class="comment">
// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
        </td></tr></tbody></table>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span>
<font style="background-color:yellow"><b>QX_PERSISTABLE_CPP(author)</b></font>

<span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le projet de test <i>./test/qxDllSample/dll1/</i> met à disposition une sorte de 'super classe de base' : la classe <i>qx::QxPersistable</i> implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> et hérite de <i>QObject</i>.<br>
           Le mécanisme <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank"><i>SIGNAL-SLOT</i></a> de Qt peut donc être utilisé avec cette classe, ce qui peut être intéressant par exemple pour la notion de déclencheurs (ou <a href="#manual_410"><i>trigger</i></a>).<br>
           La classe <i>qx::QxPersistable</i> met également à disposition des méthodes virtuelles qu'il est possible de surcharger pour gérer notamment la notion de validation des données avec le module <a href="#manual_420"><i>QxValidator</i></a>.<br>
           La classe <i>qx::QxPersistable</i> ne fait pas partie de la distribution de QxOrm, mais il est possible de la copier-coller dans un projet afin de profiter de ses fonctionnalités :
           <ul>
           <li>accéder au fichier <a href="./resource/qx_persistable_hpp.html" target="_blank"><i>QxPersistable.hpp</i></a> ;</li>
           <li>accéder au fichier <a href="./resource/qx_persistable_cpp.html" target="_blank"><i>QxPersistable.cpp</i></a>.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_460">Persister des types personnalisés</a></p>
         <div class="manual_div_content">
           La bibliothèque QxOrm permet de persister n'importe quel type, même si ce dernier n'est pas enregistré dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           Il est nécessaire d'écrire les fonctions de sérialisation de la bibliothèque boost, en utilisant la méthode <b>non intrusive</b> (puisque le code source n'est pas disponible ou ne peut pas être modifié).
           Pour plus d'informations sur la sérialisation des données avec la bibliothèque boost, rendez-vous sur <a href="http://khayyam.developpez.com/articles/cpp/boost/serialization/" target="_blank">le tutoriel de developpez.com</a>.<br>
           <br>
           Par exemple, imaginons une classe '<i>ExtObject3D</i>' provenant d'une bibliothèque tierce et dont le code source n'est pas disponible ou ne peut pas être modifié.
           Voici le code nécessaire pour pouvoir persister une instance de type '<i>ExtObject3D</i>' en base de données :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Le code ci-dessus est suffisant pour persister une instance de type '<i>ExtObject3D</i>' en base de données : il est ainsi possible d'utiliser une propriété de type '<i>ExtObject3D</i>' dans une classe persistante enregistrée dans le contexte QxOrm.
           Cette propriété peut être mappée sur une colonne de type <i>TEXT</i> ou <i>VARCHAR</i> en base de données.<br>
           <br>
           Le comportement par défaut de la bibliothèque QxOrm est le suivant : l'instance est sérialisée au format XML avant d'être insérée ou mise à jour en base de données.
           Ce comportement par défaut peut être utile par exemple si l'on souhaite enregistrer une collection d'objets sans vouloir faire de relation (et donc gérer une autre table dans la base de données).
           Par exemple, si l'on utilise une propriété de type <i>std::vector&lt;mon_objet&gt;</i> dans une classe persistante sans relation associée, la liste d'éléments sera automatiquement enregistrée au format XML en base de données.<br>
           <br>
           <b>Remarque :</b> ce comportement par défaut peut être facilement modifié pour un type donné.
           Le moteur <i>QtSql</i> utilise le type <i>QVariant</i> pour faire le lien entre le code C++ et la base de données.
           Le type <i>QVariant</i> peut contenir du texte, des valeurs numériques, du binaire, etc.
           Il peut donc être intéressant de spécialiser le comportement par défaut (sérialisation XML) si l'on souhaite stocker des données au format binaire ou bien optimiser les performances (la sérialisation XML peut être couteuse en temps d'exécution).
           Il suffit de proposer (en plus des fonctions de sérialisation boost) les conversions nécessaires en <i>QVariant</i>, par exemple avec la classe '<i>ExtObject3D</i>' :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Ici je convertis ExtObject3D en QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Ici je convertis QVariant en ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_470">Générer le schéma DDL SQL de la base de données</a></p>
         <div class="manual_div_content">
           <a href="#manual_110"><b><font style="background-color:yellow">!!! Il est fortement recommandé d'utiliser l'application <b>QxEntityEditor</b> pour gérer cette problématique !!!</font></b></a><br>
           <br>
           La bibliothèque QxOrm ne fournit pas de mécanisme pour gérer automatiquement la création et mise à jour des tables dans la base de données.<br>
           En effet, la fonction <i>qx::dao::create_table&lt;T&gt;</i> doit être utilisée uniquement pour créer des prototypes.<br>
           Il est fortement recommandé d'utiliser un outil spécifique à chaque SGBD pour créer et maintenir les tables de la base de données (par exemple <i>Navicat</i> pour <i>MySql</i>, <i>pgAdmin</i> pour <i>PostgreSQL</i>, <i>SQLite Manager</i> pour <i>SQLite</i>, etc.).<br>
           De plus, un outil spécifique à chaque SGBD permet d'appliquer certaines optimisations (ajout d'index par exemple).<br>
           <br>
           Cependant, il peut être intéressant pour certaines applications de ne pas avoir à gérer manuellement les tables de la base de données.<br>
           Dans ce cas, il est possible de créer une fonction C++ pour parcourir la liste des classes persistantes enregistrées dans le contexte QxOrm (en utilisant le moteur d'introspection de la bibliothèque) et ainsi créer un script SQL de génération et mise à jour des tables de la base de données.<br>
           <br>
           La bibliothèque QxOrm fournit une fonction C++ créée uniquement à titre d'exemple : elle peut donc servir de base de travail pour créer sa propre fonction de génération de script SQL.<br>
           Cette fonction se trouve dans le fichier <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">./src/QxRegister/QxClassX.cpp</a></i> et se nomme <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">QString qx::QxClassX::dumpSqlSchema()</a></i>.<br>
           Elle génère un script SQL et le renvoie sous forme de <i>QString</i> : il est possible d'adapter cette fonction pour générer un fichier contenant le script SQL ou bien appliquer chaque instruction SQL directement au SGBD.<br>
           <br>
           Voici un exemple d'implémentation proposé par <a href="http://www.developpez.net/forums/u449556/dodobibi/" target="_blank">dodobibi</a> pour gérer une base <i>PostgreSQL</i> : cet exemple gère les évolutions futures de son application (ajout de colonnes dans une table existante, ajout d'index sur une colonne existante, etc.).<br>
           Au lancement de l'application, le numéro de version est indiqué de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QApplication app<span class="operator">(</span>argc<span class="operator">,</span> argv<span class="operator">);</span>
app<span class="operator">.</span>setProperty<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span><span class="comment"> // Version incrementée à chaque compilation et diffusion de l'application</span></pre>
           </td></tr></tbody></table>
           <br>
           Une table de la base de données permet de stocker le numéro de version courant.<br>
           Une classe persistante C++ est mappée sur cette table de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _DATABASE_VERSION_H_
#define _DATABASE_VERSION_H_
</span><span class="keyword"> 
class</span> MY_DLL_EXPORT DatabaseVersion<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
  QString name<span class="operator">;</span><span class="type">
  long</span> version<span class="operator">;
};</span>

QX_REGISTER_HPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _DATABASE_VERSION_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/DatabaseVersion.h"
#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>DatabaseVersion<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>version<span class="operator">,</span><span class="string"> "version"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Avec la classe <i>DatabaseVersion</i>, il est possible de vérifier si la version de la base de données est à jour.<br>
           C'est le rôle de la fonction <i>isDatabaseVersionOld()</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">bool</span> isDatabaseVersionOld<span class="operator">()
{</span>
  DatabaseVersion dbVersion<span class="operator">;</span>
  dbVersion<span class="operator">.</span>name<span class="operator"> =</span><span class="string"> "MyAppName"</span><span class="operator">;</span>
  QSqlError err<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="flow">
  if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="bool"> false</span><span class="operator">; }</span><span class="flow">
  return</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &lt;</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">());
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si au lancement de l'application, la fonction <i>isDatabaseVersionOld()</i> renvoie <i>true</i>, alors la mise à jour de la base de données est effectuée de la façon suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">void</span> updateDatabaseVersion<span class="operator">()
{</span><span class="flow">
  try</span><span class="operator">
  {</span><span class="type">
    int</span> domainVersion<span class="operator"> =</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">();</span><span class="comment">

    // On se connecte avec un utilisateur de la base de données qui a les droits de modifications du schéma
</span>    QSqlDatabase db<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getDatabaseCloned<span class="operator">();</span>
    db<span class="operator">.</span>setUserName<span class="operator">(</span><span class="string">"MyAdminLogin"</span><span class="operator">);</span>
    db<span class="operator">.</span>setPassword<span class="operator">(</span><span class="string">"MyAdminPassword"</span><span class="operator">);</span><span class="comment">

    // On s'assure que la session démarre une transaction et lève une exception à la moindre erreur
</span>    qx<span class="operator">::</span>QxSession session<span class="operator">(</span>db<span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">);</span><span class="comment">

    // On "fetch" la version de la base de données avec un verrou pour éviter les modifications concurrentes !
    // Si plusieurs utilisateurs lancent l'application en même temps et qu'une mise à jour
    // est nécessaire, le premier fera la mise à jour, et les autres seront en attente
</span>    DatabaseVersion dbVersion<span class="operator">;</span>
    session<span class="operator">.</span>fetchByQuery<span class="operator">(</span>qx_query<span class="operator">(</span><span class="string">"WHERE name='MyAppName' FOR UPDATE"</span><span class="operator">),</span> dbVersion<span class="operator">);</span><span class="comment">

    // Pour les autres utilisateurs, une fois le verrou levé, on vérifie si la mise à jour est toujours nécessaire
</span><span class="flow">    if</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &gt;=</span> domainVersion<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // On exécute chaque instruction SQL avec la variable "query"
</span>    QSqlQuery query<span class="operator">(</span>db<span class="operator">);</span><span class="comment">

    // On récupère toutes les classes persistantes C++ enregistrées dans le contexte QxOrm
</span>    qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> qx<span class="operator">::</span>IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
    if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // on récupère la liste des tables existantes dans la base (fonction de Qt)
</span>    QStringList tables<span class="operator"> =</span> db<span class="operator">.</span>tables<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span><span class="type">long</span> k<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> k<span class="operator"> &lt;</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span> k<span class="operator">++)
    {</span>
      qx<span class="operator">::</span>IxClass<span class="operator"> *</span> pClass<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>getByIndex<span class="operator">(</span>k<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (!</span> pClass<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes non persistantes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxParameter"</span><span class="operator">) ||</span> pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxService"</span><span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filtre les classes à jour : si la version de pClass est &lt;= à la version enregistrée dans la base, la mise à jour n'est pas nécessaire
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // On crée la table si elle n'existe pas, et on définit son propriétaire
</span><span class="flow">      if</span><span class="operator"> (!</span> tables<span class="operator">.</span>contains<span class="operator">(</span>pClass<span class="operator">-&gt;</span>getName<span class="operator">()))
      {</span>
        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ( ) WITH (OIDS = FALSE);"
                   "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " OWNER TO \"MyAdminLogin\";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
      }</span><span class="comment">

      // On ajoute les colonnes à la table si elles n'existent pas
</span>      qx<span class="operator">::</span>IxDataMemberX<span class="operator"> *</span> pDataMemberX<span class="operator"> =</span> pClass<span class="operator">-&gt;</span>getDataMemberX<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">; (</span>pDataMemberX<span class="operator"> &amp;&amp; (</span>l<span class="operator"> &lt;</span> pDataMemberX<span class="operator">-&gt;</span>count_WithDaoStrategy<span class="operator">()));</span> l<span class="operator">++)
      {</span>
        qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> pDataMemberX<span class="operator">-&gt;</span>get_WithDaoStrategy<span class="operator">(</span>l<span class="operator">);</span><span class="flow">
        if</span><span class="operator"> (!</span> p<span class="operator"> || (</span>p<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span>

        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getSqlType<span class="operator">() +</span><span class="string"> ";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getIsPrimaryKey<span class="operator">())</span><span class="comment"> // PRIMARY KEY
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD PRIMARY KEY ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAllPropertyBagKeys<span class="operator">().</span>contains<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">))</span><span class="comment"> // INDEX
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE INDEX "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_idx"</span><span class="operator"> +</span><span class="string"> 
                     " ON "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " USING "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getPropertyBag<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">).</span>toString<span class="operator">() +</span><span class="string"> " ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getNotNull<span class="operator">())</span><span class="comment"> // NOT NULL
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " SET NOT NULL;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAutoIncrement<span class="operator">())</span><span class="comment"> // AUTO INCREMENT
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE SEQUENCE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> " OWNER TO \"MyAdminLogin\"; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span><span class="string">
                     "SET DEFAULT nextval('"</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "'::regclass);"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getDescription<span class="operator">() !=</span><span class="string"> ""</span><span class="operator">)</span><span class="comment"> // DESCRIPTION
</span><span class="operator">        {</span><span class="comment">
          // $$ceci est un texte ne nécessitant pas de caractères d'échappement dans postgres grace aux doubles dolars$$
</span>          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"COMMENT ON COLUMN "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "."</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " IS $$"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span><span class="string"> "$$ ;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }
      }
    }</span><span class="comment">

    // On enregistre la version courante de la base de données
</span>    dbVersion<span class="operator">.</span>version<span class="operator"> =</span> domainVersion<span class="operator">;</span>
    session<span class="operator">.</span>save<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="comment">

    // Fin du block "try" : la session est détruite =&gt; commit ou rollback automatique
    // De plus, un commit ou rollback sur la transaction lève automatiquement le verrou posé précédemment
</span><span class="operator">  }</span><span class="flow">
  catch</span><span class="operator"> (</span><span class="keyword">const</span> qx<span class="operator">::</span>dao<span class="operator">::</span>sql_error<span class="operator"> &amp;</span> err<span class="operator">)
  {</span>
    QSqlError sqlError<span class="operator"> =</span> err<span class="operator">.</span>get<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>databaseText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>driverText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>number<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>type<span class="operator">();
  }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le code précédent (tout comme la fonction <a href="./resource/qxclassx_dump_sql_schema.html" target="_blank"><i>qx::QxClassX::dumpSqlSchema()</i></a>) peut être modifié pour s'adapter aux besoins spécifiques d'une application.<br>
           Par exemple, il pourrait être intéressant de créer par défaut une seconde table (en plus de la table <i>DatabaseVersion</i>) pour enregistrer la liste des classes persistantes enregistrées dans le contexte QxOrm : ainsi, au lieu d'utiliser la fonction proposée par Qt "<i>db.tables()</i>", il serait possible de récupérer toutes les tables mappées sur des classes persistantes avec des informations supplémentaires (numéro de version pour chaque table, nombre de colonnes enregistrées dans le contexte QxOrm, description de chaque table, etc.).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_475">Associer un type SQL à une classe C++</a></p>
         <div class="manual_div_content">
           Chaque base de données propose des types SQL différents pour stocker l'information.<br>
           La bibliothèque QxOrm propose une association par défaut pour les classes C++ les plus fréquemment utilisées dans un programme.<br>
           Voici cette association par défaut :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
           </td></tr></tbody></table>
           <br>
           Si le type SQL proposé par défaut par la bibliothèque QxOrm ne correspond pas à la base de données utilisée, il peut facilement être modifié (de manière globale à toute l'application) en utilisant la collection suivante :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QHash<span class="operator">&lt;</span>QString<span class="operator">,</span> QString<span class="operator">&gt; *</span> lstSqlType<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllSqlTypeByClassName<span class="operator">();</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"QString"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"std::string"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
// etc.</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour modifier le type SQL de manière spécifique pour une colonne d'une table de la base de données, il faut définir le type SQL dans la fonction de mapping de QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>MyClass<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span><span class="comment">
  //...
</span>  IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> MyClass<span class="operator">::</span>m_MyProperty<span class="operator">,</span><span class="string"> "my_property"</span><span class="operator">);</span>
  p<span class="operator">-&gt;</span>setSqlType<span class="operator">(</span><span class="string">"VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
  //...
</span><span class="operator">}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Pour les classes non supportées par défaut par la bibliothèque QxOrm (voir ce chapitre du manuel utilisateur : <i><a href="#manual_460">Persister des types personnalisés</a></i>), il est possible d'associer un type SQL par défaut en utilisant la macro suivante (en dehors de tout <i>namespace</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_TRAIT_GET_SQL_TYPE<span class="operator">(</span>MyClass<span class="operator">,</span><span class="string"> "my_sql_type"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_480">Effectuer des requêtes asynchrones à la base de données</a></p>
         <div class="manual_div_content">
           Il peut être parfois intéressant d'exécuter certaines requêtes à la base de données de manière asynchrone (multi-thread), par exemple pour éviter de bloquer une IHM si une requête est trop longue à s'exécuter.<br>
           Pour simplifier les requêtes asynchrones, la bibliothèque QxOrm fournit la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>.<br>
           Cette classe exécute une requête dans un thread dédié et renvoie un <i>SIGNAL</i> <i>queryFinished()</i> lorsque la requête est terminée.<br>
           Pour utiliser la classe <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i>, il suffit de :
           <ul>
           <li>vérifier que la requête fait appel à une classe qui implémente l'interface <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> ;</li>
           <li>créer une instance de type <i>qx::QxDaoAsync</i> (par exemple, une propriété membre d'une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>connecter un <i>SLOT</i> au <i>SIGNAL</i> <i>qx::QxDaoAsync::queryFinished()</i> (par exemple, un <i>SLOT</i> défini dans une classe dérivant du type <i>QWidget</i>) ;</li>
           <li>exécuter une requête à la base de données en utilisant l'une des méthodes commençant par <i>async</i> : <i>qx::QxDaoAsync::asyncXXXX()</i>.</li>
           </ul>
           Voici un exemple d'utilisation avec une classe nommée <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MyWidget<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">
{</span> Q_OBJECT<span class="comment">

   //...
</span>   qx<span class="operator">::</span>QxDaoAsync m_daoAsync<span class="operator">;</span><span class="comment">
   //...
</span>Q_SLOTS<span class="operator">:</span><span class="type">
   void</span> onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">);</span><span class="comment">
   //...

</span><span class="operator">};</span></pre>
           </td></tr></tbody></table>
           <br>
           Et voici l'implémentation de la classe <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>MyWidget<span class="operator">::</span>MyWidget<span class="operator">() :</span> QObject<span class="operator">()
{</span><span class="comment">
   //...
</span>   QObject<span class="operator">::</span>connect<span class="operator">((&amp;</span> m_daoAsync<span class="operator">),</span> SIGNAL<span class="operator">(</span>queryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)),</span><span class="keyword"> 
                    this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)));</span><span class="comment">
   //...
</span><span class="operator">}</span><span class="type">

void</span> MyWidget<span class="operator">::</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> pDaoParams<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>
   qx<span class="operator">::</span>QxSqlQuery query<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>query<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (!</span> daoError<span class="operator">.</span>isValid<span class="operator">()) { ; }</span><span class="comment">
   // If the async query is associated to a simple object, just use 'pDaoParams-&gt;pInstance' method
</span>   qx<span class="operator">::</span>IxPersistable_ptr ptr<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pInstance<span class="operator">;</span><span class="comment">
   // If the async query is associated to a list of objects, just use 'pDaoParams-&gt;pListOfInstances' method
</span>   qx<span class="operator">::</span>IxCollection_ptr lst<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pListOfInstances<span class="operator">;</span><span class="comment">
   //...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_490">Gestion du cache pour sauvegarder des instances C++ (module QxCache)</a></p>
         <div class="manual_div_content">
           Le cache proposé par la bibliothèque QxOrm (<a href="../doxygen/html/group___qx_cache.html" target="_blank">module <i>QxCache</i></a>) est <i>thread-safe</i> et permet de stocker facilement n'importe quel type de données.<br>
           Les fonctions pour accéder au cache se trouvent dans le <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>.<br>
           Le cache permet une optimisation du programme : il est possible par exemple de stocker des éléments issus d'une requête effectuée en base de données.<br>
           <br>
           Chaque élément stocké dans le cache est associé à une clé de type <i>QString</i> : cette clé permet de retrouver rapidement un élément du cache.<br>
           Si un nouvel élément est stocké dans le cache avec une clé qui existe déjà, alors l'ancien élément associé à cette clé est effacé automatiquement du cache.<br>
           <br>
           Le cache de la bibliothèque QxOrm ne gère pas la durée de vie des objets : il n'y a aucun <i>delete</i> effectué par le cache.<br>
           C'est pourquoi il est fortement recommandé (mais ce n'est pas une obligation) de privilégier le stockage de pointeurs intelligents : par exemple, <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" target="_blank"><i>boost::shared_ptr&lt;T&gt;</i></a> pour la bibliothèque <i>boost</i> ou bien <a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer&lt;T&gt;</i></a> pour la bibliothèque <i>Qt</i>.<br>
           <br>
           Le cache peut avoir un coût relatif maximum pour éviter une utilisation de la mémoire trop importante : chaque élément inséré dans le cache peut indiquer un coût représentant une estimation de sa taille mémoire (par exemple, le nombre d'éléments d'une collection).<br>
           Lorsque le coût maximum du cache est atteint, les premiers éléments insérés dans le cache sont supprimés (en respectant l'ordre d'insertion dans le cache) jusqu'à ce que la limite du cache ne soit plus dépassée.<br>
           <br>
           Il est possible d'associer à chaque élément du cache une date-heure d'insertion.<br>
           Si aucune date-heure n'est renseignée, alors la date-heure courante est prise en compte.<br>
           Ce mécanisme permet de vérifier si un élément stocké dans le cache nécessite une mise à jour ou non.<br>
           <br>
           Voici un exemple d'utilisation du cache de la bibliothèque QxOrm (fonctions du <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Défini le coût maximum du cache à 500
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>max_cost<span class="operator">(</span><span class="int">500</span><span class="operator">);</span><span class="comment">

// Récupère une liste de 'author' de la base de données
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author<span class="operator">&gt; &gt;</span> list_author<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_author<span class="operator">);</span><span class="comment">

// Insère la liste de 'author' dans le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">,</span> list_author<span class="operator">);</span><span class="comment">

// Récupère une liste de 'blog' de la base de données
</span>QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt;</span> list_blog<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_blog<span class="operator">);</span><span class="comment">

// Insère la liste de 'blog' dans le cache (coût = nombre de 'blog')
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">,</span> list_blog<span class="operator">.</span>count<span class="operator">());</span><span class="comment">

// Pointeur vers un objet de type 'comment'
</span>comment_ptr my_comment<span class="operator">;</span>
my_comment<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> comment<span class="operator">(</span><span class="int">50</span><span class="operator">));</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_comment<span class="operator">);</span><span class="comment">

// Insère le 'comment' dans le cache en précisant une date-heure d'insertion
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span><span class="int"> 1</span><span class="operator">,</span> my_comment<span class="operator">-&gt;</span>dateModif<span class="operator">());</span><span class="comment">

// Récupère la liste de 'blog' stockée dans le cache
</span>list_blog<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">&lt;</span> QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt; &gt;(</span><span class="string">"list_blog"</span><span class="operator">);</span><span class="comment">

// Récupère la liste de 'blog' sans préciser le type
</span>qx_bool bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">);</span><span class="comment">

// Supprime du cache la liste de 'author'
</span><span class="type">bool</span> bRemoveOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>remove<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">);</span><span class="comment">

// Compte le nombre d'éléments du cache
</span><span class="type">long</span> lCount<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>count<span class="operator">();</span><span class="comment">

// Récupère le coût actuel des éléments stockés dans le cache
</span><span class="type">long</span> lCurrentCost<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>current_cost<span class="operator">();</span><span class="comment">

// Vérifie qu'un élément associé à la clé "comment" existe dans le cache
</span><span class="type">bool</span> bExist<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>exist<span class="operator">(</span><span class="string">"comment"</span><span class="operator">);</span><span class="comment">

// Récupère le 'comment' stocké dans le cache avec sa date-heure d'insertion
</span>QDateTime dt<span class="operator">;</span>
bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span> dt<span class="operator">);</span><span class="comment">

// Vide le cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_500">Travailler avec plusieurs bases de données</a></p>
         <div class="manual_div_content">
            Dans le chapitre <a href="#manual_310">Connexion à la base de données</a>, nous avons vu comment paramétrer la connexion par défaut avec la classe singleton : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a>.
            La bibliothèque QxOrm étant basée sur le moteur <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> de Qt, elle utilise en interne la classe <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase</a> de Qt.
            Toutes les fonctions d'accès à la base de données (<a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">namespace qx::dao</a>, classe <a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a>, etc...) ont un paramètre optionnel : <b><i>QSqlDatabase * pDatabase = NULL</i></b> :
            <ul>
               <li>si la valeur de ce paramètre est à NULL (valeur par défaut) : alors la bibliothèque QxOrm utilise la classe  singleton <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a> pour se connecter à la base de données (avec gestion automatique du multi-threading) ;</li>
               <li>si la valeur est non nulle : alors la bibliothèque QxOrm utilise la connexion fournie par le pointeur <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank"><i>QSqlDatabase * pDatabase</i></a>.</li>
            </ul>
            Ce paramètre permet donc de gérer son propre pool de connexions à une ou plusieurs bases de données.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_510">Déclarer une classe abstraite dans le contexte QxOrm</a></p>
         <div class="manual_div_content">
           Une classe abstraite C++ (contenant au moins une méthode virtuelle pure) ne peut pas être mappée avec une table d'une base de données (puisqu'elle ne peut pas être instanciée).<br>
           Cependant, il peut être intéressant de définir une classe abstraite contenant une liste de propriétés utilisées par plusieurs objets persistants.<br>
           Un exemple de classe abstraite se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> de la distribution de QxOrm avec la classe <i>BaseClassTrigger</i>.<br>
           QxOrm propose le mécanisme suivant pour définir une classe abstraite dans le contexte QxOrm :
           <ul>
              <li>déclarer la classe avec la méthode '<i>void register_class</i>' comme n'importe qu'elle autre classe ;</li>
              <li>utiliser la macro <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> juste après la définition de la classe.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_520">Déclarer automatiquement les méta-propriétés de Qt (macro <i>Q_PROPERTY</i>)</a></p>
         <div class="manual_div_content">
           Toute classe héritant du type <i>QObject</i> peut déclarer ses propriétés avec la macro <i><a href="http://doc-snapshots.qt.io/4.8/properties.html" target="_blank">Q_PROPERTY</a></i> : les propriétés deviennent alors des méta-propriétés.
           Ce mécanisme permet au framework Qt de proposer un moteur d'introspection grâce au pré-compilateur <i>moc</i>.
           Les méta-propriétés peuvent alors être utilisées par exemple par le moteur <i>QML</i>, <i>QtScript</i>, etc.<br>
           <br>
           La bibliothèque <b>QxOrm</b> nécessite une déclaration de chacune des propriétés d'une classe dans la fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> afin de proposer l'ensemble de ses fonctionnalités (persistance des données, sérialisation XML, JSON et binaire, etc.).
           Il est possible de déclarer automatiquement dans le contexte QxOrm l'ensemble des méta-propriétés sans maintenir une fonction de mapping <i>void qx::register_class&lt;T&gt;()</i> : la macro <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> utilise le moteur d'introspection de Qt pour parcourir la liste des méta-propriétés.<br>
           <br>
           Voici un exemple d'utilisation avec la classe <i>TestQtProperty</i> se trouvant dans le dossier <i>./test/qxDllSample/dll1/include/</i> de la distribution QxOrm :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span></font><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
<font style="background-color:yellow">QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></font></pre>
           </td></tr></tbody></table>
           <br>
           Pour ceux qui ne souhaitent pas utiliser la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>, il est possible d'écrire à la place les quatre lignes de code suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> <font style="background-color:yellow">qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span></font> <span class="operator">}
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> le deuxième paramètre de la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i> permet d'indiquer la propriété qui servira de clé primaire dans la base de données.
           Si ce paramètre est vide, cela signifie que la classe ne possède pas de clé primaire ou bien que celle-ci est définie dans une classe de base.<br>
           <br>
           Toute propriété définie avec la macro <i>Q_PROPERTY</i> peut s'enregistrer dans le contexte QxOrm de deux manières différentes :<br>
           <b>1-</b> par la méthode classique : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> ou bien sans mentionner le pointeur vers la donnée membre de la classe : <i>t.data("my_property", 0);</i><br>
           <br>
           Peu importe la méthode d'enregistrement des propriétés dans le contexte QxOrm, elles seront accessibles par la même interface <i><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i> et proposent donc les mêmes fonctionnalités.
           Il est possible d'utiliser les deux méthodes dans une même fonction de mapping <i>void qx::register_class&lt;T&gt;()</i>.
           Chaque méthode d'enregistrement présente des avantages et inconvénients.<br>
           <br>
           Voici la liste des avantages de la deuxième méthode d'enregistrement des propriétés dans le contexte QxOrm :
           <ul>
             <li>temps de compilation du projet beaucoup plus rapide ;</li>
             <li>taille de l'exécutable généré plus petite ;</li>
             <li>forte intégration avec le moteur d'introspection du framework Qt ;</li>
             <li>pas besoin de maintenir la fonction de mapping en utilisant la macro <i>QX_REGISTER_ALL_QT_PROPERTIES</i>.</li>
           </ul>
           Voici les inconvénients par rapport à la méthode classique d'enregistrement des propriétés :
           <ul>
             <li>nécessite un héritage de la classe <i>QObject</i> pour pouvoir utiliser la macro <i>Q_PROPERTY</i> ;</li>
             <li>exécution du programme plus lente (utilisation du type <i>QVariant</i> à la place des <i>template</i> C++) ;</li>
             <li>ne supporte pas la notion de relation entre tables de la base de données (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> et <i>many-to-many</i>) ;</li>
             <li>pas d'accès au pointeur sur la donnée membre de la classe (conversion nécessaire au type <i>QVariant</i> pour accéder et modifier une valeur).</li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_60">Sérialisation</a></p>
      <div class="manual_div_content_1">
         La <b>sérialisation</b> est un mécanisme permettant de sauvegarder l'état d'une instance d'objet dans un flux (fichier, réseau, etc...) sous un certain format (binaire, XML, JSON, texte, etc...).
         La <b>désérialisation</b> est le processus inverse permettant de restaurer l'état d'un objet à partir d'un flux.
         Pour plus d'informations sur la notion de sérialisation : <a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">rendez-vous sur la page Wikipedia</a>.
         <br><br>
         Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée dans différents formats :
         <ul>
            <li><a href="#manual_600">format binaire avec le moteur QDataStream de Qt</a> ;</li>
            <li><a href="#manual_606">format JSON avec le moteur QJson de Qt</a> ;</li>
            <li><a href="#manual_610">format XML avec le moteur boost::serialization</a> ;</li>
            <li><a href="#manual_620">format binaire avec le moteur boost::serialization</a> ;</li>
            <li><a href="#manual_630">d'autres formats proposés par le moteur boost::serialization</a>.</li>
         </ul>
         <b>Remarque :</b> le moteur de sérialisation de la bibliothèque QxOrm permet de proposer des fonctionnalités supplémentaires comme <a href="#manual_640">le clonage d'entités</a>, <a href="#manual_650">le dump d'entités (format XML ou JSON)</a> ou encore <a href="#manual_80">le module QxService</a>.
         <br><br>
         <b>Autre remarque :</b> par défaut, toutes les propriétés enregistrées dans le contexte QxOrm sont sérialisables. Pour supprimer une propriété du moteur de sérialisation, il est possible d'écrire :<br>
         <br>
         <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setSerialize<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
         </td></tr></tbody></table>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_605">N° version pour assurer une compatibilité ascendante</a></p>
         <div class="manual_div_content">
            La compatibilité ascendante permet à une application de pouvoir désérialiser un flux provenant d'une version antérieure.
            La bibliothèque QxOrm impose un numéro de version par classe ainsi qu'un numéro de version pour chaque propriété enregistrée dans le contexte QxOrm afin de pouvoir assurer une compatibilité ascendante automatiquement.
            <br><br>
            Par exemple, imaginons une classe <i>person</i> créée dans <b>une application en version A</b> : nous renseignons dans la macro <i>QX_REGISTER_HPP</i> une n° de version à 0 (correspond à la 1ère version de notre classe <i>person</i>), ainsi qu'un n° de version à 0 pour chacune des propriétés de la classe (si paramètre non renseigné, 0 est la valeur par défaut).
            Ce qui donne le résultat suivant :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">)</span>

<span class="pre">#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Dans la version B de notre application</b>, nous modifions la classe <i>person</i> pour ajouter 2 nouvelles propriétés : <i>sex</i> et <i>address</i>. Notre classe ayant évoluée, il faut donc incrémenter son n° de version, et les nouvelles propriétés doivent avoir un n° de version à 1, ce qui donne :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>
   <font style="background-color:yellow">QString sex<span class="operator">;</span></font>
   <font style="background-color:yellow">QString address<span class="operator">;</span></font>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 1</font></span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>address<span class="operator">,</span><span class="string"> "address"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> en procédant ainsi, la bibliothèque QxOrm peut sérialiser une instance de la classe <i>person</i> dans une application en version A, puis désérialiser à partir de ce flux issu de la version A afin de recréer une instance de la classe <i>person</i> dans une version B de l'application.
            <br><br>
            <b>Autre remarque :</b> la suppression d'une propriété casse la compatibilité ascendante.
            Il est donc recommandé de ne jamais supprimer de propriété pour utiliser le moteur de sérialisation : il est possible par exemple de mettre une visibilité à <i>private</i> et de supprimer les accesseurs <i>get/set</i>, la propriété devenant ainsi inaccessible à l'extérieur de la classe, elle peut alors être considérée comme étant obsolète.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_600">Moteur QDataStream de Qt</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">le moteur QDataStream de Qt</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">namespace qx::serialization::qt</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_byte_array()</a> : sérialise une instance C++ (dont le type est enregistré dans le contexte QxOrm) en flux binaire de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_byte_array()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_string()</a> : même sérialisation que la fonction <i>to_byte_array()</i> + conversion en base 64 de type <a href="http://doc.qt.io/qt-5/qstring.html" target="_blank">QString</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_string()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé en base 64 ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file()</a> : sérialisation binaire d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file()</a> : restauration d'une instance C++ à partir d'un fichier contenant le flux binaire sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file_compressed()</a> : sérialisation binaire d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier compressé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file_compressed()</a> : restauration d'une instance C++ à partir d'un fichier compressé contenant le flux binaire sérialisé.</li>
            </ul>
            <b>Remarque :</b> la sérialisation <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> est portable (sérialisation/désérialisation compatible sur tous types d'environnement : Windows, Linux, Mac OS X, etc...).
            Le flux sérialisé est au format binaire : la taille du flux est donc réduite (comparé à un flux XML par exemple).
            La sérialisation <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> étant basée sur le moteur d'introspection de la bibliothèque QxOrm, elle est moins performante que les sérialisations basées sur le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a>.
            <br><br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt QDataStream serialization">
<pre><span class="comment">   // Fetch a drug with id '3' in a new variable
   // drug is a C++ class registered in QxOrm context
</span>   drug d<span class="operator">;</span>
   d<span class="operator">.</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span><span class="comment">

   // Serialize the drug to a file
</span>   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>to_file<span class="operator">(</span>d<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Import drug from file in a new instance
</span>   drug d2<span class="operator">;</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>from_file<span class="operator">(</span>d2<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Check if d == d2
</span>   qAssert<span class="operator">(</span>d<span class="operator"> ==</span> d2<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> dans l'exemple ci-dessus, nous sérialisons une instance C++.
            Toutes les fonctions du namespace <a href="../doxygen/html/namespaceqx_1_1serialization.html" target="_blank">qx::serialization</a> peuvent également sérialiser des listes d'instances C++.
            Pour connaitre la liste des collections supportées, rendez-vous dans le chapitre : <a href="#manual_390">Collections supportées par QxOrm</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_606">Moteur JSON de Qt</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://doc.qt.io/qt-5/json.html" target="_blank">le moteur QJson de Qt</a> (nécessite Qt5).
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">namespace qx::serialization::json</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_string()</a> : sérialise une instance C++ au format JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_string()</a> : restaure une instance C++ à partir d'un flux JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file()</a> : sérialisation JSON d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file()</a> : restauration d'une instance C++ à partir d'un fichier contenant le flux JSON sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file_compressed()</a> : sérialisation JSON d'une instance C++ (dont le type est enregistré dans le contexte QxOrm) dans un fichier compressé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file_compressed()</a> : restauration d'une instance C++ à partir d'un fichier compressé contenant le flux JSON sérialisé ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_byte_array()</a> : sérialise une instance C++ (dont le type est enregistré dans le contexte QxOrm) en flux binaire de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_byte_array()</a> : restaure une instance C++ en fonction d'un flux binaire sérialisé de type <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a>.</li>
            </ul>
            <b>Remarque :</b> le moteur de sérialisation <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> est le plus permissif (comparé au <a href="#manual_610">moteur XML</a> par exemple) : en effet, les propriétés d'une instance peuvent être définies dans n'importe quel ordre, les propriétés peuvent être supprimées ou ajoutées.
            La désérialisation JSON ne retourne jamais d'erreur : elle ignore tout si le format des données est incorrect (le flux JSON doit par contre être valide) ou bien si des propriétés sont absentes : le moteur JSON est donc beaucoup plus flexible que <a href="#manual_610">le moteur XML</a>.
            <br><br>
            <b>Autre remarque :</b> la sérialisation <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> est basée sur le moteur d'introspection de la bibliothèque QxOrm, elle est moins performante que les sérialisations basées sur le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a>.
            <br><br>
            <b>Par exemple :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">   // Fetch a list of authors from database and serialize them to a JSON file
</span>   list_author list_of_author<span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_of_author<span class="operator">);</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>json<span class="operator">::</span>to_file<span class="operator">(</span>list_of_author<span class="operator">,</span><span class="string"> "list_of_author.json"</span><span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            L'exemple ci-dessus génère le flux JSON suivant :<br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
{
    "author_id_2": {
        "author_id": "author_id_2",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_2",
        "sex": 1
    },
    "author_id_3": {
        "author_id": "author_id_3",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_3",
        "sex": 1
    }
}
</pre>
            </div>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_610">Moteur XML de boost::serialization</a></p>
         <div class="manual_div_content">
            Le moteur XML de <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> n'est pas activé par défaut : pour activer cette fonctionnalité, il est nécessaire de définir les options de compilation <b>_QX_ENABLE_BOOST_SERIALIZATION</b> et <b>_QX_ENABLE_BOOST_SERIALIZATION_XML</b> dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            Il est également nécessaire de compiler le binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> (ce module de boost n'étant pas <i>header only</i>), et de renseigner le chemin d'accès à ce binaire dans les variables <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> et <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> du <a href="#manual_220">fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            <br><br>
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">le moteur XML de boost::serialization</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">namespace qx::serialization::xml</a> (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>).
            <br><br>
            Ce type de sérialisation possède les caractéristiques suivantes :
            <ul>
               <li><i>portable</i> : compatible sur tous types d'environnement : Windows, Linux, Mac OS X, etc... ;</li>
               <li><i>slowest</i> : plus lente que les sérialisations <i>binary</i> et <i>text</i> ;</li>
               <li><i>largest</i> : taille des flux générés plus importante que les sérialisations <i>binary</i> et <i>text</i> ;</li>
               <li><i>human-readable</i> : un flux XML peut facilement être analysé et lu par un éditeur externe ou un être humain.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_620">Moteur binaire de boost::serialization</a></p>
         <div class="manual_div_content">
            Le moteur binaire de <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> n'est pas activé par défaut : pour activer cette fonctionnalité, il est nécessaire de définir les options de compilation <b>_QX_ENABLE_BOOST_SERIALIZATION</b> et <b>_QX_ENABLE_BOOST_SERIALIZATION_BINARY</b> dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            Il est également nécessaire de compiler le binaire <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> (ce module de boost n'étant pas <i>header only</i>), et de renseigner le chemin d'accès à ce binaire dans les variables <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> et <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> du <a href="#manual_220">fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a>.
            <br><br>
            Toute classe C++ enregistrée dans le contexte QxOrm peut être sérialisée en utilisant <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">le moteur binaire de boost::serialization</a>.
            Les fonctions pour utiliser ce type de sérialisation sont disponibles dans l'espace de nom : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">namespace qx::serialization::binary</a> (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>).
            <br><br>
            Ce type de sérialisation possède les caractéristiques suivantes :
            <ul>
               <li><i>non-portable</i> : un flux sérialisé sur un environnement Windows peut être incompatible si désérialisation sur un environnement Linux par exemple : il est donc fortement recommandé de rester sur le même environnement ;</li>
               <li><i>fastest</i> : plus rapide que les sérialisations <i>XML</i> et <i>text</i> ;</li>
               <li><i>smallest</i> : taille des flux générés réduite comparé aux sérialisations <i>XML</i> et <i>text</i> ;</li>
               <li><i>non-human-readable</i> : un flux binaire n'est pas lisible (pas de log possible par exemple).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_630">Autres types de sérialisation proposés par boost</a></p>
         <div class="manual_div_content">
            Le moteur <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> propose d'autres types de sérialisation.
            Ces différents types ne sont pas activés par défaut, pour utiliser ces fonctionnalités (mêmes fonctions que dans <a href="#manual_600">l'espace de nom qx::serialization::qt</a>), il est nécessaire de définir les options de compilation suivantes dans <a href="#manual_220">le fichier de configuration QxOrm.pri (ou QxOrm.cmake)</a> :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_POLYMORPHIC :</b> active les fonctions des espaces de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__binary.html" target="_blank">qx::serialization::polymorphic_binary</a>, <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__xml.html" target="_blank">qx::serialization::polymorphic_xml</a> et <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__text.html" target="_blank">qx::serialization::polymorphic_text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_TEXT :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1text.html" target="_blank">qx::serialization::text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_PORTABLE_BINARY :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1portable__binary.html" target="_blank">qx::serialization::portable_binary</a> (non supporté officiellement par la bibliothèque boost) ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_BINARY :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1binary.html" target="_blank">qx::serialization::wide::binary</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_TEXT :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1text.html" target="_blank">qx::serialization::wide::text</a> ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_XML :</b> active les fonctions de l'espace de nom <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1xml.html" target="_blank">qx::serialization::wide::xml</a>.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_640">Cloner une instance C++</a></p>
         <div class="manual_div_content">
            Toute classe C++ enregistrée dans le contexte QxOrm peut être clonée en utilisant une des fonctions suivantes :
            <ul>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>qx_shared_ptr&lt;T&gt;</i> (par défaut type égal à <i>boost::shared_ptr&lt;T&gt;</i>, si C++11 activé alors type égal à <i>std::shared_ptr&lt;T&gt;</i>) ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_boost_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>boost::shared_ptr&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_qt_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>QSharedPointer&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_std_shared_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> de type <i>std::shared_ptr&lt;T&gt;</i> ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_nude_ptr&lt;T&gt;(const T & t) :</a> création d'une nouvelle instance identique à <i>t</i> sous forme de pointeur nu : attention à libérer la mémoire (<i>delete</i>) une fois l'utilisation du pointeur nu terminée (afin d'éviter des fuites mémoire).</li>
            </ul>
            <b>Par exemple :</b>
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone">
<pre>   drug_ptr d1<span class="operator">;</span>
   d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span>
   d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span><span class="comment">

   // Clone a drug
</span>   <font style="background-color:yellow">drug_ptr d_clone<span class="operator"> =</span> qx<span class="operator">::</span>clone<span class="operator">(*</span> d1<span class="operator">);</span></font><span class="comment">

   // Check if (d1 == d_clone)
</span>   qAssert<span class="operator">((*</span> d1<span class="operator">) == (*</span> d_clone<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque importante :</b> il faut faire attention lorsqu'on clone un pointeur intelligent (<i>boost::shared_ptr</i> ou <i>QSharedPointer</i> par exemple) dont l'élément parent (<i>root</i>) peut être référencé plusieurs fois dans sa hiérarchie (cas d'une structure en arbre par exemple).
            Dans ce cas, afin de protéger le pointeur parent d'une double suppression (2 pointeurs intelligents qui pointent sur le même pointeur brut), il est conseillé de cloner de cette façon :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone smart-pointer">
<pre><span class="comment">// 'pOther' type is boost::shared_ptr&lt;myClass&gt; (smart-pointer)
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt; *</span> pCloneTemp<span class="operator"> =</span> qx<span class="operator">::</span>clone_to_nude_ptr<span class="operator">(</span>pOther<span class="operator">);</span>
boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;</span> pClone<span class="operator"> = (</span>pCloneTemp<span class="operator"> ? (*</span> pCloneTemp<span class="operator">) :</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;());</span><span class="flow">
if</span><span class="operator"> (</span>pCloneTemp<span class="operator">) {</span><span class="keyword"> delete</span> pCloneTemp<span class="operator">;</span> pCloneTemp<span class="operator"> =</span> NULL<span class="operator">; }</span><span class="comment">
// Now use 'pClone' ...</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_650">Afficher le détail d'une instance C++ (dump au format XML ou JSON)</a></p>
         <div class="manual_div_content">
            Toute instance C++ enregistrée dans le contexte QxOrm peut être affichée <a href="#manual_606">au format JSON</a>.
            Si le <a href="#manual_610">moteur XML de boost::serialization</a> est activé, alors il est également possible d'afficher un dump sous format XML (paramètre d'entrée de la fonction <i>qx::dump</i>).
            Cette fonctionnalité peut être utile pour faire du débogage par exemple, ou bien pour générer des logs.
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::dump">
<pre>   blog_ptr b<span class="operator">;</span>
   b<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   b<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_all_relation<span class="operator">(</span>b<span class="operator">);</span><span class="comment">

   // Dump 'b' instance result from database (XML or JSON serialization)
   // Second parameter is optional : 'true' = JSON format, 'false' = XML format
</span>   <font style="background-color:yellow">qx<span class="operator">::</span>dump<span class="operator">(</span>b, false<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui génère le flux XML suivant :
            <br><br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
[QxOrm] start dump 'boost::shared_ptr&lt;blog&gt;'
&lt;boost.shared_ptr-blog- class_id="0" tracking_level="0" version="1"&gt;
	&lt;px class_id="1" tracking_level="1" version="0" object_id="_0"&gt;
		&lt;blog_id&gt;113&lt;/blog_id&gt;
		&lt;blog_text class_id="2" tracking_level="0" version="0"&gt;update blog_text_1&lt;/blog_text&gt;
		&lt;date_creation class_id="3" tracking_level="0" version="0"&gt;20100409162612000&lt;/date_creation&gt;
		&lt;author_id class_id="4" tracking_level="0" version="1"&gt;
			&lt;px class_id="5" tracking_level="1" version="0" object_id="_1"&gt;
				&lt;author_id&gt;author_id_2&lt;/author_id&gt;
				&lt;name&gt;author_2&lt;/name&gt;
				&lt;birthdate class_id="6" tracking_level="0" version="0"&gt;20100409&lt;/birthdate&gt;
				&lt;sex&gt;1&lt;/sex&gt;
				&lt;list_blog class_id="7" tracking_level="0" version="0"&gt;
					&lt;count&gt;0&lt;/count&gt;
					&lt;item_version&gt;1&lt;/item_version&gt;
				&lt;/list_blog&gt;
			&lt;/px&gt;
		&lt;/author_id&gt;
		&lt;list_comment class_id="8" tracking_level="0" version="0"&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="9" tracking_level="0" version="1"&gt;
				&lt;px class_id="10" tracking_level="1" version="0" object_id="_2"&gt;
					&lt;comment_id&gt;209&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_1 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_3"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category class_id="11" tracking_level="0" version="0"&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;px class_id_reference="10" object_id="_4"&gt;
					&lt;comment_id&gt;210&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_2 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_5"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
		&lt;/list_comment&gt;
		&lt;list_category&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="12" tracking_level="0" version="0"&gt;
				&lt;first&gt;355&lt;/first&gt;
				&lt;second class_id="13" tracking_level="0" version="0"&gt;
					&lt;qt_shared_ptr class_id="14" tracking_level="1" version="0" object_id="_6"&gt;
						&lt;category_id&gt;355&lt;/category_id&gt;
						&lt;name&gt;category_1&lt;/name&gt;
						&lt;description&gt;desc_1&lt;/description&gt;
						&lt;list_blog class_id="15" tracking_level="0" version="0"&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;first&gt;357&lt;/first&gt;
				&lt;second&gt;
					&lt;qt_shared_ptr class_id_reference="14" object_id="_7"&gt;
						&lt;category_id&gt;357&lt;/category_id&gt;
						&lt;name&gt;category_3&lt;/name&gt;
						&lt;description&gt;desc_3&lt;/description&gt;
						&lt;list_blog&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
		&lt;/list_category&gt;
	&lt;/px&gt;
&lt;/boost.shared_ptr-blog-&gt;
[QxOrm] end dump 'boost::shared_ptr&lt;blog&gt;'
</pre>
            </div>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_70">Introspection - Réflexion</a></p>
      <div class="manual_div_content_1">
           Toute classe enregistrée dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> peut être utilisée par le moteur d'introspection (ou réflexion) de la bibliothèque QxOrm.
           Le moteur d'introspection permet d'obtenir de façon dynamique (donc pendant l'exécution du programme) des informations propres à un type.
           Ces informations correspondent à des <i>méta-données</i> et décrivent de façon exhaustive les caractéristiques d'une classe (propriétés, méthodes, etc.).
           De nombreux langages de programmation (par exemple Java ou C#) intègrent nativement ce mécanisme, ce n'est pas le cas du C++, c'est pourquoi la bibliothèque QxOrm émule un moteur d'introspection.
           Pour plus de détails sur l'introspection (ou réflexion), <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" target="_blank">rendez-vous sur la page Wikipedia</a>.
           <br><br>
           Voici la liste des classes disponibles pour accéder aux <i>méta-données</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton permettant de parcourir l'ensemble des classes enregistrées dans le contexte QxOrm par la méthode <i>qx::register_class&lt;T&gt;()</i> ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface pour une classe enregistrée dans le contexte QxOrm ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : liste des propriétés associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface pour une propriété d'une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : liste des méthodes associées à une classe ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface pour une méthode d'une classe (<i>static</i> ou <i>non static</i>).</li>
           </ul>
           Une instance de type <a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank"><i>qx::IxClass</i></a> possède la liste des propriétés d'une classe (<a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank"><i>qx::IxDataMemberX</i></a>) ainsi que la liste des méthodes d'une classe (<a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank"><i>qx::IxFunctionX</i></a>).<br>
           <br>
           Le moteur d'introspection de la bibliothèque QxOrm permet par exemple de :
           <ul>
             <li><a href="#manual_740">créer dynamiquement une instance en fonction du nom d'une classe sous forme de chaîne de caractères (<i>qx::create()</i>)</a> ;</li>
             <li><a href="#manual_710">accéder/modifier le contenu d'un champ d'un objet de façon dynamique</a> en prenant pour paramètres un objet et le nom du champ qu'on souhaite accéder/modifier (<i>qx::IxDataMember::getValue()</i> et <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li><a href="#manual_730">invoquer une méthode de classe de façon dynamique</a>, en gérant bien entendu le passage des paramètres souhaités à la méthode (<i>qx::IxFunction::invoke()</i>) ;</li>
             <li><a href="#manual_750">accéder à la hiérarchie d'une classe (<i>qx::IxClass::getBaseClass()</i>)</a>.</li>
           </ul>
           <br>
           <b>Remarque :</b> le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> de la bibliothèque QxOrm (<a href="./tutorial_2.html" target="_blank">cliquez ici pour accéder au tutoriel</a>) permettant de créer un serveur d'applications C++ est basé sur le moteur d'introspection pour appeler dynamiquement les méthodes de type service (demande du client) sur le serveur, ainsi que pour créer dynamiquement les instances des classes de paramètre (entrée/sortie).<br>
           <br>
           <b>Autre remarque :</b> il est possible d'ajouter de nouvelles informations au moteur d'introspection en utilisant <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank">la notion de <i>property bag</i></a>.
           En effet, les classes <i>qx::IxClass</i>, <i>qx::IxDataMember</i> et <i>qx::IxFunction</i> possèdent chacune une liste d'éléments de type <i>QVariant</i> accessibles par clé de type <i>QString</i> (voir <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank">la classe <i>qx::QxPropertyBag</i></a> pour plus de détails sur cette notion).
           <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_710">Obtenir dynamiquement la valeur d'une donnée membre</a></p>
         <div class="manual_div_content">
            Pour obtenir dynamiquement la valeur d'une donnée membre en utilisant le moteur d'introspection de la bibliothèque QxOrm, il est nécessaire de passer par la classe : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a>.
            La classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> fournit plusieurs méthodes pour obtenir la valeur d'une donnée membre (chacune prenant en paramètre un pointeur générique de type <i>void *</i> correspondant à l'adresse de l'instance courante) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">toVariant()</a> : retourne la valeur de la donnée membre convertie en <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValue&lt;T&gt;()</a> : retourne la valeur avec son type réel précisé dans le paramètre template T ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValueAnyPtr()</a> : retourne la valeur encapsulée par le type <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any</a> (possibilité de caster ensuite en utilisant : <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any_cast</a>).</li>
            </ul>
            <b>Par exemple :</b> imaginons un pointeur générique de type <i>void *</i> vers une classe <i>person</i>. Nous pouvons obtenir la valeur de la propriété <i>firstName</i> de type <i>QString</i> de la façon suivante :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to get the data member value with the real type
</span>QString sFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">);</span><span class="comment">

// Second method to get the data member value converted in QVariant
</span>QVariant vFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>toVariant<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Third method to get the value encapsulated in boost::any type
</span>boost<span class="operator">::</span>any aFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValueAnyPtr<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Check if all values are equals
</span>qAssert<span class="operator">((</span>sFirstName<span class="operator"> ==</span> vFirstName<span class="operator">.</span>toString<span class="operator">()) &amp;&amp; (</span>sFirstName<span class="operator"> == (*</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span>QString<span class="operator"> *&gt;(</span>aFirstName<span class="operator">))));</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_720">Valoriser dynamiquement une donnée membre</a></p>
         <div class="manual_div_content">
            De la même façon que pour obtenir la valeur d'une donnée membre, la classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> permet de valoriser une donnée membre (modifier sa valeur).
            La classe <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> fournit les 2 méthodes suivantes (chacune prend en paramètre un pointeur de type <i>void *</i> correspondant à l'adresse de l'instance courante, ainsi que la nouvelle valeur à positionner) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">fromVariant()</a> : valorise la donnée membre en fonction du paramètre de type <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">setValue&lt;T&gt;()</a> : valorise la donnée membre avec un paramètre du type réel T de la donnée membre.</li>
            </ul>
            <b>Par exemple :</b> imaginons un pointeur générique de type <i>void *</i> vers une classe <i>person</i>. Nous pouvons modifier la valeur de la propriété <i>firstName</i> de type <i>QString</i> de la façon suivante :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to change the data member value
</span>QVariant vFirstName<span class="operator"> =</span> QVariant<span class="operator">(</span><span class="string">"my new firstname 1"</span><span class="operator">);</span>
pDataMember<span class="operator">-&gt;</span>fromVariant<span class="operator">(</span>p<span class="operator">,</span> vFirstName<span class="operator">);</span><span class="comment">

// Other method to change the data member value (using real type)
</span>QString sFirstName<span class="operator"> =</span><span class="string"> "other firstname 2"</span><span class="operator">;</span>
pDataMember<span class="operator">-&gt;</span>setValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">,</span> sFirstName<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_730">Appeler dynamiquement une fonction</a></p>
         <div class="manual_div_content">
            Tout comme les données membre (propriétés), il est possible d'enregistrer des méthodes membre (fonctions) dans le contexte QxOrm (support des méthodes <i>static</i> et <i>non static</i>).
            Le moteur d'introspection de la bibliothèque QxOrm permet d'invoquer dynamiquement des méthodes de classe.
            Toutes les fonctions enregistrées dans le contexte QxOrm sont associées à une instance de la classe : <a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a>.
            Pour enregistrer des méthodes dans le contexte QxOrm, il faut utiliser :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a> : enregistre une méthode de classe sans paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a> : enregistre une méthode de classe avec 1 paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_2()</a> : enregistre une méthode de classe avec 2 paramètres ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_X()</a> : le suffixe <i>X</i> correspondant au nombre de paramètres de la méthode de classe ;</li>
               <br>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_0()</a> : enregistre une méthode de classe <i>static</i> sans paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_1()</a> : enregistre une méthode de classe <i>static</i> avec 1 paramètre ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_2()</a> : enregistre une méthode de classe <i>static</i> avec 2 paramètres ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_X()</a> : le suffixe <i>X</i> correspondant au nombre de paramètres de la méthode de classe <i>static</i> ;</li>
            </ul>
            <b>Par exemple :</b> on souhaite enregistrer dans le contexte QxOrm plusieurs méthodes d'une classe <i>person</i> :
            <br><br>
            <i>* Fichier person.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span>

   <font style="background-color:yellow"><span class="type">long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="type">void</span> myMethodWith2Params<span class="operator">(</span><span class="type">int</span> param1<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> param2<span class="operator">);</span></font>

   <font style="background-color:yellow"><span class="keyword">static</span><span class="type"> double</span> myStaticMethodWith1Param<span class="operator">(</span><span class="type">long</span> param1<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier person.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  <font style="background-color:yellow">t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>getId<span class="operator">,</span><span class="string"> "getId"</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>fct_2<span class="operator">&lt;</span><span class="type">void</span><span class="operator">,</span><span class="type"> int</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;&gt;(&amp;</span> person<span class="operator">::</span>myMethodWith2Params<span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">);</span></font>

  <font style="background-color:yellow">t<span class="operator">.</span>fctStatic_1<span class="operator">&lt;</span><span class="type">double</span><span class="operator">,</span><span class="type"> long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>myStaticMethodWith1Param<span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Une fois enregistrées dans le contexte QxOrm, il est possible d'appeler dynamiquement ces fonctions avec les méthodes <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invoke()</a> et <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invokeStatic()</a> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre>   <span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">   void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

   // Call method 'long getId() const' and get return value
</span>   boost<span class="operator">::</span>any returnValue<span class="operator">;</span>
   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "getId"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> ""</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   long</span> lId<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a string (default separator for parameters is character '|')
   // This way to pass parameters to the function works only if parameters are numeric or string
   // If parameters are more complex, then you have to encapsulate parameters in a list of boost::any, as shown below
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> "36|my string param 2"</span><span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a list of boost::any : std::vector&lt;boost::any&gt;
</span>   std<span class="operator">::</span>vector<span class="operator">&lt;</span>boost<span class="operator">::</span>any<span class="operator">&gt;</span> lstParams<span class="operator">;</span><span class="type">
   int</span> iParam1<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>iParam1<span class="operator">);</span><span class="comment"> // Parameter at position 1
</span>   QString sParam2<span class="operator"> =</span><span class="string"> "my string param 2"</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>sParam2<span class="operator">);</span><span class="comment"> // Parameter at position 2
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span> lstParams<span class="operator">);</span><span class="comment">

   // Call static method 'myStaticMethodWith1Param' with 1 parameter and get return value
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invokeStatic<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">,</span><span class="string"> "19"</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   double</span> dValue<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_740">Créer une instance C++ dynamiquement</a></p>
         <div class="manual_div_content">
            Le moteur d'introspection de la bibliothèque QxOrm permet de créer dynamiquement des instances de classe (<a href="../doxygen/html/group___qx_factory.html" target="_blank">module QxFactory</a>, modèle de conception fabrique ou design pattern factory) avec les méthodes suivantes :
            <ul>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">boost::any</a> (contenant un pointeur intelligent de type <i>qx_shared_ptr</i>, alias de <i>boost::shared_ptr</i> par défaut) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_nude_ptr&lt;T&gt;(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme d'un pointeur nu de type <i>T *</i> (attention à libérer la mémoire de ce pointeur pour éviter les fuites mémoire) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_void_ptr(const QString & sKey)</a> : création d'une instance de type <i>sKey</i> sous la forme d'un pointeur nu de type <i>void *</i> (attention à libérer la mémoire de ce pointeur pour éviter les fuites mémoire).</li>
            </ul>
            <b>Par exemple :</b> <a href="#manual_80">le module QxService</a> de la bibliothèque QxOrm utilise ce mécanisme pour créer dynamiquement les instances de classe de service pour exécuter les routines côté serveur :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - factory">
<pre>   qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator"> *</span> ptr<span class="operator"> =</span> qx<span class="operator">::</span>create_nude_ptr<span class="operator">&lt;</span>qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">&gt;(</span>m_sServiceName<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_750">Parcourir la liste des classes/propriétés enregistrées dans le contexte QxOrm</a></p>
         <div class="manual_div_content">
           Voici un exemple d'utilisation du moteur d'introspection de la bibliothèque QxOrm : comment lister toutes les classes, propriétés et méthodes enregistrées dans le contexte QxOrm ?<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Si on utilise la méthode <i>qx::QxClassX::dumpAllClasses()</i> avec le <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a>, voici le résultat obtenu :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_80">Services : transférer la couche de données persistante sur le réseau (module QxService)</a></p>
      <div class="manual_div_content_1">
         Le module <a href="../doxygen/html/group___qx_service.html" target="_blank"><b>QxService</b></a> de la bibliothèque <b>QxOrm</b> permet de créer rapidement un <b>serveur d'applications C++</b> performant (notion de <i>services</i> avec <i>demande</i> du client et <i>réponse</i> du serveur).
         <font style="background-color:yellow"><b><a href="./tutorial_2.html">Un tutoriel est disponible sur le site QxOrm</a></b></font> afin de présenter un exemple d'utilisation du module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
         Le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> est basé sur <a href="#manual_70">le moteur d'introspection</a> ainsi que <a href="#manual_60">le moteur de sérialisation</a> de la bibliothèque QxOrm afin de transférer la couche de données persistante sur le réseau et exécuter automatiquement les routines côté serveur.
         <br><br>
         <b>Remarque :</b> pour activer le module <b>QxService</b>, il faut définir l'option de compilation <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> dans <a href="#manual_220">le fichier de configuration <i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>)</a>.
         Cette option de compilation ajoute une dépendance au binaire <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> fourni avec la bibliothèque Qt.
         <br><br>
         <b>Autre remarque :</b> l'application <b>QxEntityEditor</b> est livrée avec le plugin <i>QxEECppServicesExport</i> : ce plugin génère automatiquement le code source nécessaire pour transférer l'ensemble des entités d'un projet sur le réseau.
         Une liste de méthodes client/serveur est générée automatiquement :
         <ul>
            <li><i>count() :</i> requête client/serveur pour compter le nombre d'éléments (avec possibilité d'utiliser un filtre SQL) ;</li>
            <li><i>fetchById() :</i> requête client/serveur pour alimenter les propriétés d'une entité en fonction de son identifiant ;</li>
            <li><i>fetchAll() :</i> requête client/serveur pour alimenter les propriétés de toutes les entités d'une table ;</li>
            <li><i>fetchByQuery() :</i> requête client/serveur pour alimenter les propriétés des entités filtrées par une requête SQL ;</li>
            <li><i>insert() :</i> requête client/serveur pour insérer les données d'une entité ;</li>
            <li><i>update() :</i> requête client/serveur pour mettre à jour les données d'une entité ;</li>
            <li><i>save() :</i> requête client/serveur pour sauvegarder les données d'une entité (insertion ou mise à jour) ;</li>
            <li><i>deleteById() :</i> requête client/serveur pour supprimer une entité en fonction de son identifiant ;</li>
            <li><i>deleteAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée à une entité ;</li>
            <li><i>deleteByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL ;</li>
            <li><i>destroyById() :</i> requête client/serveur pour supprimer une entité en fonction de son identifiant (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>destroyAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée à une entité (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>destroyByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>executeQuery() :</i> requête client/serveur pour exécuter <a href="#manual_3610">une requête SQL personnalisée ou procédure stockée</a> ;</li>
            <li><i>exist() :</i> requête client/serveur pour tester l'existence d'une entité en fonction de son identifiant ;</li>
            <li><i>isValid() :</i> requête client/serveur pour tester la validité d'une entité (<a href="#manual_420">module QxValidator</a>).</li>
         </ul>
         Il est possible d'ajouter de nouveaux services ou de personnaliser les services générés automatiquement par l'application <b>QxEntityEditor</b>.
         <br><br>
         L'objectif de ce chapite est de présenter les concepts à mettre en oeuvre pour utiliser le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> :
         <ul>
            <li><a href="#manual_810">Définition des paramètres d'entrée/sortie d'un service (requête/réponse)</a> ;</li>
            <li><a href="#manual_820">Définition des fonctions publiées par un service</a> ;</li>
            <li><a href="#manual_825">Liste des options disponibles côté serveur</a> ;</li>
            <li><a href="#manual_826">Paramétrage de la connexion côté client</a> ;</li>
            <li><a href="#manual_830">Gestion de l'authentification dans un service</a> ;</li>
            <li><a href="#manual_840">Requêtes client/serveur asynchrones</a>.</li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_810">Paramètres d'entrée/sortie d'un service (requête/réponse)</a></p>
         <div class="manual_div_content">
            Chaque fonction publiée par un service dispose de paramètres d'entrée (demande du client) et de paramètres de sortie (réponse du serveur).
            Ces paramètres d'entrée/sortie doivent hériter de l'interface <a href="../doxygen/html/classqx_1_1service_1_1_ix_parameter" target="_blank">qx::service::IxParameter</a> et doivent être enregistrées dans le contexte QxOrm (par la fonction <i>void qx::register_class&lt;T&gt;</i>).
            <br><br>
            <b>Par exemple :</b> voici un exemple de paramètres d'entrée/sortie générés automatiquement par l'application <b>QxEntityEditor</b> basé sur la classe <i>blog</i> du <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a> :
            <br><br>
            <i>* Fichier blog.services.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_of_blog<span class="operator">;</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>list_of_blog<span class="operator">&gt;</span> list_of_blog_ptr<span class="operator">;</span><span class="comment">

/* -- Service Input Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_input<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_input<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_input<span class="operator">();</span><span class="type">

   long</span> id<span class="operator">;</span><span class="comment">                   //!&lt; Id to fetch or delete
</span>   blog_ptr instance<span class="operator">;</span><span class="comment">         //!&lt; Single instance to fetch, insert, update, delete or validate
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">     //!&lt; List of instances to fetch, insert, update, delete or validate
</span>   qx_query query<span class="operator">;</span><span class="comment">            //!&lt; Query to execute when fetching, updating or deleting
</span>   QStringList columns<span class="operator">;</span><span class="comment">       //!&lt; List of columns to fetch or update
</span>   QStringList relations<span class="operator">;</span><span class="comment">     //!&lt; List of relations to fetch
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt;</span> blog_input_ptr<span class="operator">;</span><span class="comment">

/* -- Service Output Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_output<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_output<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_output<span class="operator">();</span>

   blog_ptr instance<span class="operator">;</span><span class="comment">            //!&lt; Single instance from server
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">        //!&lt; List of instances from server
</span>   QSqlError error<span class="operator">;</span><span class="comment">              //!&lt; If a SQL error occurred, this output parameter is not empty
</span>   qx<span class="operator">::</span>QxInvalidValueX invalid<span class="operator">;</span><span class="comment">  //!&lt; Check if a single instance (or a list of instances) is valid
</span>   qx_query query<span class="operator">;</span><span class="comment">               //!&lt; Query which contains all results
</span><span class="type">   long</span> count<span class="operator">;</span><span class="comment">                   //!&lt; Count how many items in database using a query or not
</span>   qx_bool exist<span class="operator">;</span><span class="comment">                //!&lt; Check if a single instance (or a list of instances) exist in database
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt;</span> blog_output_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_output<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier blog.services.gen.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> services_blog_output<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>columns<span class="operator">,</span><span class="string"> "columns"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>relations<span class="operator">,</span><span class="string"> "relations"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>error<span class="operator">,</span><span class="string"> "error"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>invalid<span class="operator">,</span><span class="string"> "invalid"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>count<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>exist<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> comme on peut le constater sur l'exemple ci-dessus, les paramètres d'entrée/sortie peuvent contenir des types complexes (des collections, des pointeurs, etc...).
            Il est donc possible et très simple de transférer des structures complexes sur le réseau avec le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_820">Définir les fonctions publiées par un service</a></p>
         <div class="manual_div_content">
            Chaque service enregistré dans le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> publie une liste de fonctions accessibles côté client (requêtes client/serveur).
            Les services doivent hériter de la classe de base <a href="../doxygen/html/classqx_1_1service_1_1_qx_service.html" target="_blank">qx::service::QxService&lt;INPUT, OUTPUT&gt;</a> (les paramètres template <i>INPUT</i> et <i>OUTPUT</i> correspondant <a href="#manual_810">aux paramètres d'entrée/sortie</a>) et doivent être enregistrés dans le contexte QxOrm (par la fonction <i>void qx::register_class&lt;T&gt;</i>).
            <br><br>
            <b>Par exemple :</b> voici un exemple de service généré automatiquement par l'application <b>QxEntityEditor</b> basé sur la classe <i>blog</i> du <a href="./tutorial.html" target="_blank">tutoriel qxBlog</a> :
            <br><br>
            <i>* Fichier blog.services.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="comment">

/* -- Service Definition -- */</span>

<font style="background-color:yellow"><span class="keyword">typedef</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span> blog_input<span class="operator">,</span> blog_output<span class="operator"> &gt;</span> blog_base_class<span class="operator">;</span><span class="keyword">
class</span> QXBLOG_SERVICES_EXPORT blog_services<span class="operator"> :</span><span class="keyword"> public</span> blog_base_class</font><span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_services<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_services<span class="operator">();</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   void</span> fetchById_<span class="operator">();</span><span class="type">
   void</span> fetchAll_<span class="operator">();</span><span class="type">
   void</span> fetchByQuery_<span class="operator">();</span><span class="type">

   void</span> insert_<span class="operator">();</span><span class="type">
   void</span> update_<span class="operator">();</span><span class="type">
   void</span> save_<span class="operator">();</span><span class="type">
   void</span> deleteById_<span class="operator">();</span><span class="type">
   void</span> deleteAll_<span class="operator">();</span><span class="type">
   void</span> deleteByQuery_<span class="operator">();</span><span class="type">
   void</span> destroyById_<span class="operator">();</span><span class="type">
   void</span> destroyAll_<span class="operator">();</span><span class="type">
   void</span> destroyByQuery_<span class="operator">();</span><span class="type">

   void</span> executeQuery_<span class="operator">();</span><span class="type">
   void</span> callQuery_<span class="operator">();</span><span class="type">
   void</span> exist_<span class="operator">();</span><span class="type">
   void</span> count_<span class="operator">();</span><span class="type">
   void</span> isValid_<span class="operator">();</span><span class="pre">

#ifdef _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="keyword">
public</span><span class="operator">:</span>

   blog_ptr fetchById<span class="operator">(</span><span class="type">long</span> id<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchAll<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span>
                                      <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError insert<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError insert<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError deleteById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError deleteAll<span class="operator">();</span>
   QSqlError deleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError destroyAll<span class="operator">();</span>
   QSqlError destroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>

   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError callQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError count<span class="operator">(</span><span class="type">long</span><span class="operator"> &amp;</span> lCount<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">());</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span><span class="pre">

#endif // _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt;</span> blog_services_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_services<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier blog.services.gen.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> services_blog_services<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span>

<font style="background-color:yellow"><span class="keyword">template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchById_<span class="operator">,</span><span class="string"> "fetchById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchAll_<span class="operator">,</span><span class="string"> "fetchAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchByQuery_<span class="operator">,</span><span class="string"> "fetchByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>insert_<span class="operator">,</span><span class="string"> "insert"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>update_<span class="operator">,</span><span class="string"> "update"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>save_<span class="operator">,</span><span class="string"> "save"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteById_<span class="operator">,</span><span class="string"> "deleteById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteAll_<span class="operator">,</span><span class="string"> "deleteAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteByQuery_<span class="operator">,</span><span class="string"> "deleteByQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyById_<span class="operator">,</span><span class="string"> "destroyById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyAll_<span class="operator">,</span><span class="string"> "destroyAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyByQuery_<span class="operator">,</span><span class="string"> "destroyByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>executeQuery_<span class="operator">,</span><span class="string"> "executeQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>callQuery_<span class="operator">,</span><span class="string"> "callQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>exist_<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>count_<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>isValid_<span class="operator">,</span><span class="string"> "isValid"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx

// Then there is the implementation of all functions provided by the service...</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> une fois définies dans le contexte QxOrm, le client peut appeler les fonctions publiées par le service : les routines côté serveur sont alors exécutées automatiquement.
            La sérialisation des données ainsi que la gestion de la couche réseau pour le transfert des données sont gérées de manière transparente par le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_825">Liste des options disponibles côté serveur</a></p>
         <div class="manual_div_content">
            Le serveur d'application C++ basé sur le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> dispose de plusieurs paramètres accessibles par la classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> :
            <ul>
               <li><i>setPort() :</i> port d'écoute pour recevoir les requêtes du client et envoyer les réponses du serveur ;</li>
               <li><i>setThreadCount() :</i> nombre de threads disponibles côté serveur pour traiter les demandes du client ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">type de sérialisation</a> utilisé pour envoyer les réponses du serveur ;</li>
               <li><i>setCompressData() :</i> permet de définir si les données renvoyées par le serveur sont compressées ou non ;</li>
               <li><i>setEncryptData() :</i> permet de définir si les données renvoyées par le serveur sont cryptées ou non (avec possibilité de renseigner une clé de cryptage).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_826">Paramétrage de la connexion côté client</a></p>
         <div class="manual_div_content">
            La couche cliente basée sur le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> dispose de plusieurs paramètres accessibles par la classe singleton <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> :
            <ul>
               <li><i>setIp() :</i> adresse IP du serveur d'application C++ ;</li>
               <li><i>setPort() :</i> port utilisé par le serveur d'application C++ ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">type de sérialisation</a> utilisé par la couche cliente pour envoyer les requêtes du client au serveur ;</li>
               <li><i>setCompressData() :</i> permet de définir si les données envoyées au serveur sont compressées ou non ;</li>
               <li><i>setEncryptData() :</i> permet de définir si les données envoyées au serveur sont cryptées ou non (avec possibilité de renseigner une clé de cryptage).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_830">Gestion de l'authentification dans un service</a></p>
         <div class="manual_div_content">
            Il est classique d'implémenter un contrôle au niveau du serveur pour vérifier l'utilisateur connecté à la couche cliente.
            L'interface <a href="../doxygen/html/classqx_1_1service_1_1_ix_service.html" target="_blank">qx::service::IxService</a> (classe de base de tous les services enregistrés par le module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a>) fournit des méthodes virtuelles qui peuvent être surchargées pour gérer cette problématique :
            <ul>
               <li><i>onBeforeProcess() :</i> méthode virtuelle appelée systématiquement avant exécution de la routine serveur ;</li>
               <li><i>onAfterProcess() :</i> méthode virtuelle appelée systématiquement après exécution de la routine serveur.</li>
            </ul>
            <br>
            <b>Par exemple :</b> voici une classe de base nommée <i>ParameterAuthentication</i> qui peut être utilisée par tous les paramètres d'entrée/sortie, cette classe fournit 3 propriétés <i>login</i>, <i>password</i> et <i>token</i> :
            <br><br>
            <i>* Fichier ParameterAuthentication.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MY_DLL_EXPORT ParameterAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ParameterAuthentication<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ParameterAuthentication<span class="operator">();</span>
 
   QString login<span class="operator">;</span>
   QString password<span class="operator">;</span>
   QString token<span class="operator">;</span><span class="comment">
   // etc..., put here all properties required by the authentication process
</span><span class="operator"> 
};</span><span class="keyword">
 
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt;</span> ParameterAuthentication_ptr<span class="operator">;</span>
 
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> ParameterAuthentication<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* Fichier ParameterAuthentication.cpp :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> ParameterAuthentication<span class="operator">)</span><span class="keyword">
 
namespace</span> qx<span class="operator"> {</span><span class="keyword">
 
template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>login<span class="operator">,</span><span class="string"> "login"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>password<span class="operator">,</span><span class="string"> "password"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>token<span class="operator">,</span><span class="string"> "token"</span><span class="operator">);
}
 
}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Maintenant que l'on dispose d'une classe de base pour nos paramètres (<i>ParameterAuthentication</i>), nous allons créer une classe de base utilisée par tous nos services nommée <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i>.
            Cette classe de base des services va surcharger la méthode virtuelle <i>onBeforeProcess()</i> afin de gérer l'authentification avant exécution de la routine serveur :
            <br><br>
            <i>* Fichier ServiceAuthentication.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "ParameterAuthentication.h"
</span><span class="keyword"> 
template</span><span class="operator"> &lt;</span><span class="keyword">class</span> INPUT<span class="operator">,</span><span class="keyword"> class</span> OUTPUT<span class="operator">&gt;</span><span class="keyword">
class</span> ServiceAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ServiceAuthentication<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> sServiceName<span class="operator">) :</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;(</span>sServiceName<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ServiceAuthentication<span class="operator">() { ; }</span>
 
   <font style="background-color:yellow"><span class="keyword">virtual</span><span class="type"> void</span> onBeforeProcess<span class="operator">()</span></font>
   <span class="operator">{</span><span class="comment">
      // Here you can implement your own authentication control (checking login/password for example)
      // You can get input authentication parameters like this :
</span>      ParameterAuthentication_ptr pParams<span class="operator"> =</span> getInputParameter<span class="operator">();</span>
      <i>pParams<span class="operator">-&gt;</span>login<span class="operator">,</span> pParams<span class="operator">-&gt;</span>password<span class="operator">,</span> etc<span class="operator">...</span></i><span class="comment">
 
      // If authentication is not valid, then you can throw an exception (and stop process before executing service function)
</span><span class="flow">      throw</span> qx<span class="operator">::</span>exception<span class="operator">(</span><span class="string">"Authentication error !"</span><span class="operator">);
   }
 
};</span></pre>
            </td></tr></tbody></table>
            <br><br>
            A présent, nous disposons des classes de base <i>ParameterAuthentication</i> et <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i> : toutes les classes de paramètres et toutes les classes de services doivent hériter de ces classes de base pour gérer automatiquement l'authentification, et retourner une erreur au client si les paramètres de l'utilisateur ne sont pas valides.
            <br><br>
            <b>Remarque :</b> de la même façon que pour gérer l'authentification, il est possible de mettre en place des logs automatiques en surchargeant les méthodes virtuelles <i>onBeforeProcess()</i> et <i>onAfterProcess()</i>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_840">Requêtes client/serveur asynchrones</a></p>
         <div class="manual_div_content">
            Par défaut, les requêtes client/serveur sont synchrones : ce qui signifie que la couche cliente attend la réponse du serveur pour continuer son exécution.
            Dans une interface graphique utilisateur (<i>GUI</i>), une requête client/serveur bloque l'application (<i>freeze</i>) si elle est exécutée dans le thread principal : si le serveur met du temps pour renvoyer sa réponse, l'utilisateur peut alors penser qu'il s'agit d'un crash de l'application.
            La module <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> propose une solution simple pour effectuer des requêtes asynchrones (qui ne bloquent donc pas l'interface graphique de l'utilisateur) grâce à la classe <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a>.
            <br><br>
            La classe <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> utilise <a href="#manual_70">le moteur d'introspection</a> de la bibliothèque QxOrm ainsi que le mécanisme <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank"><i>SIGNAL-SLOT</i> de Qt</a>.
            Elle prend en paramètre :
            <ul>
               <li>une instance de service ;</li>
               <li>les paramètres d'entrée/sortie du service ;</li>
               <li>le nom de la routine serveur à exécuter (sous forme de chaine de caractères) ;</li>
               <li>une fonction à appeler une fois que la transaction est terminée (connexion à l'évènement <i>signal</i> <i>finished()</i>).</li>
            </ul>
            <br>
            Voici l'exemple issu du <a href="./tutorial_2.html#tuto_302">tutoriel qxClientServer</a> qui exécute une routine serveur de manière asynchrone :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTimeAsync(), main_dlg::onDateTimeAsyncFinished()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTimeAsync<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDateTimeAsync<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] '%s' transaction is already running"</span><span class="operator">,</span><span class="string"> "server_infos::get_current_date_time"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur (mode asynchrone)
</span>   server_infos_ptr service<span class="operator"> =</span> server_infos_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxClientAsync<span class="operator">());</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pDateTimeAsync<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>finished<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onDateTimeAsyncFinished<span class="operator">()));</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>setService<span class="operator">(</span>service<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">);</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>start<span class="operator">();
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onDateTimeAsyncFinished<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_pDateTimeAsync<span class="operator"> || !</span> m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()) {</span><span class="flow"> return</span><span class="operator">; }</span>
   updateLastTransactionLog<span class="operator">(</span>m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()-&gt;</span>getTransaction<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">();
}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Remarque :</b> l'exemple ci-dessus montre comment effectuer une requête asynchrone avec les actions suivantes :
            <ul>
               <li>création d'une instance d'un service (de type <i>server_infos_ptr</i> pour cet exemple) ;</li>
               <li>création d'une instance de type <i>qx::service::QxClientAsync</i> ;</li>
               <li>connexion à l'évènement <i>finished</i> (pour indiquer qu'une réponse du serveur vient d'arriver) ;</li>
               <li>passage de l'instance du service et de la méthode à appeler (sous forme de chaine de caractères) à l'objet <i>qx::service::QxClientAsync</i> ;</li>
               <li>démarrage de la transaction avec l'appel de la méthode <i>start()</i>.</li>
            </ul>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_90">Moteur modèle/vue (module QxModelView)</a></p>
      <div class="manual_div_content_1">
         Le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet d'utiliser <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">le moteur model/view de Qt</a> avec toutes les classes enregistrées dans le contexte QxOrm :
         <ul>
            <li><a href="#manual_940">QML</a> : toute propriété enregistrée dans le contexte QxOrm est accessible en QML : le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> permet ainsi de faciliter l'intéraction entre QML et les bases de données ;</li>
            <li><a href="#manual_950">Qt widgets</a> : utilisation de <i>QTableView</i> ou <i>QListView</i> par exemple pour afficher/modifier le contenu d'une table de la base de données.</li>
         </ul>
         L'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une base commune pour tous les modèles liés aux classes persistantes déclarées dans le contexte QxOrm.
         Les méthodes de cette classe préfixées par '<i>qx</i>' appellent les fonctions du <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">namespace qx::dao</a> et communiquent donc directement avec la base de données.
         L'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> fournit également des méthodes définies <b>Q_INVOKABLE</b> et sont donc accessibles directement en <a href="#manual_940">QML</a> :
         <ul>
            <li><i>qxCount_() :</i> compte le nombre d'éléments dans la table de la base de données associée au modèle (avec possibilité d'indiquer un filtre SQL) ;</li>
            <li><i>qxFetchById_() :</i> alimente le modèle en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxFetchAll_() :</i> alimente le modèle avec tous les éléments contenus dans la table de la base de données associée au modèle ;</li>
            <li><i>qxFetchByQuery_() :</i> alimente le modèle avec les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL ;</li>
            <li><i>qxFetchRow_() :</i> alimente (met à jour) une ligne du modèle (chaque ligne du modèle dispose de son propre identifiant de base de données) ;</li>
            <li><i>qxInsert_() :</i> insère l'intégralité du modèle en base de données ;</li>
            <li><i>qxInsertRow_() :</i> insère une ligne du modèle en base de données ;</li>
            <li><i>qxUpdate_() :</i> met à jour l'intégralité du modèle en base de données ;</li>
            <li><i>qxUpdateRow_() :</i> met à jour une ligne du modèle en base de données ;</li>
            <li><i>qxSave_() :</i> sauvegarde l'intégralité du modèle en base de données (insertion ou mise à jour) ;</li>
            <li><i>qxSaveRow_() :</i> sauvegarde une ligne du modèle en base de données (insertion ou mise à jour) ;</li>
            <li><i>qxDeleteById_() :</i> supprime un élément de la base de données en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxDeleteAll_() :</i> supprime tous les éléments de la table de la base de données associée au modèle ;</li>
            <li><i>qxDeleteByQuery_() :</i> supprime les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL ;</li>
            <li><i>qxDeleteRow_() :</i> supprime une ligne du modèle de la base de données (chaque ligne du modèle dispose de son propre identifiant de base de données) ;</li>
            <li><i>qxDestroyById_() :</i> supprime un élément de la base de données en fonction de l'identifiant passé en paramètre (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyAll_() :</i> supprime tous les éléments de la table de la base de données associée au modèle (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyByQuery_() :</i> supprime les éléments de la table de la base de données associée au modèle en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
            <li><i>qxDestroyRow_() :</i> supprime une ligne du modèle de la base de données (chaque ligne du modèle dispose de son propre identifiant de base de données), avec prise en compte de <a href="#manual_3400">la suppression logique</a> ;</li>
            <li><i>qxExecuteQuery_() :</i> alimente le modèle en fonction d'une <a href="#manual_3610">requête SQL personnalisée ou procédure stockée</a> ;</li>
            <li><i>qxExist_() :</i> teste l'existence d'un élément en fonction de l'identifiant passé en paramètre ;</li>
            <li><i>qxValidate_() :</i> teste la validité de l'intégralité du modèle (<a href="#manual_420">module QxValidator</a>) ;</li>
            <li><i>qxValidateRow_() :</i> teste la validité d'une ligne du modèle (<a href="#manual_420">module QxValidator</a>).</li>
         </ul>
         <br/>
         <b>Remarque :</b> le projet de test <i>qxBlogModelView</i> présent dans le dossier <i>./test/</i> du package QxOrm montre comment créer rapidement un modèle et l'associer au moteur <i>model/view</i> de Qt (d'abord dans <a href="#manual_950">un widget Qt</a>, puis dans <a href="#manual_940">une vue QML</a>).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_910">Définir un modèle "simple" (sans relation)</a></p>
         <div class="manual_div_content">
            Toute classe enregistrée dans le contexte QxOrm peut être utilisée en tant que modèle afin d'alimenter des vues.
            La classe de base <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> des modèles QxOrm hérite de la classe Qt <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a> : les modèles QxOrm sont donc entièrement compatibles avec <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">le moteur model/view de Qt</a>.
            <br/><br/>
            Une seule ligne de code est suffisante pour instancier un modèle QxOrm :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <font style="background-color:yellow">qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>MyClass<span class="operator">&gt;();</span></font>   </pre>
            </td></tr></tbody></table>
            <br/>
            <b>Remarque :</b> le modèle créé avec cette ligne de code expose automatiquement toutes les propriétés enregistrées dans le contexte QxOrm au <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">moteur model/view</a>.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_920">Modèles avec relations (notion de modèles imbriqués)</a></p>
         <div class="manual_div_content">
            Adapter les relations entre classe (<i>1-n</i>, <i>n-1</i> ou <i>n-n</i>) au moteur model/view de Qt est complexe : la solution proposée par la bibliothèque QxOrm est l'utilisation de <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a>.
            Pour plus de détails sur la notion de modèles imbriqués, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">un tutoriel est disponible sur le site developpez.com</a>.
            <br/><br/>
            Pour utiliser les relations (<i>1-n</i>, <i>n-1</i> ou <i>n-n</i>) avec le <a href="../doxygen/html/group___qx_model_view.html" target="_blank">module QxModelView</a>, il est important de comprendre qu'il peut y avoir <b>une hiérarchie entre modèles</b> (un modèle parent peut avoir plusieurs modèles enfants associés, c'est la notion de <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a>).
            <br/><br/>
            Afin de pouvoir travailler avec des relations (modèles imbriqués), il est nécessaire de créer des classes modèles qui héritent de : <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::QxModel&lt;T&gt;</a>.
            Ainsi, toutes les propriétés simples (non relation) sont automatiquement exposées aux vues (grâce à la classe de base), il reste à écrire uniquement les accesseurs pour accéder aux relations.
            L'application <b>QxEntityEditor</b> est livrée avec le plugin <i>QxEECppModelViewExport</i> : <b>ce plugin génère automatiquement le code source pour pouvoir travailler avec des modèles imbriqués</b>.
            <br/><br/>
            Voici un exemple de code généré par l'application <b>QxEntityEditor</b> afin de créer un modèle basé sur la classe <i>blog</i> (voir <a href="./tutorial.html" target="_blank">le tutoriel <i>qxBlog</i></a> pour plus de détails).
            La classe <i>blog</i> dispose de 3 relations : <i>author (n-1)</i>, <i>list_of_comment (1-n)</i> et <i>list_of_category (n-n)</i> :
            <br/><br/>
            <i>* Fichier blog.model_view.gen.h :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span><span class="keyword">

typedef</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_model_base_class<span class="operator">;</span><span class="keyword">

class</span> QXBLOG_MODEL_VIEW_EXPORT blog_model<span class="operator"> :</span><span class="keyword"> public</span> blog_model_base_class<span class="operator">
{</span>

   Q_OBJECT<span class="keyword">

public</span><span class="operator">:</span>

   blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="operator"> =</span><span class="int"> 0</span><span class="operator">);</span>
   blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">);</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_model<span class="operator">();</span>

   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>

   <span class="comment">/* List of properties exposed by the model (3) :
      - blog_id
      - title
      - text
   */</span><span class="keyword">

protected</span><span class="operator">:</span><span class="keyword">

   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="keyword">
   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="operator">

};

}</span><span class="comment"> // namespace model_view</span></pre>
            </td></tr></tbody></table>
            <br/>
            <i>* Fichier blog.model_view.gen.cpp :</i><br>
            <div style="width:1000px; height:300px; overflow:auto; background-color:white;">
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="comment"> /* = 0 */</span><span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>other<span class="operator">,</span> parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::~</span>blog_model<span class="operator">() { ; }</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "author"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_author value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getauthor<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getauthor<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>author_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_comment"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_comment value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_comment<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_comment<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>comment_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_category"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_category value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_category<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_category<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>category_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span>
   Q_UNUSED<span class="operator">(</span>relation<span class="operator">);</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pNestedModel<span class="operator"> =</span> NULL<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span><span class="flow"> return</span><span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_author value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_comment value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_category value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lstChild<span class="operator">.</span>count<span class="operator">() &lt;=</span><span class="int"> 0</span><span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="flow">
   for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
   {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>syncNestedModel<span class="operator">(</span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(</span>l<span class="operator">),</span> relation<span class="operator">); }
}

}</span><span class="comment"> // namespace model_view</span></pre>
            </div>
            <br/><br/>
            <b>Remarque :</b> comme on peut le constater sur l'exemple ci-dessus, le code source à écrire pour travailler avec des modèles imbriqués est verbeux.
            <b>Afin de travailler avec les relations, il est donc fortement recommandé d'utiliser l'application QxEntityEditor afin de générer le code source automatiquement.</b>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_940">Intéraction avec les vues QML</a></p>
         <div class="manual_div_content">
            Voici un exemple en QML (en Qt5, le module <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> étant également compatible avec Qt4) qui utilise la table '<i>author</i>' définie dans <a href="./tutorial.html" target="_blank">le tutoriel <i>qxBlog</i></a> (le code source de cet exemple QML est disponible dans le projet de test <i>qxBlogModelView</i> présent dans le package QxOrm) :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QML view and display it
</span>QQuickView qmlView<span class="operator">;</span>
qmlView<span class="operator">.</span>rootContext<span class="operator">()-&gt;</span>setContextProperty<span class="operator">(</span><span class="string">"myModel"</span><span class="operator">,</span> pModel<span class="operator">);</span>
qmlView<span class="operator">.</span>setSource<span class="operator">(</span>QUrl<span class="operator">(</span><span class="string">"qrc:/documents/main.qml"</span><span class="operator">));</span>
qmlView<span class="operator">.</span>show<span class="operator">();</span></pre>
            </td></tr></tbody></table>
            <br/>
            Et voici le contenu du fichier '<i>main.qml</i>' :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>import QtQuick<span class="float"> 2.1</span>
import QtQuick<span class="operator">.</span>Controls<span class="float"> 1.0</span>

Item<span class="operator"> {</span>
   width<span class="operator">:</span><span class="int"> 400</span>
   height<span class="operator">:</span><span class="int"> 300</span>
   Row<span class="operator"> {</span>
      height<span class="operator">:</span><span class="int"> 20</span>
      spacing<span class="operator">:</span><span class="int"> 20</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Clear"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>clear<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Fetch All"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxFetchAll_<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Save"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxSave_<span class="operator">()
      }
   }</span>
   ListView<span class="operator"> {</span>
      y<span class="operator">:</span><span class="int"> 30</span>
      height<span class="operator">:</span><span class="int"> 270</span>
      model<span class="operator">:</span> myModel
      delegate<span class="operator">:</span> Row<span class="operator"> {</span>
         height<span class="operator">:</span><span class="int"> 20</span>
         spacing<span class="operator">:</span><span class="int"> 10</span>
         Text<span class="operator"> {</span> text<span class="operator">:</span><span class="string"> "id: "</span><span class="operator"> +</span> author_id<span class="operator"> }</span>
         TextField<span class="operator"> {</span>
            text<span class="operator">:</span> name
            onTextChanged<span class="operator">:</span> name<span class="operator"> =</span> text<span class="operator">
         }
      }
   }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui donne le résultat suivant à l'exécution :<br/>
            <br/>
            <img alt="qx_model_view_02" src="./resource/qx_model_view_02.png" border="0" /><br/>
            <br/>
            <b>Remarque :</b> comme on peut le constater dans le fichier '<i>main.qml</i>', les propriétés '<i>author_id</i>' et '<i>name</i>' du modèle '<i>author</i>' (variable <i>myModel</i>) sont accessibles automatiquement en lecture/écriture (car elles ont été enregistrées dans le contexte QxOrm).<br/>
            De plus, l'interface <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> propose une liste de méthodes accessibles en QML (utilisation de <i>Q_INVOKABLE</i>) pour communiquer directement avec la base de données : ainsi, le bouton '<i>Save</i>' de l'écran ci-dessus enregistre le modèle en base de données depuis QML.
            <br/><br/>
            <b>Autre remarque :</b> <a href="#manual_920">un plugin de l'application <b>QxEntityEditor</b> permet de générer automatiquement le code des modèles pour la gestion des relations</a>. Il est ainsi possible de travailler avec des <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">modèles imbriqués</a> (pour plus de détails sur la notion de modèles imbriqués, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">rendez-vous sur ce tutoriel du site developpez.com</a>).
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_950">Intéraction avec les vues QtWidget</a></p>
         <div class="manual_div_content">
            Voici un exemple de création d'un modèle pour afficher/modifier les données de la table '<i>author</i>' (voir le <a href="./tutorial.html" target="_blank">tutoriel <i>qxBlog</i></a> pour la définition de la classe '<i>author</i>') dans un <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a> (le code source de cet exemple est disponible dans le projet de test <i>qxBlogModelView</i> présent dans le package QxOrm) :<br/>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
   <pre>   <span class="comment">// Create a model and fetch all data from database
   </span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
   pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

   // Associate the model to a QTableView and display it   
   </span>QTableView tableView<span class="operator">;</span>
   tableView<span class="operator">.</span>setModel<span class="operator">(</span>pModel<span class="operator">);</span>
   tableView<span class="operator">.</span>show<span class="operator">();</span></pre>
            </td></tr></tbody></table>
            <br>
            Ce qui donne le résultat suivant à l'exécution :<br/>
            <br/>
            <img alt="qx_model_view_01" src="./resource/qx_model_view_01.png" border="0" /><br/>
            <br/>
            <b>Remarque :</b> Qt propose par défaut plusieurs vues <i>QtWidget</i> qui peuvent être mappées sur un modèle, par exemple : <a href="http://doc.qt.io/qt-5/qlistview.html" target="_blank">QListView</a>, <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a>, <a href="http://doc.qt.io/qt-5/qtreeview.html" target="_blank">QTreeView</a>.
            Il est également possible d'utiliser la classe <a href="http://doc.qt.io/qt-4.8/qdatawidgetmapper.html" target="_blank">QDataWidgetMapper</a> pour créer ses propres formulaires basés sur des modèles (<a href="http://qt-quarterly.developpez.com/qq-21/widget-correspondance-donnees/" target="_blank">un tutoriel est disponible sur le site developpez.com</a>).
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_960">Connexion d'un modèle au module QxService</a></p>
         <div class="manual_div_content">
            Le module <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a> fournit la classe template : <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> (qui hérite de : <a href="../doxygen/html/classqx_1_1_qx_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> &gt;&gt; <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> &gt;&gt; <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a>).
            Cette classe dispose de 2 paramètres template :
            <ul>
               <li><i>T</i> : classe enregistrée dans le contexte QxOrm dont toutes les propriétés sont exposées au <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">moteur model/view de Qt</a> ;</li>
               <li><i>S</i> : classe de services du <a href="#manual_80">module QxService</a> pour accéder/enregistrer les données du modèle (requêtes client/serveur).</li>
            </ul>
            Les données proposées par le modèle sont ainsi issues de requêtes client/serveur grâce au <a href="#manual_80">module QxService</a> (elles ne proviennent pas directement de la base de données).
            La classe de services <i>S</i> doit proposer les méthodes suivantes :
            <ul>
               <li><i>count() :</i> requête client/serveur pour compter le nombre d'éléments (avec possibilité d'utiliser un filtre SQL) ;</li>
               <li><i>fetchById() :</i> requête client/serveur pour alimenter les propriétés du modèle en fonction de son identifiant ;</li>
               <li><i>fetchAll() :</i> requête client/serveur pour alimenter les propriétés du modèle qui contiendra tous les éléments d'une table ;</li>
               <li><i>fetchByQuery() :</i> requête client/serveur pour alimenter les propriétés du modèle qui contiendra les éléments filtrés par une requête SQL ;</li>
               <li><i>insert() :</i> requête client/serveur pour insérer les données du modèle ;</li>
               <li><i>update() :</i> requête client/serveur pour mettre à jour les données du modèle ;</li>
               <li><i>save() :</i> requête client/serveur pour sauvegarder les données du modèle (insertion ou mise à jour) ;</li>
               <li><i>deleteById() :</i> requête client/serveur pour supprimer un modèle en fonction de son identifiant ;</li>
               <li><i>deleteAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée au modèle ;</li>
               <li><i>deleteByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL ;</li>
               <li><i>destroyById() :</i> requête client/serveur pour supprimer un modèle en fonction de son identifiant (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>destroyAll() :</i> requête client/serveur pour supprimer tous les éléments de la table mappée au modèle (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>destroyByQuery() :</i> requête client/serveur pour supprimer tous les éléments en fonction d'une requête SQL (avec prise en compte de <a href="#manual_3400">la suppression logique</a>) ;</li>
               <li><i>executeQuery() :</i> requête client/serveur pour exécuter <a href="#manual_3610">une requête SQL personnalisée ou procédure stockée</a> ;</li>
               <li><i>exist() :</i> requête client/serveur pour tester l'existence du modèle en fonction de son identifiant ;</li>
               <li><i>isValid() :</i> requête client/serveur pour tester la validité du modèle (<a href="#manual_420">module QxValidator</a>).</li>
            </ul>
            <br/>
            <b>Remarque :</b> l'application <b>QxEntityEditor</b> est livrée avec les plugins <i>QxEECppServicesExport</i> et <i>QxEECppModelViewExport</i> : ces plugins génèrent automatiquement tout le code source nécessaire pour travailler avec des modèles qui utilisent le <a href="#manual_80">module QxService</a>.
            <b>Afin de travailler avec la classe <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a>, il est donc fortement recommandé d'utiliser l'application QxEntityEditor afin de générer le code source automatiquement.</b>
            <br/><br/>
         </div>
      </div>

      </div>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2017 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
