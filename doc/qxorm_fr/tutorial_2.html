<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Accueil</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Téléchargement</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Exemple rapide</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutoriel (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manuel (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">Manuel QxOrm</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">Manuel QxEntityEditor</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Nos clients</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Tutoriel  &gt;&gt;  qxClientServer</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Version courante :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.4.3 - <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.1</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/tutorial_2.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/tutorial_2.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
        <table border="0" cellpadding="4">
          <col><col>
          <tbody>
            <tr>
              <td><font class="txt_with_shadow" color="#0B0B61" size="4"><i>Sélection du tutoriel : </i></font></td>
              <td align="left">
                <a href="./tutorial.html" class="btn_tuto">Tuto n°1 : qxBlog</a>
                <a href="./tutorial_2.html" class="btn_tuto_selected">Tuto n°2 : qxClientServer</a>
                <a href="./tutorial_3.html" class="btn_tuto">Tuto n°3 : install QxOrm</a>
                <a href="./tutorial_4.html" class="btn_tuto">Tuto n°4 : video QxEntityEditor</a>
              </td>
            </tr>
          </tbody>
        </table>
        <hr style="width: 100%" align="center" size="1" color="#100D5A">
        <br>
        <table border="0" style="width: 100%" align="center">
          <col><col>
          <tbody>
            <tr>
              <td>Le tutoriel <b>qxClientServer</b> a pour objectif d'expliquer le fonctionnement du module <a href="../doxygen/html/group___qx_service.html" target="_blank"><b>QxService</b></a> de la bibliothèque <b>QxOrm</b>.<br>
                 Le module <b>QxService</b> permet de créer rapidement un <b>serveur d'applications C++</b> performant (notion de <i>services</i> avec <i>demande</i> du client et <i>réponse</i> du serveur).<br>
                 Les sources du projet <b>qxClientServer</b> sont disponibles dans le dossier <i>./test/qxClientServer/</i> de la distribution de <b>QxOrm</b>.<br>
                 Il est conseillé d'avoir lu <a href="./tutorial.html">le tutoriel <b>qxBlog</b></a> avant de lire cet article, notamment tout ce qui concerne la fonction de mapping de <b>QxOrm</b> : <b><i>void qx::register_class&lt;T&gt;(...)</i></b>.<br>
                 <br>
                 <b>Remarque :</b> pour activer le module <b>QxService</b> (nécessaire pour compiler les sources de ce tutoriel), il faut définir l'option de compilation <b>_QX_ENABLE_QT_NETWORK</b> dans le fichier de configuration <i>QxOrm.pri</i>.
                 Pour plus de détails sur ces options de compilation, <a href="./manual.html#manual_220">rendez-vous sur le manuel utilisateur de la bibliothèque QxOrm</a>.
                 <br><br>
                 Le résultat final de ce tutoriel comporte deux exécutables et une couche service :
                 <ul>
                   <li><i>qxServer</i> : serveur d'applications C++ avec une interface utilisateur pour paramétrer le serveur et un champ pour afficher la dernière transaction effectuée entre le client et le serveur ;</li>
                   <li><i>qxClient</i> : interface utilisateur contenant plusieurs boutons pour exécuter différentes requêtes au serveur ;</li>
                   <li><i>qxService</i> : couche service, le serveur et le client partagent cette même couche pour transférer les données et appeler les services.</li>
                 </ul>
                 Le tutoriel <b>qxClientServer</b> est constitué des étapes suivantes :
                 <ul>
                   <li><a href="#tuto_10">1- Création de l'interface serveur : <i>qxServer</i></a>
                     <ul>
                       <li><a href="#tuto_101">1.1- Description du fichier <i>main_dlg.h</i></a></li>
                       <li><a href="#tuto_102">1.2- Description du fichier <i>main_dlg.cpp</i>, méthode <i>init()</i></a></li>
                       <li><a href="#tuto_103">1.3- Description du fichier <i>main_dlg.cpp</i>, méthode <i>loadServices()</i></a></li>
                       <li><a href="#tuto_104">1.4- Description du fichier <i>main_dlg.cpp</i>, méthode <i>onClickStartStop()</i></a></li>
                       <li><a href="#tuto_105">1.5- Description du fichier <i>main_dlg.cpp</i>, méthodes <i>onError()</i> et <i>onTransactionFinished()</i></a></li>
                       <li><a href="#tuto_106">1.6- Résultat obtenu pour le projet <i>qxServer</i></a></li>
                     </ul>
                   </li>
                   <li><a href="#tuto_20">2- Création de la couche service : <i>qxService</i></a>
                     <ul>
                       <li><a href="#tuto_201">2.1- Ecriture du premier service : récupérer la date-heure courante du serveur</a></li>
                       <li><a href="#tuto_202">2.2- Description du fichier <i>server_infos.h</i></a></li>
                       <li><a href="#tuto_203">2.3- Description du fichier <i>server_infos.cpp</i></a></li>
                       <li><a href="#tuto_204">2.4- Ecriture du second service : opérations avec une classe persistante</a></li>
                     </ul>
                   </li>
                   <li><a href="#tuto_30">3- Création de l'interface cliente : <i>qxClient</i></a>
                     <ul>
                       <li><a href="#tuto_301">3.1- Description de la méthode <i>onClickBtnDateTime()</i></a></li>
                       <li><a href="#tuto_302">3.2- Description de la méthode <i>onClickBtnDateTimeAsync()</i></a></li>
                       <li><a href="#tuto_303">3.3- Description de la méthode <i>onClickBtnAddUser()</i></a></li>
                       <li><a href="#tuto_304">3.4- Description de la méthode <i>onClickBtnGetAllUsers()</i></a></li>
                     </ul>
                   </li>
                 </ul>
                 <i>Remarque :</i> ce tutoriel est également disponible sur le site <a href="http://marty-lionel.developpez.com/tutoriels/qt/qxorm-tutoriel-qxclientserver/" target="_blank">www.developpez.com</a>.<br>
              </td>
              <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                 <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
              </td>
            </tr>
          </tbody>
        </table>
        <br>
        <img alt="gui_qxClientServer" src="./resource/gui_qxClientServer.jpg" width="1056" height="727" style="border:0px solid #100D5A; border-color:#100D5A;">
        <br><br>
        <b>Remarque :</b> pour plus de détails sur la notion de socket, de thread et de réseau, le site de <b>Qt</b> propose des tutoriels sur l'utilisation du module <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank"><b>QtNetwork</b></a> :
        <ul>
          <li><a href="http://doc.qt.io/qt-5/qtnetwork-fortuneclient-example.html" target="_blank"><i>Fortune Client</i></a> ;</li>
          <li><a href="http://doc.qt.io/qt-5/qtnetwork-blockingfortuneclient-example.html" target="_blank"><i>Blocking Fortune Client</i></a> ;</li>
          <li><a href="http://doc.qt.io/qt-5/qtnetwork-fortuneserver-example.html" target="_blank"><i>Fortune Server</i></a> ;</li>
          <li><a href="http://doc.qt.io/qt-5/qtnetwork-threadedfortuneserver-example.html" target="_blank"><i>Threaded Fortune Server</i></a>.</li>
        </ul>
        <br>
        <b><a name="tuto_10"><u><font color="#100D5A">1- Création de l'interface serveur : <i>qxServer</i></font></u></a></b>
        <br><br>
        Le projet <i>qxServer</i> contient une seule fenêtre : l'interface utilisateur a été réalisée avec l'outil <b>Qt Designer</b> proposé par la bibliothèque Qt.<br>
        Cette interface a pour seul objectif d'afficher à l'utilisateur la dernière transaction client-serveur, et de pouvoir configurer certains paramètres du serveur.<br>
        Pour une utilisation réelle (logiciel de production), il est conseillé de proposer un sytème de <i>log</i> plutôt qu'un affichage à l'utilisateur.<br>
        Une interface la plus minimaliste possible (voire aucune interface) est de manière générale la solution la plus optimale pour un serveur d'applications.<br>
        Les fichiers <i>main_dlg.h</i> et <i>main_dlg.cpp</i> correspondent au code C++ de l'interface du projet <i>qxServer</i>.<br>
        <br>
        <a name="tuto_101"><u><font color="#100D5A">1.1- Description du fichier <i>main_dlg.h</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg.h">
<pre><span class="pre">#ifndef _QX_SERVER_MAIN_DLG_H_
#define _QX_SERVER_MAIN_DLG_H_

#include "../qt/ui/include/ui_qxServer.h"
</span><span class="keyword">
class</span> main_dlg<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">,</span><span class="keyword"> private</span> Ui<span class="operator">::</span>dlgServer<span class="operator">
{</span> Q_OBJECT<span class="keyword">

private</span><span class="operator">:</span>

   qx<span class="operator">::</span>service<span class="operator">::</span>QxThreadPool_ptr m_pThreadPool<span class="operator">;</span><span class="comment"> // Liste de threads pour recevoir les requêtes des clients
</span><span class="keyword">
public</span><span class="operator">:</span>

   main_dlg<span class="operator">(</span>QWidget<span class="operator"> *</span> parent<span class="operator"> =</span> NULL<span class="operator">) :</span> QWidget<span class="operator">(</span>parent<span class="operator">),</span> Ui<span class="operator">::</span>dlgServer<span class="operator">() {</span> main_dlg<span class="operator">::</span>init<span class="operator">(); }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>main_dlg<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span><span class="type">

   void</span> init<span class="operator">();</span><span class="type">
   void</span> loadServices<span class="operator">();</span><span class="keyword">

private</span> Q_SLOTS<span class="operator">:</span><span class="type">

   void</span> onClickStartStop<span class="operator">();</span><span class="type">
   void</span> onCboIndexChanged<span class="operator">(</span><span class="type">int</span> index<span class="operator">);</span><span class="type">
   void</span> onError<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> err<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr transaction<span class="operator">);</span><span class="type">
   void</span> onServerIsRunning<span class="operator">(</span><span class="type">bool</span> bIsRunning<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxServer<span class="operator"> *</span> pServer<span class="operator">);</span><span class="type">
   void</span> onTransactionFinished<span class="operator">(</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr transaction<span class="operator">);

};</span><span class="pre">

#endif // _QX_SERVER_MAIN_DLG_H_</span></pre>
        </td></tr></tbody></table>
        <br>
        La variable <i>m_pThreadPool</i> de type <i>qx::service::QxThreadPool_ptr</i> contient toute la logique du serveur d'applications.<br>
        Cette logique est gérée de manière automatique par la bibliothèque <b>QxOrm</b>.<br>
        La méthode <i>init()</i> permet d'initialiser les paramètres par défaut du serveur, de connecter les évènements <b>SIGNAL-SLOT</b> et de lancer automatiquement le serveur.<br>
        Nous allons voir tout ceci plus en détails avec l'implémentation des méthodes dans le fichier <i>main_dlg.cpp</i>...<br>
        <br>
        <a name="tuto_102"><u><font color="#100D5A">1.2- Description du fichier <i>main_dlg.cpp</i>, méthode <i>init()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::init()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>init<span class="operator">()
{</span>
   setupUi<span class="operator">(</span><span class="keyword">this</span><span class="operator">);</span>

   QObject<span class="operator">::</span>connect<span class="operator">(</span>btnStartStop<span class="operator">,</span> SIGNAL<span class="operator">(</span>clicked<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onClickStartStop<span class="operator">()));</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>cboSerializationType<span class="operator">,</span> SIGNAL<span class="operator">(</span>currentIndexChanged<span class="operator">(</span><span class="type">int</span><span class="operator">)),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onCboIndexChanged<span class="operator">(</span><span class="type">int</span><span class="operator">)));</span>

   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"0- serialization_binary"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_binary<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"1- serialization_xml"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_xml<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"2- serialization_text"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_text<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"3- serialization_portable_binary"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_portable_binary<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"4- serialization_wide_binary"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_wide_binary<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"5- serialization_wide_xml"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_wide_xml<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"6- serialization_wide_text"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_wide_text<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"7- serialization_polymorphic_binary"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_polymorphic_binary<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"8- serialization_polymorphic_xml"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_polymorphic_xml<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>addItem<span class="operator">(</span><span class="string">"9- serialization_polymorphic_text"</span><span class="operator">,</span> QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_polymorphic_text<span class="operator">));</span>
   cboSerializationType<span class="operator">-&gt;</span>setCurrentIndex<span class="operator">(</span>cboSerializationType<span class="operator">-&gt;</span>findData<span class="operator">(</span>QVariant<span class="operator">((</span><span class="type">int</span><span class="operator">)</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getSerializationType<span class="operator">())));</span>

   spinPortNumber<span class="operator">-&gt;</span>setValue<span class="operator">(</span><span class="int">7694</span><span class="operator">);</span>
   spinThreadCount<span class="operator">-&gt;</span>setValue<span class="operator">(</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getThreadCount<span class="operator">());</span>
   onServerIsRunning<span class="operator">(</span><span class="bool">false</span><span class="operator">,</span> NULL<span class="operator">);</span>
   onClickStartStop<span class="operator">();
}</span></pre>
        </td></tr></tbody></table>
        <br>
        L'évènement <i>onClickStartStop()</i> permet de démarrer/arrêter le serveur.<br>
        Le serveur d'applications peut sérialiser les réponses à envoyer aux clients de plusieurs façons : ce paramètre est disponible avec la combobox <i>cboSerializationType</i>.<br>
        Pour plus d'informations sur les différents types de sérialisation supportés par la bibliothèque QxOrm, <a href="../qxorm_fr/manual.html#manual_60">suivre ce lien du manuel utilisateur</a>.<br>
        D'une manière générale, la sérialisation binaire est fortement conseillée pour une transaction réseau car elle est plus rapide à exécuter et permet de limiter le traffic sur le réseau.<br>
        On définit également le port d'écoute du serveur d'applications avec le champ <i>spinPortNumber</i>.<br>
        Un paramètre important est le <b>nombre de threads</b> disponibles sur le serveur d'applications : celà correspond aux <b>nombres de clients pouvant se connecter au serveur simultanément</b>.<br>
        La valeur par défaut de ce paramètre est <i>30</i>, vous pouvez modifier cette valeur suivant la charge estimée de votre serveur d'applications.<br>
        Si le nombre de clients dépasse le nombre de threads disponibles, la requête est mise en attente : dès qu'un thread se libère, alors la requête s'exécute normalement.<br>
        Tout ceci est géré automatiquement par la bibliothèque <b>QxOrm</b> : il est juste important de faire une estimation de la charge que pourra avoir votre serveur d'applications.<br>
        Enfin, l'appel à <i>onClickStartStop()</i> permet de démarrer automatiquement le serveur dès l'exécution du programme <i>qxServer</i>.<br>
        <br>
        <a name="tuto_103"><u><font color="#100D5A">1.3- Description du fichier <i>main_dlg.cpp</i>, méthode <i>loadServices()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::loadServices()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>loadServices<span class="operator">()
{</span><span class="comment">
   // Nécessaire pour être certain de charger les DLL contenant les services : création d'un service fantôme pour chaque DLL
   // Il peut être intéressant à ce niveau de créer un mécanisme de plugins pour charger les différents services
</span>   server_infos dummy_01<span class="operator">;</span> Q_UNUSED<span class="operator">(</span>dummy_01<span class="operator">);
}</span></pre>
        </td></tr></tbody></table>
        <br>
        La méthode <i>loadServices()</i> est l'unique dépendance avec les services proposés par le serveur d'applications.<br>
        Elle sert uniquement à créer une instance fantôme pour être certain que la DLL contenant la liste des services soient correctement chargée au démarrage de l'application.<br>
        Pour un logiciel en production, il peut être intéressant à ce niveau de proposer <b>un système de plugins</b> pour charger les différents services.<br>
        <br>
        <a name="tuto_104"><u><font color="#100D5A">1.4- Description du fichier <i>main_dlg.cpp</i>, méthode <i>onClickStartStop()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickStartStop()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickStartStop<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pThreadPool<span class="operator">)
   {</span>
      m_pThreadPool<span class="operator">-&gt;</span>disconnect<span class="operator">();</span>
      m_pThreadPool<span class="operator">.</span>reset<span class="operator">();</span>
      txtError<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
      txtTransaction<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
      onServerIsRunning<span class="operator">(</span><span class="bool">false</span><span class="operator">,</span> NULL<span class="operator">);
   }</span><span class="flow">
   else</span><span class="operator">
   {</span>
      qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setPort<span class="operator">(</span>spinPortNumber<span class="operator">-&gt;</span>value<span class="operator">());</span>
      qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setThreadCount<span class="operator">(</span>spinThreadCount<span class="operator">-&gt;</span>value<span class="operator">());</span>
      qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setSerializationType<span class="operator">((</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>serialization_type<span class="operator">)
                                                                   (</span>cboSerializationType<span class="operator">-&gt;</span>itemData<span class="operator">(</span>cboSerializationType<span class="operator">-&gt;</span>currentIndex<span class="operator">()).</span>toInt<span class="operator">()));</span>
      qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setCompressData<span class="operator">(</span>chkCompressData<span class="operator">-&gt;</span>isChecked<span class="operator">());</span>
      qx<span class="operator">::</span>service<span class="operator">::</span>QxConnect<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setEncryptData<span class="operator">(</span>chkEncryptData<span class="operator">-&gt;</span>isChecked<span class="operator">());</span>

      m_pThreadPool<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxThreadPool<span class="operator">());</span>
      QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pThreadPool<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>error<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr<span class="operator">)),</span><span class="keyword"> this</span><span class="operator">,</span> 
                                            SLOT<span class="operator">(</span>onError<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr<span class="operator">)));</span>
      QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pThreadPool<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>serverIsRunning<span class="operator">(</span><span class="type">bool</span><span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxServer<span class="operator"> *)),</span><span class="keyword"> this</span><span class="operator">,</span> 
                                            SLOT<span class="operator">(</span>onServerIsRunning<span class="operator">(</span><span class="type">bool</span><span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxServer<span class="operator"> *)));</span>
      QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pThreadPool<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>transactionFinished<span class="operator">(</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr<span class="operator">)),</span><span class="keyword"> this</span><span class="operator">,</span> 
                                            SLOT<span class="operator">(</span>onTransactionFinished<span class="operator">(</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr<span class="operator">)));</span>
      m_pThreadPool<span class="operator">-&gt;</span>start<span class="operator">();
   }</span><span class="operator">
}</span></pre>
        </td></tr></tbody></table>
        <br>
        La méthode <i>onClickStartStop()</i> permet de démarrer/arrêter le serveur d'applications : elle s'occupe de créer une instance de type <i>qx::service::QxThreadPool_ptr</i> ou bien de la détruire.<br>
        Si la variable <i>m_pThreadPool</i> est valorisée, alors celà signifie que l'on souhaite arrêter le serveur : <i>m_pThreadPool.reset();</i>.<br>
        Sinon, le serveur est arrêté donc on souhaite le démarrer :<br>
        <br>
        <i>m_pThreadPool.reset(new qx::service::QxThreadPool());</i>.<br>
        <i>m_pThreadPool->start();</i>.<br>
        <br>
        Le paramétrage du serveur est effectué grâce au singleton <i>qx::service::QxConnect::getSingleton()</i>.<br>
        Enfin, l'interface utilisateur s'abonne aux évènements envoyés par le serveur d'applications (mécanisme <b>SIGNAL-SLOT</b> de Qt) pour récupérer une erreur ou bien afficher la dernière transaction client-serveur.<br>
        <br>
        <a name="tuto_105"><u><font color="#100D5A">1.5- Description du fichier <i>main_dlg.cpp</i>, méthodes <i>onError()</i> et <i>onTransactionFinished()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onError(), main_dlg::onTransactionFinished()">
        <pre><span class="type">void</span> main_dlg<span class="operator">::</span>onError<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> err<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr transaction<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isEmpty<span class="operator">()) {</span> txtError<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span><span class="string">""</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   QString errText<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">().</span>toString<span class="operator">(</span><span class="string">"dd.MM.yyyy hh:mm"</span><span class="operator">) +</span><span class="string"> " : "</span><span class="operator"> +</span> err<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>transaction<span class="operator">) {</span> errText<span class="operator"> +=</span> QString<span class="operator">(</span><span class="string">"\r\n\r\n"</span><span class="operator">) +</span> qx<span class="operator">::</span>serialization<span class="operator">::</span>xml<span class="operator">::</span>to_string<span class="operator">(*</span> transaction<span class="operator">); }</span>
   txtError<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span>errText<span class="operator">.</span>replace<span class="operator">(</span><span class="string">"\t"</span><span class="operator">,</span><span class="string"> "    "</span><span class="operator">));
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onTransactionFinished<span class="operator">(</span>qx<span class="operator">::</span>service<span class="operator">::</span>QxTransaction_ptr transaction<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> transaction<span class="operator">) {</span> txtTransaction<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span><span class="string">""</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   QString text<span class="operator"> =</span> qx<span class="operator">::</span>serialization<span class="operator">::</span>xml<span class="operator">::</span>to_string<span class="operator">(*</span> transaction<span class="operator">);</span>
   txtTransaction<span class="operator">-&gt;</span>setPlainText<span class="operator">(</span>text<span class="operator">.</span>replace<span class="operator">(</span><span class="string">"\t"</span><span class="operator">,</span><span class="string"> "    "</span><span class="operator">));
}</span></pre>
        </td></tr></tbody></table>
        <br>
        Toutes les transactions entre client et serveur sont représentées par la classe <i>qx::service::QxTransaction_ptr</i>.<br>
        Cette classe contient toutes les informations nécessaires à l'exécution d'un service (identifiant unique, date-heure, requête du client, service à exécuter, réponse du serveur, code et message d'erreur, etc.).<br>
        La transaction est sérialisée au format XML (ou JSON) avant d'être affichée à l'utilisateur dans le champ <i>txtTransaction</i>.<br>
        Cette sérialisation est indépendante de la réponse envoyée au client qui, par défaut, est au format binaire.<br>
        <br>
        <a name="tuto_106"><u><font color="#100D5A">1.6- Résultat obtenu pour le projet <i>qxServer</i></font></u></a>
        <br><br>
        <b>Et... c'est tout</b> : vous pouvez constater que l'écriture d'un serveur d'applications est extrêmement simple avec la bibliothèque <b>QxOrm</b>.<br>
        Votre serveur d'applications est prêt pour proposer de multiples services aux différents clients.<br>
        Voici le résultat obtenu :<br>
        <br>
        <img alt="gui_qxServer" src="./resource/gui_qxServer.jpg" width="560" height="426" style="border:0px solid #100D5A; border-color:#100D5A;">
        <br>
        <br><br>
        <b><a name="tuto_20"><u><font color="#100D5A">2- Création de la couche service : <i>qxService</i></font></u></a></b>
        <br><br>
        La couche service doit être partagée entre le client et le serveur.<br>
        La compilation du projet <i>qxService</i> crée deux DLL (ou fichiers <i>*.so</i> sous Linux) : <i>qxServiceClient</i> et <i>qxServiceServer</i>.<br>
        Une option de compilation <i>_QX_SERVICE_MODE_CLIENT</i> permet de faire la distinction entre le client et le serveur.<br>
        L'outil <i>qmake</i> de Qt et le système de fichiers <i>*.pro</i> et <i>*.pri</i> permettent de créer facilement ce type d'architecture :<br>
        <ul>
          <li>Le fichier <a href="./resource/qxService.pri"><i>qxService.pri</i></a> correspond au tronc commun des deux DLL, c'est-à-dire l'ensemble des dépendances et des fichiers à compiler ;</li>
          <li>Le fichier <a href="./resource/qxServiceClient.pro"><i>qxServiceClient.pro</i></a> est spécifique au mode client : définition de l'option de compilation <i>_QX_SERVICE_MODE_CLIENT</i> et du nom de la DLL ;</li>
          <li>Le fichier <a href="./resource/qxServiceServer.pro"><i>qxServiceServer.pro</i></a> est spécifique au mode serveur : définition du nom de la DLL.</li>
        </ul>
        Il est important de signaler que ce mécanisme permet au programme client de partager les mêmes fichiers que le programme serveur.<br>
        <b>La partie cliente n'a aucun code à écrire pour pouvoir appeler un service</b> : le serveur peut livrer la liste des fichiers de type <i>headers</i>, les <i>.dll</i> et <i>.lib</i> (ou <i>*.so</i> sous Linux).<br>
        <br>
        <a name="tuto_201"><u><font color="#100D5A">2.1- Ecriture du premier service : récupérer la date-heure courante du serveur</font></u></a>
        <br><br>
        Le premier service proposé par notre serveur d'applications de test est relativement simple : <b>il consiste à renvoyer aux clients la date-heure courante du serveur</b>.<br>
        Ce service est disponible avec la classe <i>server_infos</i> : fichiers <i>server_infos.h</i> et <i>server_infos.cpp</i>.<br>
        Une même classe peut proposer plusieurs services : la classe <i>server_infos</i> pourrait par exemple renvoyer en plus de la date-heure courante, un nom de machine, une fréquence processeur du serveur, etc.<br>
        Chaque classe service possède des paramètres d'entrée (demande du client) et des paramètres de sortie (réponse du serveur).<br>
        Une classe paramètre (entrée ou sortie) doit hériter de la classe <b>qx::service::IxParameter</b> et doit être sérialisable.<br>
        Une classe service doit hériter du template <b>qx::service::QxService&lt;INPUT, OUTPUT&gt;</b> et doit définir une liste de méthodes (services disponibles).<br>
        Il est conseillé d'écrire les classes paramètres d'entrée, paramètres de sortie et services dans le même fichier.<br>
        <br>
        <a name="tuto_202"><u><font color="#100D5A">2.2- Description du fichier <i>server_infos.h</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="server_infos.h">
<pre><span class="pre">#ifndef _QX_SERVICE_SERVER_INFOS_H_
#define _QX_SERVICE_SERVER_INFOS_H_
</span><span class="comment">
/* -- Liste des paramètres d'entrée du service -- */</span><span class="keyword">

class</span> QX_SERVICE_DLL_EXPORT server_infos_input<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{ ; };</span>

QX_REGISTER_HPP_QX_SERVICE<span class="operator">(</span>server_infos_input<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>server_infos_input<span class="operator">&gt;</span> server_infos_input_ptr<span class="operator">;</span><span class="comment">

/* -- Liste des paramètres de sortie du service -- */</span><span class="keyword">

class</span> QX_SERVICE_DLL_EXPORT server_infos_output<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{</span><span class="keyword"> public</span><span class="operator">:</span> QDateTime current_date_time<span class="operator">; };</span>

QX_REGISTER_HPP_QX_SERVICE<span class="operator">(</span>server_infos_output<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>server_infos_output<span class="operator">&gt;</span> server_infos_output_ptr<span class="operator">;</span><span class="comment">

/* -- Définition du service -- */</span><span class="keyword">

typedef</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>server_infos_input<span class="operator">,</span> server_infos_output<span class="operator">&gt;</span> server_infos_base_class<span class="operator">;</span><span class="keyword">
class</span> QX_SERVICE_DLL_EXPORT server_infos<span class="operator"> :</span><span class="keyword"> public</span> server_infos_base_class<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
   server_infos<span class="operator">() :</span> server_infos_base_class<span class="operator">(</span><span class="string">"server_infos"</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>server_infos<span class="operator">() { ; }</span><span class="type">
   void</span> get_current_date_time<span class="operator">();
};</span>

QX_REGISTER_HPP_QX_SERVICE<span class="operator">(</span>server_infos<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>server_infos<span class="operator">&gt;</span> server_infos_ptr<span class="operator">;</span><span class="pre">

#endif // _QX_SERVICE_SERVER_INFOS_H_</span></pre>
        </td></tr></tbody></table>
        <br>
        Le fichier <i>server_infos.h</i> possède trois classes :
        <ul>
          <li><b><i>server_infos_input</i></b> : hérite de <i>qx::service::IxParameter</i> et correspond aux paramètres d'entrée du service (demande du client). Notre service de test n'a pas besoin de paramètres en entrée, donc cette classe ne contient aucune propriété ;</li>
          <li><b><i>server_infos_output</i></b> : hérite de <i>qx::service::IxParameter</i> et correspond aux paramètres de sortie du service (réponse du serveur). Cette classe contient une seule propriété, la date-heure courante du serveur (<i>QDateTime current_date_time</i>) ;</li>
          <li><b><i>server_infos</i></b> : hérite de <i>qx::service::QxService&lt;INPUT, OUTPUT&gt;</i> et contient la liste des services disponibles : une seule méthode pour récupérer la date-heure courante du serveur.</li>
        </ul>
        Ces trois classes doivent être enregistrées dans le contexte QxOrm, de la même façon qu'une classe persistante (voir <a href="./tutorial.html">le tutoriel <b>qxBlog</b></a>).<br>
        C'est pourquoi nous utilisons la macro <i>QX_REGISTER_HPP_QX_SERVICE</i> pour ces trois classes.<br>
        De plus, pour simplifier l'écriture des pointeurs, la gestion de la mémoire et éviter les problèmes de fuites mémoires, nous utilisons les pointeurs intelligents de la bibliothèque boost : <i>boost::shared_ptr</i>.<br>
        Le module <b>QxService</b> travaille essentiellement avec des pointeurs intelligents, c'est pourquoi il est fortement conseillé de créer les <i>typedef</i> correspondants, par exemple :<br>
        <br>
        <i>typedef boost::shared_ptr&lt;server_infos_input&gt; server_infos_input_ptr;</i>.<br>
        <i>typedef boost::shared_ptr&lt;server_infos_output&gt; server_infos_output_ptr;</i>.<br>
        <i>typedef boost::shared_ptr&lt;server_infos&gt; server_infos_ptr;</i>.<br>
        <br>
        Enfin, le constructeur du service doit indiquer en paramètre le nom de la classe sous forme de chaîne de caractères : ceci est indispensable pour le moteur d'<i>introspection</i> de QxOrm pour pouvoir instancier dynamiquement les services correspondant aux requêtes des clients.<br>
        <br>
        <a name="tuto_203"><u><font color="#100D5A">2.3- Description du fichier <i>server_infos.cpp</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="server_infos.cpp">
<pre><span class="pre">#include "../../include/precompiled.h"

#include "../../include/service/server_infos.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>server_infos_input<span class="operator">)</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>server_infos_output<span class="operator">)</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>server_infos<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>server_infos_input<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">); }</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>server_infos_output<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> server_infos_output<span class="operator">::</span>current_date_time<span class="operator">,</span><span class="string"> "current_date_time"</span><span class="operator">); }</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>server_infos<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> server_infos<span class="operator">::</span>get_current_date_time<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">); }

}</span><span class="comment"> // namespace qx
</span><span class="pre">
#ifdef _QX_SERVICE_MODE_CLIENT
</span><span class="type">
void</span> server_infos<span class="operator">::</span>get_current_date_time<span class="operator">()
{</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">); }</span><span class="pre">

#else // _QX_SERVICE_MODE_CLIENT
</span><span class="type">
void</span> server_infos<span class="operator">::</span>get_current_date_time<span class="operator">()
{</span>
   server_infos_output_ptr output<span class="operator"> =</span> server_infos_output_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos_output<span class="operator">());</span>
   output<span class="operator">-&gt;</span>current_date_time<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   setOutputParameter<span class="operator">(</span>output<span class="operator">);</span>
   setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">);
}</span><span class="pre">

#endif // _QX_SERVICE_MODE_CLIENT</span></pre>
        </td></tr></tbody></table>
        <br>
        Le fichier <i>server_infos.cpp</i> contient l'implémentation du service pour le mode client et le mode serveur : c'est la macro <i>_QX_SERVICE_MODE_CLIENT</i> qui fait la distinction entre client et serveur au moment de la compilation du projet.<br>
        La macro <i>QX_REGISTER_CPP_QX_SERVICE</i> permet d'enregistrer les trois classes dans le contexte QxOrm, de la même façon qu'une classe persistante (voir le tutoriel <b>qxBlog</b>).<br>
        Ensuite, nous écrivons la méthode de mapping <i>void qx::register_class(...)</i> pour les trois classes du service :
        <ul>
          <li>Les deux classes de paramètres enregistrent les propriétés utilisées pour effectuer une demande du client (aucune pour notre service de test), et les propriétés qui seront renvoyées pour la réponse du serveur (date-heure courante : <i>t.data(& server_infos_output::current_date_time, "current_date_time");</i>) ;</li>
          <li>La classe service doit enregistrer la liste des méthodes disponibles, dans notre cas : <i>t.fct_0&lt;void&gt;(& server_infos::get_current_date_time, "get_current_date_time");</i>.</li>
        </ul>
        <b>Remarque :</b> toutes les méthodes de type service doivent avoir la même signature : <b>pas de valeur de retour, et pas d'argument</b> (par exemple : <i>void my_service()</i>).<br>
        En effet, dans un service, les paramètres d'entrée sont disponibles par la méthode <i>getInputParameter()</i> (de type <i>server_infos_input_ptr</i> dans notre exemple).<br>
        Les paramètres de sortie peuvent être valorisés par la méthode <i>setOutputParameter()</i> (de type <i>server_infos_output_ptr</i> dans notre exemple).<br>
        Une valeur de retour de type <i>qx_bool</i> permet d'indiquer que la transaction s'est déroulée normalement, ou bien qu'une erreur quelconque est survenue (avec libellé et code de l'erreur).<br>
        Il est très important d'écrire <i>setMessageReturn(true);</i> à la fin de chaque méthode service pour indiquer que tout s'est bien déroulé.<br>
        <br>
        La dernière partie de notre fichier contient l'implémentation de la méthode <i>server_infos::get_current_date_time()</i> pour le mode client et serveur :
        <ul>
          <li>Pour le mode client, le code est très simple et sera le même pour tous les services : <i>qx::service::execute_client(this, "get_current_date_time");</i> ;</li>
          <li>Pour le mode serveur, notre service de test est très simple : on valorise la date-heure courante, on la transfère dans les paramètres de sortie, puis on indique que la transaction s'est déroulée sans aucune erreur.</li>
        </ul>
        <a name="tuto_204"><u><font color="#100D5A">2.4- Ecriture du second service : opérations avec une classe persistante</font></u></a>
        <br><br>
        Le projet <i>qxService</i> contient un second exemple de service plus complet avec une classe persistante (classe <i>user</i>), et des actions sur une base de données (<i>SELECT, INSERT, UPDATE, DELETE, etc.</i>).<br>
        Ce deuxième exemple fait transiter sur le réseau des structures complexes : <b>pointeurs</b>, <b>pointeurs intelligents</b>, <b>collections</b>, <b>critères de recherche</b>, etc.<br>
        Nous ne détaillerons pas ce second service dans le tutoriel, le principe étant identique au premier service :<br>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="user_service.cpp">
<pre><span class="pre">#include "../../include/precompiled.h"

#include "../../include/service/user_service.h"

#include "../../include/dao/user_manager.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>user_service_input<span class="operator">)</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>user_service_output<span class="operator">)</span>
QX_REGISTER_CPP_QX_SERVICE<span class="operator">(</span>user_service<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>user_service_input<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> user_service_input<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> user_service_input<span class="operator">::</span>user<span class="operator">,</span><span class="string"> "user"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> user_service_input<span class="operator">::</span>criteria<span class="operator">,</span><span class="string"> "criteria"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>user_service_output<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> user_service_output<span class="operator">::</span>user<span class="operator">,</span><span class="string"> "user"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> user_service_output<span class="operator">::</span>list_of_users<span class="operator">,</span><span class="string"> "list_of_users"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>user_service<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>insert<span class="operator">,</span><span class="string"> "insert"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>update<span class="operator">,</span><span class="string"> "update"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>remove<span class="operator">,</span><span class="string"> "remove"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>remove_all<span class="operator">,</span><span class="string"> "remove_all"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>fetch_by_id<span class="operator">,</span><span class="string"> "fetch_by_id"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>fetch_all<span class="operator">,</span><span class="string"> "fetch_all"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> user_service<span class="operator">::</span>get_by_criteria<span class="operator">,</span><span class="string"> "get_by_criteria"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx
</span><span class="pre">
#ifdef _QX_SERVICE_MODE_CLIENT
</span><span class="type">
void</span> user_service<span class="operator">::</span>insert<span class="operator">()            {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "insert"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>update<span class="operator">()            {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "update"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>remove<span class="operator">()            {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "remove"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>remove_all<span class="operator">()        {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "remove_all"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>fetch_by_id<span class="operator">()       {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "fetch_by_id"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>fetch_all<span class="operator">()         {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "fetch_all"</span><span class="operator">); }</span><span class="type">
void</span> user_service<span class="operator">::</span>get_by_criteria<span class="operator">()   {</span> qx<span class="operator">::</span>service<span class="operator">::</span>execute_client<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "get_by_criteria"</span><span class="operator">); }</span><span class="pre">

#else // _QX_SERVICE_MODE_CLIENT
</span><span class="type">
void</span> user_service<span class="operator">::</span>insert<span class="operator">()
{</span>
   user_service_input_ptr input<span class="operator"> =</span> getInputParameter<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> input<span class="operator">) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span><span class="string"> "invalid input parameter to call service 'user_service::insert()'"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>insert<span class="operator">(</span>input<span class="operator">-&gt;</span>user<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">());</span><span class="flow"> return</span><span class="operator">; }</span>
   user_service_output_ptr output<span class="operator"> =</span> user_service_output_ptr<span class="operator">(</span><span class="keyword">new</span> user_service_output<span class="operator">());</span>
   output<span class="operator">-&gt;</span>user<span class="operator"> =</span> input<span class="operator">-&gt;</span>user<span class="operator">;</span>
   setOutputParameter<span class="operator">(</span>output<span class="operator">);</span>
   setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">);
}</span><span class="type">

void</span> user_service<span class="operator">::</span>update<span class="operator">()
{</span>
   user_service_input_ptr input<span class="operator"> =</span> getInputParameter<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> input<span class="operator">) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span><span class="string"> "invalid input parameter to call service 'user_service::update()'"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>update<span class="operator">(</span>input<span class="operator">-&gt;</span>user<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">()); }</span><span class="flow">
   else</span><span class="operator"> {</span> setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">); }
}</span><span class="type">

void</span> user_service<span class="operator">::</span>remove<span class="operator">()
{</span>
   user_service_input_ptr input<span class="operator"> =</span> getInputParameter<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> input<span class="operator">) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span><span class="string"> "invalid input parameter to call service 'user_service::remove()'"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   user_ptr user_tmp<span class="operator"> =</span> user_ptr<span class="operator">(</span><span class="keyword">new</span> user<span class="operator">());</span>
   user_tmp<span class="operator">-&gt;</span>id<span class="operator"> =</span> input<span class="operator">-&gt;</span>id<span class="operator">;</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>remove<span class="operator">(</span>user_tmp<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">()); }</span><span class="flow">
   else</span><span class="operator"> {</span> setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">); }
}</span><span class="type">

void</span> user_service<span class="operator">::</span>remove_all<span class="operator">()
{</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>remove_all<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">()); }</span><span class="flow">
   else</span><span class="operator"> {</span> setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">); }
}</span><span class="type">

void</span> user_service<span class="operator">::</span>fetch_by_id<span class="operator">()
{</span>
   user_service_input_ptr input<span class="operator"> =</span> getInputParameter<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> input<span class="operator">) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span><span class="string"> "invalid input parameter to call service 'user_service::fetch_by_id()'"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   user_ptr user_output<span class="operator"> =</span> user_ptr<span class="operator">(</span><span class="keyword">new</span> user<span class="operator">());</span>
   user_output<span class="operator">-&gt;</span>id<span class="operator"> =</span> input<span class="operator">-&gt;</span>id<span class="operator">;</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>fetch_by_id<span class="operator">(</span>user_output<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">());</span><span class="flow"> return</span><span class="operator">; }</span>
   user_service_output_ptr output<span class="operator"> =</span> user_service_output_ptr<span class="operator">(</span><span class="keyword">new</span> user_service_output<span class="operator">());</span>
   output<span class="operator">-&gt;</span>user<span class="operator"> =</span> user_output<span class="operator">;</span>
   setOutputParameter<span class="operator">(</span>output<span class="operator">);</span>
   setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">);
}</span><span class="type">

void</span> user_service<span class="operator">::</span>fetch_all<span class="operator">()
{</span>
   list_of_users_ptr list_of_users_output<span class="operator"> =</span> list_of_users_ptr<span class="operator">(</span><span class="keyword">new</span> list_of_users<span class="operator">());</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>fetch_all<span class="operator">(</span>list_of_users_output<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">());</span><span class="flow"> return</span><span class="operator">; }</span>
   user_service_output_ptr output<span class="operator"> =</span> user_service_output_ptr<span class="operator">(</span><span class="keyword">new</span> user_service_output<span class="operator">());</span>
   output<span class="operator">-&gt;</span>list_of_users<span class="operator"> =</span> list_of_users_output<span class="operator">;</span>
   setOutputParameter<span class="operator">(</span>output<span class="operator">);</span>
   setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">);
}</span><span class="type">

void</span> user_service<span class="operator">::</span>get_by_criteria<span class="operator">()
{</span>
   user_service_input_ptr input<span class="operator"> =</span> getInputParameter<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> input<span class="operator">) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span><span class="string"> "invalid input parameter to call service 'user_service::get_by_criteria()'"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span>
   list_of_users_ptr list_of_users_output<span class="operator"> =</span> list_of_users_ptr<span class="operator">(</span><span class="keyword">new</span> list_of_users<span class="operator">());</span>
   QSqlError err<span class="operator"> =</span> user_manager<span class="operator">().</span>get_by_criteria<span class="operator">(</span>input<span class="operator">-&gt;</span>criteria<span class="operator">,</span> list_of_users_output<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> setMessageReturn<span class="operator">(</span><span class="int">0</span><span class="operator">,</span> err<span class="operator">.</span>text<span class="operator">());</span><span class="flow"> return</span><span class="operator">; }</span>
   user_service_output_ptr output<span class="operator"> =</span> user_service_output_ptr<span class="operator">(</span><span class="keyword">new</span> user_service_output<span class="operator">());</span>
   output<span class="operator">-&gt;</span>list_of_users<span class="operator"> =</span> list_of_users_output<span class="operator">;</span>
   setOutputParameter<span class="operator">(</span>output<span class="operator">);</span>
   setMessageReturn<span class="operator">(</span><span class="bool">true</span><span class="operator">);
}</span><span class="pre">

#endif // _QX_SERVICE_MODE_CLIENT
</span></pre>
        </td></tr></tbody></table>
        <br>
        A ce niveau du tutoriel, notre serveur d'applications C++ est terminé et propose plusieurs services.<br>
        Il reste à présent à écrire le code client qui va appeler tous les services que nous avons mis en place...<br>
        <br><br>
        <b><a name="tuto_30"><u><font color="#100D5A">3- Création de l'interface cliente : <i>qxClient</i></font></u></a></b>
        <br><br>
        De la même façon que le projet <i>qxServer</i>, le projet <i>qxClient</i> possède une interface utilisateur construite avec l'outil <b>Qt Designer</b> de la bibliothèque Qt.<br>
        Cette interface possède plusieurs boutons pour appeler l'ensemble des services proposés par notre serveur d'applications.<br>
        L'interface permet également d'indiquer une adresse ip et un numéro de port pour se connecter au serveur d'applications.<br>
        <br>
        <img alt="gui_qxClient" src="./resource/gui_qxClient_01.jpg" width="549" height="405" style="border:0px solid #100D5A; border-color:#100D5A;">
        <br><br>
        <a name="tuto_301"><u><font color="#100D5A">3.1- Description de la méthode <i>onClickBtnDateTime()</i></font></u></a>
        <br><br>
        Comment récupérer la date-heure courante du serveur d'applications ?<br>
        Voici le code qui s'exécute lorsque l'utilisateur clique sur le bouton <i>Get Server DateTime</i> :<br>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTime()">
        <pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTime<span class="operator">()
{</span><span class="comment">
   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur
</span>   server_infos service<span class="operator">;</span>
   service<span class="operator">.</span>get_current_date_time<span class="operator">();</span><span class="comment">
   // Affiche la dernière transaction au format XML (ou JSON)
</span>   updateLastTransactionLog<span class="operator">(</span>service<span class="operator">.</span>getTransaction<span class="operator">());</span><span class="operator">
}</span></pre>
        </td></tr></tbody></table>
        <br>
        <b>Comme vous pouvez le constater, la partie cliente n'a aucun code spécifique à écrire pour pouvoir appeler un service</b>.<br>
        Il suffit d'instancier un service, puis d'appeler la méthode qui nous intéresse : <i>get_current_date_time()</i>.<br>
        La méthode <i>updateLastTransactionLog()</i> permet d'afficher la dernière transaction client-serveur (au format XML ou JSON) exécutée.<br>
        Si une erreur s'est produite, alors un message apparaît à l'écran pour le signaler à l'utilisateur.<br>
        Pour savoir si le service s'est exécuté correctement, il faut utiliser la méthode : <i>service.getMessageReturn();</i> (de type <i>qx_bool</i> qui peut contenir un code et un libellé d'une éventuelle erreur).<br>
        Enfin, pour récupérer la réponse du serveur (donc sa date-heure courante), il faut utiliser la méthode : <i>service.getOutputParameter();</i> (de type <i>user_service_output_ptr</i>).<br>
        <br>
        <a name="tuto_302"><u><font color="#100D5A">3.2- Description de la méthode <i>onClickBtnDateTimeAsync()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTimeAsync(), main_dlg::onDateTimeAsyncFinished()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTimeAsync<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDateTimeAsync<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] '%s' transaction is already running"</span><span class="operator">,</span><span class="string"> "server_infos::get_current_date_time"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">
   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur (mode asynchrone)
</span>   server_infos_ptr service<span class="operator"> =</span> server_infos_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxClientAsync<span class="operator">());</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pDateTimeAsync<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>finished<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onDateTimeAsyncFinished<span class="operator">()));</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>setService<span class="operator">(</span>service<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">);</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>start<span class="operator">();
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onDateTimeAsyncFinished<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_pDateTimeAsync<span class="operator"> || !</span> m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()) {</span><span class="flow"> return</span><span class="operator">; }</span>
   updateLastTransactionLog<span class="operator">(</span>m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()-&gt;</span>getTransaction<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">();
}</span></pre>
        </td></tr></tbody></table>
        <br>
        Ce second exemple correspond au bouton <i>Get Server DateTime Async</i> de l'interface utilisateur.<br>
        Il montre comment appeler un service de manière asynchrone, c'est-à-dire <b>sans bloquer l'IHM</b> en attendant la réponse du serveur.<br>
        La bibliothèque <b>QxOrm</b> propose la classe <i>qx::service::QxClientAsync</i> pour simplifier les appels asynchrones.<br>
        <br>
        Le mécanisme des appels asynchrones avec le module <b>QxService</b> est très simple :
        <ul>
          <li>création d'une instance d'un service ;</li>
          <li>création d'une instance de type <i>qx::service::QxClientAsync</i> ;</li>
          <li>connexion à l'évènement <i>finished</i> (pour indiquer qu'une réponse du serveur vient d'arriver) ;</li>
          <li>passage de l'instance du service et de la méthode à appeler (sous forme de chaine de caractères) à l'objet <i>qx::service::QxClientAsync</i> ;</li>
          <li>démarrage de la transaction avec l'appel de la méthode <i>start()</i>.</li>
        </ul>
        <a name="tuto_303"><u><font color="#100D5A">3.3- Description de la méthode <i>onClickBtnAddUser()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnAddUser()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnAddUser<span class="operator">()
{</span><span class="comment">
   // Création des paramètres d'entrée contenant l'utilisateur à ajouter en BDD
</span>   user_service_input_ptr input<span class="operator"> =</span> user_service_input_ptr<span class="operator">(</span><span class="keyword">new</span> user_service_input<span class="operator">());</span>
   input<span class="operator">-&gt;</span>user<span class="operator"> =</span> fileUser<span class="operator">();</span><span class="comment">
   // Création d'une instance de service et association des paramètres d'entrée
</span>   user_service service<span class="operator">;</span>
   service<span class="operator">.</span>setInputParameter<span class="operator">(</span>input<span class="operator">);</span>
   service<span class="operator">.</span>insert<span class="operator">();</span><span class="comment">
   // Si la transaction s'est déroulée correctement, on affiche l'identifiant qui vient d'être ajouté en BDD
</span>   user_ptr output<span class="operator"> = (</span>service<span class="operator">.</span>isValidWithOutput<span class="operator">() ?</span> service<span class="operator">.</span>getOutputParameter<span class="operator">()-&gt;</span>user<span class="operator"> :</span> user_ptr<span class="operator">());</span><span class="flow">
   if</span><span class="operator"> (</span>output<span class="operator">) {</span> fillUser<span class="operator">(</span>output<span class="operator">); }</span><span class="comment">
   // Affiche la dernière transaction au format XML (ou JSON)
</span>   updateLastTransactionLog<span class="operator">(</span>service<span class="operator">.</span>getTransaction<span class="operator">());</span><span class="operator">
}</span></pre>
        </td></tr></tbody></table>
        <br>
        Ce 3ème exemple correspond au bouton <i>Add</i> dans la section <i>User transaction</i>.<br>
        Il permet à l'utilisateur d'ajouter une nouvelle personne dans la base de données.<br>
        Cet exemple nous montre comment passer une structure (classe <i>user</i>) en paramètre d'entrée d'un service.<br>
        La méthode <i>fileUser()</i> permet de créer une instance de type <i>user</i> et de valoriser ses propriétés en fonction des champs de l'IHM.<br>
        Cette instance est ensuite utilisée comme paramètre d'entrée de notre service.<br>
        Si la transaction s'est déroulée correctement, le paramètre de retour (réponse du serveur) contient lui aussi une instance de type <i>user</i> avec le nouvel identifiant qui vient d'être ajouté en base de données.<br>
        On utilise alors la méthode <i>fillUser()</i> pour mettre à jour l'interface utilisateur en fonction de la réponse du serveur et afficher ainsi le nouvel identifiant.<br>
        <br>
        <a name="tuto_304"><u><font color="#100D5A">3.4- Description de la méthode <i>onClickBtnGetAllUsers()</i></font></u></a>
        <br><br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnGetAllUsers()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnGetAllUsers<span class="operator">()
{</span><span class="comment">
   // Création d'une instance de service
</span>   user_service service<span class="operator">;</span>
   service<span class="operator">.</span>fetch_all<span class="operator">();</span><span class="comment">
   // Si la transaction s'est déroulée correctement, affiche un message avec le nombre d'utilisateurs stockés en BDD
</span>   list_of_users_ptr output<span class="operator"> = (</span>service<span class="operator">.</span>isValidWithOutput<span class="operator">() ?</span> service<span class="operator">.</span>getOutputParameter<span class="operator">()-&gt;</span>list_of_users<span class="operator"> :</span> list_of_users_ptr<span class="operator">());</span><span class="flow">
   if</span><span class="operator"> (</span>output<span class="operator">) {</span> QMessageBox<span class="operator">::</span>information<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span><span class="string"> "qxClient - get all users"</span><span class="operator">,</span><span class="string"> "database contains '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>output<span class="operator">-&gt;</span>size<span class="operator">()) +</span><span class="string"> "' user(s)."</span><span class="operator">); }</span><span class="comment">
   // Affiche la dernière transaction au format XML (ou JSON)
</span>   updateLastTransactionLog<span class="operator">(</span>service<span class="operator">.</span>getTransaction<span class="operator">());</span><span class="operator">
}</span></pre>
        </td></tr></tbody></table>
        <br>
        Ce 4ème exemple correspond au bouton <i>Get All</i> de la section <i>User transaction</i>.<br>
        Il permet de récupérer la liste de tous les <i>user</i> présents dans la base de données.<br>
        Le paramètre de retour est une liste fortement typée : il est possible d'utiliser les collections des bibliothèques <i>stl</i>, <i>boost</i>, <i>Qt</i> ou <i>qx::QxCollection</i>.<br>
        Le module <b>QxService</b> permet donc d'<b>échanger des structures complexes entre client et serveur</b>.<br>
        <br>
        A présent, bon courage avec le module <b>QxService</b>... ;o)
        <br>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2017 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
